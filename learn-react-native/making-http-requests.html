<!DOCTYPE html>
<!--####################################################################
	THIS IS A GENERATED FILE — ANY CHANGES MADE WILL BE OVERWRITTEN

	INSTEAD CHANGE:
	source: src/react-native/10-making-http-requests/making-http-requests.md
	@page learn-react-native/making-http-requests
######################################################################## -->
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="google-site-verification" content="UMCgjrWAjJW_tHmYo6AerdZvVdmh8QHdY9Ywb59tpHw" />
  <meta name="description" content="Learn about how to make &#x60;fetch&#x60; requests and render requested data in React components. 
">
  
  <!-- Google Tag Manager -->
  <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-P9MQVJS');</script>
  <!-- End Google Tag Manager -->

  <title>Bitovi Academy - Making HTTP Requests</title>
  
  <link rel="stylesheet" type="text/css" href="../static/bundles/bit-docs-site/static.css">
  
</head>

<body>
  <!-- Google Tag Manager (noscript) -->
  <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-P9MQVJS"
  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  <!-- End Google Tag Manager (noscript) -->
  
  <div class="header">
    <div class="logo">
      <a href="https://www.bitovi.com/">Bitovi</a>
    </div>
    <ul>
      <li><a href="https://www.bitovi.com/services">Services</a></li>
      <li><a href="https://www.bitovi.com/client-work">Client Work</a></li>
      <li><a href="https://www.bitovi.com/about">Our Team</a></li>
      <li><a href="https://www.bitovi.com/open-source">Open Source</a></li>
      <li><a href="https://www.bitovi.com/blog">Blog</a></li>
      <li><a href=".." class="active">Academy</a></li>
     </ul>
     <a class="contact-popup hs-button brand button-smallest" href="https://www.bitovi.com/contact">Contact Us</a>
  </div>

  <div class="content">
	
		<div class="sidebar-left">
  
    

  
  <p class="border">
      <a href="..#courses">View More Courses</a>
      <a class='bit-academy-fullscreen' title='fullscreen' href="javascript://">[ ]</a>
  </p>
</div>

	
	<article class="main">
    <div class="main-content">
  		
  			<section class="title">
	<h1>Making HTTP Requests <code>page</code></h1>
</section>

  		

  		
  			
  				<section class="description">
    <p>Learn about how to make <code>fetch</code> requests and render requested data in React components.</p>

</section>

  			
  		

  		
  			
  				
  			
  			
  				<section class="body">
    <h2>Overview</h2>
<p>TODO</p>
<h2>Objective 1: Add a <code>fetch</code> request for states</h2>
<p>In this section, we will:</p>
<ul>
<li>Learn about the <code>useEffect</code> Hook</li>
<li>TODO: Review TypeScript generics?</li>
</ul>
<h3>The <code>useEffect</code> Hook</h3>
<p><code>useEffect</code> is a React Hook that lets you perform side effects in your functional components.
It serves as a powerful tool to execute code in response to component renders or state changes.</p>
<p>Here is an example component with <code>useEffect</code>:</p>
<pre><code class="language-tsx">import { useEffect, useState } from 'react';

const GeolocationComponent: React.FC = () =&gt; {
    const [location, setLocation] = useState(null);

    useEffect(() =&gt; { // Effect callback function
        navigator.geolocation.getCurrentPosition(position =&gt; {
            setLocation(position.coords);
        }, (error) =&gt; {
            console.error(error);
        });
    }, []); // Dependency array

    return (
        &lt;main&gt;
            {location ? (
                &lt;p&gt;
                    Latitude: {location.latitude},
                    Longitude: {location.longitude}
                &lt;/p&gt;
            ) : (
                &lt;p&gt;Requesting location…&lt;/p&gt;
            )}
        &lt;/main&gt;
    );
}

export default GeolocationComponent;

</code></pre>
<div line-highlight='1, 6-12, only'></div>
<p>Let’s break this example down by the two arguments that <code>useEffect</code> takes:</p>
<h4>Effect callback function</h4>
<p>The first argument of <code>useEffect</code> is a function, often referred to as the “effect” function.
This is where you perform your side effects, such as fetching data, setting up a subscription,
or manually changing the DOM in React components.</p>
<p>The key aspect of this function is that it’s executed after the component renders. The effects
in <code>useEffect</code> don’t block the browser from updating the screen, leading to more responsive UIs.</p>
<p>This effect function can optionally return another function, known as the “cleanup” function.
The cleanup function is useful for performing any necessary cleanup activities when the component
unmounts or before the component re-renders and the effect is re-invoked. Common examples include
clearing timers, canceling network requests, or removing event listeners.</p>
<h4>The dependency array</h4>
<p>The second argument of <code>useEffect</code> is an array, called the “dependency array”, which determines
when your effect function should be called. The behavior of the effect changes based on the
contents of this array:</p>
<p>Consider three scenarios based on the dependency array:</p>
<h5>Empty dependency array (<code>[]</code>)</h5>
<p>If the dependency array is an empty array, the effect runs once
after the initial render.</p>
<pre><code class="language-tsx">import { useEffect, useState } from 'react';

const GeolocationComponent: React.FC = () =&gt; {
    const [location, setLocation] = useState(null);

    useEffect(() =&gt; { // Effect callback function
        navigator.geolocation.getCurrentPosition(position =&gt; {
            setLocation(position.coords);
        }, (error) =&gt; {
            console.error(error);
        });
    }, []); // Dependency array

    return (
        &lt;main&gt;
            {location ? (
                &lt;p&gt;
                    Latitude: {location.latitude},
                    Longitude: {location.longitude}
                &lt;/p&gt;
            ) : (
                &lt;p&gt;Requesting location…&lt;/p&gt;
            )}
        &lt;/main&gt;
    );
}

export default GeolocationComponent;

</code></pre>
<div line-highlight='6-12, only'></div>
<h5>Array with values</h5>
<p>When you include values (variables, props, state) in the dependency array,
the effect will only re-run if those specific values change between renders. This selective
execution can optimize performance by avoiding unnecessary work.</p>
<pre><code class="language-tsx">import { useEffect, useState } from 'react';

function NameStorage() {
    const [name, setName] = useState('');

    useEffect(() =&gt; {
        localStorage.setItem('name', name);
    }, [name]);

    return (
        &lt;label&gt;
            Name
            &lt;input
                onChange={event =&gt; setName(event.target.value)}
                type=&quot;text&quot;
                value={name}
            /&gt;
        &lt;/label&gt;
    );
}

export default NameStorage;
</code></pre>
<div line-highlight='4, 7-8, only'></div>
<h5>No dependency array</h5>
<p>If the dependency array is omitted, the effect runs after every render
of the component.</p>
<pre><code class="language-tsx">import { useEffect, useState } from 'react';

function UpdateLogger() {
    const [count, setCount] = useState(0);

    useEffect(() =&gt; {
        console.info('Component updated!');
    }); // No dependency array, runs on every update

    return (
        &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
            Increment
        &lt;/button&gt;
    );
}

export default UpdateLogger;

</code></pre>
<div line-highlight='8, only'></div>
<h4>Async operations inside useEffect</h4>
<p>You can use APIs that return a <code>Promise</code> normally within a <code>useEffect</code>:</p>
<pre><code class="language-tsx">import { useEffect, useState } from 'react';

function DataFetcher() {
    const [data, setData] = useState(null);

    useEffect(() =&gt; {
        fetch('https://api.example.com/data')
            .then(response =&gt; {
                const parsedData = response.json();
                setData(parsedData);
            })
            .catch(error =&gt; {
                // Error should be shown to the user
                console.error('Error fetching data:', error)
            });
    }, []);

    return (
        &lt;p&gt;{data}&lt;/p&gt;
    );
}

export default DataFetcher;

</code></pre>
<div line-highlight='7-15, only'></div>
<p>However, unlike traditional functions, <code>useEffect</code> functions can’t be marked as async.
This is because returning a <code>Promise</code> from <code>useEffect</code> would conflict with its mechanism,
which expects either nothing or a clean-up function to be returned.</p>
<p>To handle asynchronous operations, you typically define an <code>async</code> function inside the
effect and then call it:</p>
<pre><code class="language-tsx">import { useEffect, useState } from 'react';

function DataFetcher() {
    const [data, setData] = useState(null);

    useEffect(() =&gt; {
        const fetchData = async () =&gt; {
            try {
                const response = await fetch('https://api.example.com/data');
                const parsedData = response.json();
                setData(parsedData);
            } catch (error) {
                // Error should be shown to the user
                console.error('Error fetching data:', error)
            }
        };

        fetchData();
    }, []);

    return (
        &lt;p&gt;{data}&lt;/p&gt;
    );
}

export default DataFetcher;

</code></pre>
<div line-highlight='7-18, only'></div>
<p>When using async/await, error handling is typically done using try-catch blocks. This allows
you to gracefully handle any errors that occur during the execution of your async operation.</p>
<p>In this example, if <code>fetch</code> throws an error, the <code>catch</code> block catches and handles it.
This pattern is crucial to prevent unhandled promise rejections and ensure that your application
can respond appropriately to failures in asynchronous tasks.</p>
<h3>TypeScript generics</h3>
<p>TODO? We’ve used generics, but maybe explain the ones we’re going to use so it’s a little familiar?</p>
<h3>Cleanup functions</h3>
<p>The effect function can optionally return another function, known as the “cleanup” function. The cleanup function is useful for performing any necessary cleanup activities when the component unmounts or before the component re-renders and the effect is re-invoked. Common examples include clearing timers, canceling network requests, or removing event listeners.</p>
<pre><code class="language-tsx">import { useEffect, useState } from 'react';

function WebSocketComponent() {
  const [messages, setMessages] = useState([]);

  useEffect(() =&gt; {
    const socket = new WebSocket('wss://chat.donejs.com/');

    socket.onmessage = (event) =&gt; {
      setMessages(previousMessages =&gt; {
        return [ ...previousMessages, event.data ];
      });
    };

    return () =&gt; {
      // Clean up (tear down) the socket connection
      return socket.close();
    };
  }, []);

  return (
    &lt;ol&gt;
      {messages.map((message) =&gt; (
        &lt;li key={message}&gt;{message}&lt;/li&gt;
      ))}
    &lt;/ol&gt;
  );
}

export default WebSocketComponent;

</code></pre>
<div line-highlight='7-21, only'></div>
<p>In the example above, we’re creating a WebSocket connection to an API when the component
is first rendered (note the empty dependency array).</p>
<p>When the component is removed from the DOM, the cleanup function will run and tear down
the WebSocket connection.</p>
<h3>Environment variables</h3>
<p>The way we’re accessing our locally run API during development may be different than how
we access it in production. To prepare for this, we’ll set an environment variable to do
what we need.</p>
<p>TODO: Explain that setting environment variables is a generic thing you do, and on this
project in particular, Vite will make anything prefixed with <code>VITE_</code> available in our
client-side source code.</p>
<h3>Setup</h3>
<p>✏️ Create <strong>.env</strong> and update it to be:</p>
<pre><code>VITE_PMO_API = '//localhost:7070'
</code></pre>
<div line-highlight='1'></div>
<p>✏️ Update <strong>src/pages/RestaurantList/RestaurantList.tsx</strong> to be:</p>
<pre><code class="language-tsx">import type { State } from &quot;../../services/restaurant/interfaces&quot;
import CheeseThumbnail from &quot;place-my-order-assets/images/2-thumbnail.jpg&quot;
import PoutineThumbnail from &quot;place-my-order-assets/images/4-thumbnail.jpg&quot;
import { useEffect, useState } from &quot;react&quot;
import ListItem from &quot;./ListItem&quot;
import { useCities } from &quot;../../services/restaurant/hooks&quot;

interface StatesResponse {
  data: State[] | null
  error: Error | null
  isPending: boolean
}

const RestaurantList: React.FC = () =&gt; {
  const [state, setState] = useState(&quot;&quot;)
  const [city, setCity] = useState(&quot;&quot;)

  const states = [
    { name: &quot;Illinois&quot;, short: &quot;IL&quot; },
    { name: &quot;Wisconsin&quot;, short: &quot;WI&quot; },
  ]

  const cities = useCities(state)

  const restaurants = {
    data: [
      {
        name: &quot;Cheese Curd City&quot;,
        slug: &quot;cheese-curd-city&quot;,
        images: {
          thumbnail: CheeseThumbnail,
        },
        address: {
          street: &quot;2451 W Washburne Ave&quot;,
          city: &quot;Green Bay&quot;,
          state: &quot;WI&quot;,
          zip: &quot;53295&quot;,
        },
        _id: &quot;Ar0qBJHxM3ecOhcr&quot;,
      },
      {
        name: &quot;Poutine Palace&quot;,
        slug: &quot;poutine-palace&quot;,
        images: {
          thumbnail: PoutineThumbnail,
        },
        address: {
          street: &quot;230 W Kinzie Street&quot;,
          city: &quot;Green Bay&quot;,
          state: &quot;WI&quot;,
          zip: &quot;53205&quot;,
        },
        _id: &quot;3ZOZyTY1LH26LnVw&quot;,
      },
    ],
  }

  const updateState = (stateShortCode: string) =&gt; {
    setState(stateShortCode)
    setCity(&quot;&quot;)
  }

  const updateCity = (cityName: string) =&gt; {
    setCity(cityName)
  }

  return (
    &lt;&gt;
      &lt;div className=&quot;restaurants&quot;&gt;
        &lt;h2 className=&quot;page-header&quot;&gt;Restaurants&lt;/h2&gt;

        &lt;form className=&quot;form&quot;&gt;
          &lt;div className=&quot;form-group&quot;&gt;
            &lt;label className=&quot;control-label&quot; htmlFor=&quot;stateSelect&quot;&gt;
              State
            &lt;/label&gt;
            &lt;select
              className=&quot;form-control&quot;
              id=&quot;stateSelect&quot;
              onChange={(event) =&gt; updateState(event.target.value)}
              value={state}
            &gt;
              &lt;option key=&quot;choose_state&quot; value=&quot;&quot;&gt;
                {statesResponse.isPending
                  ? &quot;Loading states…&quot;
                  : statesResponse.error
                    ? statesResponse.error.message
                    : &quot;Choose a state&quot;}
              &lt;/option&gt;
              {statesResponse.data?.map(({ short, name }) =&gt; (
                &lt;option key={short} value={short}&gt;
                  {name}
                &lt;/option&gt;
              ))}
            &lt;/select&gt;
          &lt;/div&gt;

          &lt;div className=&quot;form-group&quot;&gt;
            City:
            {state ? (
              cities.map(({ name }) =&gt; (
                &lt;button
                  key={name}
                  onClick={() =&gt; updateCity(name)}
                  type=&quot;button&quot;
                &gt;
                  {name}
                &lt;/button&gt;
              ))
            ) : (
              &lt;&gt; Choose a state before selecting a city&lt;/&gt;
            )}
            &lt;hr /&gt;
            &lt;p&gt;Current city: {city || &quot;(none)&quot;}&lt;/p&gt;
          &lt;/div&gt;
        &lt;/form&gt;

        {restaurants.data ? (
          restaurants.data.map(({ _id, address, images, name, slug }) =&gt; (
            &lt;ListItem
              key={_id}
              address={address}
              name={name}
              slug={slug}
              thumbnail={images.thumbnail}
            /&gt;
          ))
        ) : (
          &lt;p&gt;No restaurants.&lt;/p&gt;
        )}
      &lt;/div&gt;
    &lt;/&gt;
  )
}

export default RestaurantList

</code></pre>
 <div line-highlight="1,4,8-11,74-91,93-95,107,134,only"></div>
<h4>Install the Place My Order API</h4>
<p>Before we begin requesting data from our API, we need to install the
<code>place-my-order-api</code> module, which will generate fake restaurant data and
serve it from port <code>7070</code>.</p>
<p>✏️ Run:</p>
<pre><code class="language-bash">npm install place-my-order-api@1
</code></pre>
<p>✏️ Next add an API script to your <code>package.json</code></p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;place-my-order&quot;,
  &quot;private&quot;: true,
  &quot;version&quot;: &quot;0.0.0&quot;,
  &quot;type&quot;: &quot;module&quot;,
  &quot;scripts&quot;: {
    &quot;typecheck&quot;: &quot;tsc&quot;,
    &quot;eslint&quot;: &quot;eslint vite.config.ts src&quot;,
    &quot;prettier&quot;: &quot;prettier --check vite.config.ts src&quot;,
    &quot;test&quot;: &quot;vitest&quot;,
    &quot;dev&quot;: &quot;vite&quot;,
    &quot;build&quot;: &quot;tsc &amp;&amp; vite build&quot;
  },
  &quot;eslintConfig&quot;: {
    &quot;root&quot;: true,
    &quot;extends&quot;: &quot;@bitovi/eslint-config/react&quot;
  },
  &quot;prettier&quot;: {
    &quot;semi&quot;: false,
    &quot;trailingComma&quot;: &quot;all&quot;
  },
  &quot;dependencies&quot;: {
    &quot;place-my-order-api&quot;: &quot;^1.3.0&quot;,
    &quot;place-my-order-assets&quot;: &quot;^0.2.2&quot;,
    &quot;react&quot;: &quot;^18.2.0&quot;,
    &quot;react-dom&quot;: &quot;^18.2.0&quot;,
    &quot;react-router-dom&quot;: &quot;^6.22.0&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;@bitovi/eslint-config&quot;: &quot;^1.8.0&quot;,
    &quot;@testing-library/jest-dom&quot;: &quot;^6.4.2&quot;,
    &quot;@testing-library/react&quot;: &quot;^14.2.1&quot;,
    &quot;@testing-library/user-event&quot;: &quot;^14.5.2&quot;,
    &quot;@types/react&quot;: &quot;^18.2.43&quot;,
    &quot;@types/react-dom&quot;: &quot;^18.2.17&quot;,
    &quot;@vitejs/plugin-react&quot;: &quot;^4.2.1&quot;,
    &quot;eslint&quot;: &quot;^8.55.0&quot;,
    &quot;jsdom&quot;: &quot;^24.0.0&quot;,
    &quot;prettier&quot;: &quot;^3.2.5&quot;,
    &quot;typescript&quot;: &quot;^5.2.2&quot;,
    &quot;vite&quot;: &quot;^5.0.8&quot;,
    &quot;vitest&quot;: &quot;^1.2.2&quot;
  }
}

</code></pre>
<div line-highlight='7, only'></div>
<p>✏️ In a <strong>new</strong> terminal window, start the API server by running:</p>
<pre><code class="language-bash">npm run api
</code></pre>
<p>Double check the API by navigating to <a href="http://localhost:7070/restaurants">localhost:7070/restaurants</a>.
You should see a JSON list of restaurant data. It will be helpful to have a second terminal tab to run the <code>api</code> command from.</p>
<h3>Verify</h3>
<p>✏️ Update <strong>src/pages/RestaurantList/RestaurantList.test.tsx</strong> to be:</p>
<pre><code class="language-tsx">import &quot;@testing-library/jest-dom&quot;
import { act, render, screen } from &quot;@testing-library/react&quot;
import { describe, expect, it, vi } from &quot;vitest&quot;

import * as restaurantHooks from &quot;../../services/restaurant/hooks&quot;
import RestaurantList from &quot;./RestaurantList&quot;

// Mocking necessary modules
vi.mock(&quot;../../services/restaurant/hooks&quot;)

// Mocking the global fetch function
const mockFetch = vi.fn()

global.fetch = mockFetch

beforeEach(() =&gt; {
  mockFetch.mockClear()

  mockFetch.mockResolvedValueOnce({
    ok: true,
    json: () =&gt; Promise.resolve({ message: &quot;success&quot; }),
    statusText: &quot;OK&quot;,
    status: 200,
  })
})

afterEach(() =&gt; {
  mockFetch.mockClear()
})

describe(&quot;RestaurantList component&quot;, () =&gt; {
  beforeEach(async () =&gt; {
    vi.spyOn(restaurantHooks, &quot;useCities&quot;).mockReturnValue([
      { name: &quot;Green Bay&quot; },
      { name: &quot;Madison&quot; },
    ])
    render(&lt;RestaurantList /&gt;)
    await act(() =&gt; {})
  })

  it(&quot;renders the Restaurants header&quot;, () =&gt; {
    expect(screen.getByText(/Restaurants/i)).toBeInTheDocument()
  })

  it(&quot;renders the restaurant images&quot;, () =&gt; {
    const images = screen.getAllByRole(&quot;img&quot;)
    expect(images[0]).toHaveAttribute(
      &quot;src&quot;,
      expect.stringContaining(&quot;2-thumbnail.jpg&quot;),
    )
    expect(images[0]).toHaveAttribute(&quot;width&quot;, &quot;100&quot;)
    expect(images[0]).toHaveAttribute(&quot;height&quot;, &quot;100&quot;)
    expect(images[1]).toHaveAttribute(
      &quot;src&quot;,
      expect.stringContaining(&quot;4-thumbnail.jpg&quot;),
    )
    expect(images[1]).toHaveAttribute(&quot;width&quot;, &quot;100&quot;)
    expect(images[1]).toHaveAttribute(&quot;height&quot;, &quot;100&quot;)
  })

  it(&quot;renders the addresses&quot;, () =&gt; {
    const addressDivs = screen.getAllByText(/Washburne Ave|Kinzie Street/i)
    expect(addressDivs[0]).toHaveTextContent(&quot;2451 W Washburne Ave&quot;)
    expect(addressDivs[0]).toHaveTextContent(&quot;Green Bay, WI 53295&quot;)
    expect(addressDivs[1]).toHaveTextContent(&quot;230 W Kinzie Street&quot;)
    expect(addressDivs[1]).toHaveTextContent(&quot;Green Bay, WI 53205&quot;)
  })

  it(&quot;renders the hours and price information for each restaurant&quot;, () =&gt; {
    const hoursPriceDivs = screen.getAllByText(/\$\$\$/i)
    hoursPriceDivs.forEach((div) =&gt; {
      expect(div).toHaveTextContent(&quot;$$$&quot;)
      expect(div).toHaveTextContent(&quot;Hours: M-F 10am-11pm&quot;)
    })
  })

  it(&quot;indicates if the restaurant is open now for each restaurant&quot;, () =&gt; {
    const openNowTags = screen.getAllByText(&quot;Open Now&quot;)
    expect(openNowTags.length).toBeGreaterThan(0)
  })

  it(&quot;renders the details buttons with correct links for each restaurant&quot;, () =&gt; {
    const detailsButtons = screen.getAllByRole(&quot;link&quot;)
    expect(detailsButtons[0]).toHaveAttribute(
      &quot;href&quot;,
      &quot;/restaurants/cheese-curd-city&quot;,
    )
    expect(detailsButtons[1]).toHaveAttribute(
      &quot;href&quot;,
      &quot;/restaurants/poutine-palace&quot;,
    )
    detailsButtons.forEach((button) =&gt; {
      expect(button).toHaveTextContent(&quot;Details&quot;)
    })
  })

  it(&quot;renders ListItem components for each restaurant&quot;, () =&gt; {
    const restaurantNames = screen.getAllByText(
      /Cheese Curd City|Poutine Palace/,
    )
    expect(restaurantNames.length).toBe(2)
  })
})

</code></pre>
 <div line-highlight="2-3,5,8-9,11-12,14,16-17,19-23,27-29,32-36,38,103,only"></div>
<h3>Exercise</h3>
<ul>
<li>Update <code>RestaurantList.tsx</code> to call <code>useState()</code> and use the <code>StateResponse</code> interface.</li>
<li>Call <code>useEffect()</code> and <code>fetch</code> data from <code>${import.meta.env.VITE_PMO_API}/states</code>.</li>
</ul>
<p>Hint: Call your state setter after you parse the JSON response from <code>fetch()</code>.</p>
<h3>Solution</h3>
<p><details>
<summary>Click to see the solution</summary></p>
<p>✏️ Update <strong>src/pages/RestaurantList/RestaurantList.tsx</strong> to be:</p>
<pre><code class="language-tsx">import type { State } from &quot;../../services/restaurant/interfaces&quot;
import CheeseThumbnail from &quot;place-my-order-assets/images/2-thumbnail.jpg&quot;
import PoutineThumbnail from &quot;place-my-order-assets/images/4-thumbnail.jpg&quot;
import { useEffect, useState } from &quot;react&quot;
import ListItem from &quot;./ListItem&quot;
import { useCities } from &quot;../../services/restaurant/hooks&quot;

interface StatesResponse {
  data: State[] | null
  error: Error | null
  isPending: boolean
}

const RestaurantList: React.FC = () =&gt; {
  const [state, setState] = useState(&quot;&quot;)
  const [city, setCity] = useState(&quot;&quot;)

  const [statesResponse, setStatesResponse] = useState&lt;StatesResponse&gt;({
    data: null,
    error: null,
    isPending: true,
  })

  useEffect(() =&gt; {
    const fetchData = async () =&gt; {
      const response = await fetch(`${import.meta.env.VITE_PMO_API}/states`, {
        method: &quot;GET&quot;,
      })

      const data = await response.json()

      setStatesResponse({
        data: data?.data || null,
        error: null,
        isPending: false,
      })
    }
    fetchData()
  }, [])

  const cities = useCities(state)

  const restaurants = {
    data: [
      {
        name: &quot;Cheese Curd City&quot;,
        slug: &quot;cheese-curd-city&quot;,
        images: {
          thumbnail: CheeseThumbnail,
        },
        address: {
          street: &quot;2451 W Washburne Ave&quot;,
          city: &quot;Green Bay&quot;,
          state: &quot;WI&quot;,
          zip: &quot;53295&quot;,
        },
        _id: &quot;Ar0qBJHxM3ecOhcr&quot;,
      },
      {
        name: &quot;Poutine Palace&quot;,
        slug: &quot;poutine-palace&quot;,
        images: {
          thumbnail: PoutineThumbnail,
        },
        address: {
          street: &quot;230 W Kinzie Street&quot;,
          city: &quot;Green Bay&quot;,
          state: &quot;WI&quot;,
          zip: &quot;53205&quot;,
        },
        _id: &quot;3ZOZyTY1LH26LnVw&quot;,
      },
    ],
  }

  const updateState = (stateShortCode: string) =&gt; {
    setState(stateShortCode)
    setCity(&quot;&quot;)
  }

  const updateCity = (cityName: string) =&gt; {
    setCity(cityName)
  }

  return (
    &lt;&gt;
      &lt;div className=&quot;restaurants&quot;&gt;
        &lt;h2 className=&quot;page-header&quot;&gt;Restaurants&lt;/h2&gt;

        &lt;form className=&quot;form&quot;&gt;
          &lt;div className=&quot;form-group&quot;&gt;
            &lt;label className=&quot;control-label&quot; htmlFor=&quot;stateSelect&quot;&gt;
              State
            &lt;/label&gt;
            &lt;select
              className=&quot;form-control&quot;
              id=&quot;stateSelect&quot;
              onChange={(event) =&gt; updateState(event.target.value)}
              value={state}
            &gt;
              &lt;option key=&quot;choose_state&quot; value=&quot;&quot;&gt;
                {statesResponse.isPending
                  ? &quot;Loading states…&quot;
                  : statesResponse.error
                    ? statesResponse.error.message
                    : &quot;Choose a state&quot;}
              &lt;/option&gt;
              {statesResponse.data?.map(({ short, name }) =&gt; (
                &lt;option key={short} value={short}&gt;
                  {name}
                &lt;/option&gt;
              ))}
            &lt;/select&gt;
          &lt;/div&gt;

          &lt;div className=&quot;form-group&quot;&gt;
            City:
            {state ? (
              cities.map(({ name }) =&gt; (
                &lt;button
                  key={name}
                  onClick={() =&gt; updateCity(name)}
                  type=&quot;button&quot;
                &gt;
                  {name}
                &lt;/button&gt;
              ))
            ) : (
              &lt;&gt; Choose a state before selecting a city&lt;/&gt;
            )}
            &lt;hr /&gt;
            &lt;p&gt;Current city: {city || &quot;(none)&quot;}&lt;/p&gt;
          &lt;/div&gt;
        &lt;/form&gt;

        {restaurants.data ? (
          restaurants.data.map(({ _id, address, images, name, slug }) =&gt; (
            &lt;ListItem
              key={_id}
              address={address}
              name={name}
              slug={slug}
              thumbnail={images.thumbnail}
            /&gt;
          ))
        ) : (
          &lt;p&gt;No restaurants.&lt;/p&gt;
        )}
      &lt;/div&gt;
    &lt;/&gt;
  )
}

export default RestaurantList

</code></pre>
 <div line-highlight="18-22,24-28,30,32-39,only"></div>
<p></details></p>
<h2>Objective 2: Move the fetch to a <code>useStates</code> Hook</h2>
<p>In this section, we will:</p>
<ul>
<li>Refactor our <code>&lt;RestaurantList&gt;</code> component to depend on a custom Hook.</li>
</ul>
<h3>Writing custom Hooks as services</h3>
<p>In a previous section, we created a <code>useCities</code> Hook in our <code>hooks.ts</code> file.</p>
<p>Putting stateful logic into a custom Hook has numerous benefits:</p>
<p><strong>Reusability:</strong> One of the primary reasons for creating custom Hooks is reusability.
You might find yourself repeating the same logic in different components—for
example, fetching data from an API, handling form input, or managing a subscription.
By refactoring this logic into a custom Hook, you can easily reuse this functionality
across multiple components, keeping your code DRY (Don't Repeat Yourself).</p>
<p><strong>Separation of concerns:</strong> Custom Hooks allow you to separate complex logic from the
component logic. This makes your main component code cleaner and more focused on
rendering UI, while the custom Hook handles the business logic or side effects.
It aligns well with the principle of single responsibility, where a function or
module should ideally do one thing only.</p>
<p><strong>Easier testing and maintenance:</strong> Isolating logic into custom Hooks can make your code
easier to test and maintain. Since Hooks are just JavaScript functions, they can be
tested independently of any component. This isolation can lead to more robust and
reliable code.</p>
<p><strong>Simplifying components:</strong> If your component is becoming too large and difficult to
understand, moving some logic to a custom Hook can simplify it. This not only
improves readability but also makes it easier for other developers to grasp what
the component is doing.</p>
<p><strong>Sharing stateful logic:</strong> Custom Hooks can contain stateful logic, which is not
possible with regular JavaScript functions. This means you can have a Hook that
manages its own state and shares this logic across multiple components, something
that would be difficult or impossible with traditional class-based components.</p>
<h3>Setup</h3>
<p>✏️ Update <strong>src/pages/RestaurantList/RestaurantList.tsx</strong> to be:</p>
<pre><code class="language-tsx">import CheeseThumbnail from &quot;place-my-order-assets/images/2-thumbnail.jpg&quot;
import PoutineThumbnail from &quot;place-my-order-assets/images/4-thumbnail.jpg&quot;
import { useState } from &quot;react&quot;
import ListItem from &quot;./ListItem&quot;
import { useCities, useStates } from &quot;../../services/restaurant/hooks&quot;

interface StatesResponse {
  data: State[] | null
  error: Error | null
  isPending: boolean
}

const RestaurantList: React.FC = () =&gt; {
  const [state, setState] = useState(&quot;&quot;)
  const [city, setCity] = useState(&quot;&quot;)

  const [statesResponse, setStatesResponse] = useState&lt;StatesResponse&gt;({
    data: null,
    error: null,
    isPending: true,
  })

  useEffect(() =&gt; {
    const fetchData = async () =&gt; {
      const response = await fetch(`${import.meta.env.VITE_PMO_API}/states`, {
        method: &quot;GET&quot;,
      })

      const data = await response.json()

      setStatesResponse({
        data: data?.data || null,
        error: null,
        isPending: false,
      })
    }
    fetchData()
  }, [])

  const cities = useCities(state)

  const restaurants = {
    data: [
      {
        name: &quot;Cheese Curd City&quot;,
        slug: &quot;cheese-curd-city&quot;,
        images: {
          thumbnail: CheeseThumbnail,
        },
        address: {
          street: &quot;2451 W Washburne Ave&quot;,
          city: &quot;Green Bay&quot;,
          state: &quot;WI&quot;,
          zip: &quot;53295&quot;,
        },
        _id: &quot;Ar0qBJHxM3ecOhcr&quot;,
      },
      {
        name: &quot;Poutine Palace&quot;,
        slug: &quot;poutine-palace&quot;,
        images: {
          thumbnail: PoutineThumbnail,
        },
        address: {
          street: &quot;230 W Kinzie Street&quot;,
          city: &quot;Green Bay&quot;,
          state: &quot;WI&quot;,
          zip: &quot;53205&quot;,
        },
        _id: &quot;3ZOZyTY1LH26LnVw&quot;,
      },
    ],
  }

  const updateState = (stateShortCode: string) =&gt; {
    setState(stateShortCode)
    setCity(&quot;&quot;)
  }

  const updateCity = (cityName: string) =&gt; {
    setCity(cityName)
  }

  return (
    &lt;&gt;
      &lt;div className=&quot;restaurants&quot;&gt;
        &lt;h2 className=&quot;page-header&quot;&gt;Restaurants&lt;/h2&gt;

        &lt;form className=&quot;form&quot;&gt;
          &lt;div className=&quot;form-group&quot;&gt;
            &lt;label className=&quot;control-label&quot; htmlFor=&quot;stateSelect&quot;&gt;
              State
            &lt;/label&gt;
            &lt;select
              className=&quot;form-control&quot;
              id=&quot;stateSelect&quot;
              onChange={(event) =&gt; updateState(event.target.value)}
              value={state}
            &gt;
              &lt;option key=&quot;choose_state&quot; value=&quot;&quot;&gt;
                {statesResponse.isPending
                  ? &quot;Loading states…&quot;
                  : statesResponse.error
                    ? statesResponse.error.message
                    : &quot;Choose a state&quot;}
              &lt;/option&gt;
              {statesResponse.data?.map(({ short, name }) =&gt; (
                &lt;option key={short} value={short}&gt;
                  {name}
                &lt;/option&gt;
              ))}
            &lt;/select&gt;
          &lt;/div&gt;

          &lt;div className=&quot;form-group&quot;&gt;
            City:
            {state ? (
              cities.map(({ name }) =&gt; (
                &lt;button
                  key={name}
                  onClick={() =&gt; updateCity(name)}
                  type=&quot;button&quot;
                &gt;
                  {name}
                &lt;/button&gt;
              ))
            ) : (
              &lt;&gt; Choose a state before selecting a city&lt;/&gt;
            )}
            &lt;hr /&gt;
            &lt;p&gt;Current city: {city || &quot;(none)&quot;}&lt;/p&gt;
          &lt;/div&gt;
        &lt;/form&gt;

        {restaurants.data ? (
          restaurants.data.map(({ _id, address, images, name, slug }) =&gt; (
            &lt;ListItem
              key={_id}
              address={address}
              name={name}
              slug={slug}
              thumbnail={images.thumbnail}
            /&gt;
          ))
        ) : (
          &lt;p&gt;No restaurants.&lt;/p&gt;
        )}
      &lt;/div&gt;
    &lt;/&gt;
  )
}

export default RestaurantList

</code></pre>
 <div line-highlight="3,5,only"></div>
<p>✏️ Update <strong>src/services/restaurant/hooks.ts</strong> to be:</p>
<pre><code class="language-ts">import type { City, State } from &quot;./interfaces&quot;
import { useEffect, useState } from &quot;react&quot;

export function useCities(state: string): City[] {
  const cities = [
    { name: &quot;Madison&quot;, state: &quot;WI&quot; },
    { name: &quot;Springfield&quot;, state: &quot;IL&quot; },
  ]
  return cities.filter((city) =&gt; {
    return city.state === state
  })
}

</code></pre>
 <div line-highlight="1-2,only"></div>
<h3>Verify</h3>
<p>✏️ Update <strong>src/pages/RestaurantList/RestaurantList.test.tsx</strong> to be:</p>
<pre><code class="language-tsx">import &quot;@testing-library/jest-dom&quot;
import { act, render, screen } from &quot;@testing-library/react&quot;
import { describe, expect, it, vi } from &quot;vitest&quot;

import * as restaurantHooks from &quot;../../services/restaurant/hooks&quot;
import RestaurantList from &quot;./RestaurantList&quot;

// Mock the hooks used in the component
vi.mock(&quot;../../services/restaurant/hooks&quot;, () =&gt; ({
  useCities: vi.fn(() =&gt; {
    return {
      data: null,
      error: null,
      isPending: false,
    }
  }),
  useStates: vi.fn(() =&gt; {
    return {
      data: null,
      error: null,
      isPending: false,
    }
  }),
}))

describe(&quot;RestaurantList component&quot;, () =&gt; {
  beforeEach(async () =&gt; {
    vi.spyOn(restaurantHooks, &quot;useCities&quot;).mockReturnValue([
      { name: &quot;Green Bay&quot; },
      { name: &quot;Madison&quot; },
    ])
    render(&lt;RestaurantList /&gt;)
    await act(() =&gt; {})
  })

  it(&quot;renders the Restaurants header&quot;, () =&gt; {
    expect(screen.getByText(/Restaurants/i)).toBeInTheDocument()
  })

  it(&quot;renders the restaurant images&quot;, () =&gt; {
    const images = screen.getAllByRole(&quot;img&quot;)
    expect(images[0]).toHaveAttribute(
      &quot;src&quot;,
      expect.stringContaining(&quot;2-thumbnail.jpg&quot;),
    )
    expect(images[0]).toHaveAttribute(&quot;width&quot;, &quot;100&quot;)
    expect(images[0]).toHaveAttribute(&quot;height&quot;, &quot;100&quot;)
    expect(images[1]).toHaveAttribute(
      &quot;src&quot;,
      expect.stringContaining(&quot;4-thumbnail.jpg&quot;),
    )
    expect(images[1]).toHaveAttribute(&quot;width&quot;, &quot;100&quot;)
    expect(images[1]).toHaveAttribute(&quot;height&quot;, &quot;100&quot;)
  })

  it(&quot;renders the addresses&quot;, () =&gt; {
    const addressDivs = screen.getAllByText(/Washburne Ave|Kinzie Street/i)
    expect(addressDivs[0]).toHaveTextContent(&quot;2451 W Washburne Ave&quot;)
    expect(addressDivs[0]).toHaveTextContent(&quot;Green Bay, WI 53295&quot;)
    expect(addressDivs[1]).toHaveTextContent(&quot;230 W Kinzie Street&quot;)
    expect(addressDivs[1]).toHaveTextContent(&quot;Green Bay, WI 53205&quot;)
  })

  it(&quot;renders the hours and price information for each restaurant&quot;, () =&gt; {
    const hoursPriceDivs = screen.getAllByText(/\$\$\$/i)
    hoursPriceDivs.forEach((div) =&gt; {
      expect(div).toHaveTextContent(&quot;$$$&quot;)
      expect(div).toHaveTextContent(&quot;Hours: M-F 10am-11pm&quot;)
    })
  })

  it(&quot;indicates if the restaurant is open now for each restaurant&quot;, () =&gt; {
    const openNowTags = screen.getAllByText(&quot;Open Now&quot;)
    expect(openNowTags.length).toBeGreaterThan(0)
  })

  it(&quot;renders the details buttons with correct links for each restaurant&quot;, () =&gt; {
    const detailsButtons = screen.getAllByRole(&quot;link&quot;)
    expect(detailsButtons[0]).toHaveAttribute(
      &quot;href&quot;,
      &quot;/restaurants/cheese-curd-city&quot;,
    )
    expect(detailsButtons[1]).toHaveAttribute(
      &quot;href&quot;,
      &quot;/restaurants/poutine-palace&quot;,
    )
    detailsButtons.forEach((button) =&gt; {
      expect(button).toHaveTextContent(&quot;Details&quot;)
    })
  })

  it(&quot;renders ListItem components for each restaurant&quot;, () =&gt; {
    const restaurantNames = screen.getAllByText(
      /Cheese Curd City|Poutine Palace/,
    )
    expect(restaurantNames.length).toBe(2)
  })
})

</code></pre>
 <div line-highlight="8-24,only"></div>
<p>✏️ Update <strong>src/services/restaurant/hooks.test.ts</strong> to be:</p>
<pre><code class="language-ts">import { renderHook, waitFor } from &quot;@testing-library/react&quot;
import { describe, expect, it, vi } from &quot;vitest&quot;
import { useCities, useStates } from &quot;./hooks&quot;

describe(&quot;useCities Hook&quot;, () =&gt; {
  it(&quot;should return cities from Wisconsin when state is WI&quot;, () =&gt; {
    const { result } = renderHook(() =&gt; useCities(&quot;WI&quot;))
    expect(result.current).toHaveLength(1)
    expect(result.current[0].name).toBe(&quot;Madison&quot;)
  })

  it(&quot;should return cities from Illinois when state is IL&quot;, () =&gt; {
    const { result } = renderHook(() =&gt; useCities(&quot;IL&quot;))
    expect(result.current).toHaveLength(1)
    expect(result.current[0].name).toBe(&quot;Springfield&quot;)
  })

  it(&quot;should return no cities for an unknown state&quot;, () =&gt; {
    const { result } = renderHook(() =&gt; useCities(&quot;CA&quot;))
    expect(result.current).toHaveLength(0)
  })
})

describe(&quot;useStates Hook&quot;, () =&gt; {
  beforeEach(async () =&gt; {
    // Mocking the fetch function
    global.fetch = vi.fn()
  })

  it(&quot;should set the states data on successful fetch&quot;, async () =&gt; {
    const mockStates = [{ name: &quot;State1&quot; }, { name: &quot;State2&quot; }]
    fetch.mockResolvedValueOnce({
      json: () =&gt; Promise.resolve({ data: mockStates }),
    })

    const { result } = renderHook(() =&gt; useStates())

    await waitFor(() =&gt; {
      expect(result.current.isPending).toBe(false)
      expect(result.current.data).toEqual(mockStates)
      expect(result.current.error).toBeNull()
    })
  })
})

</code></pre>
 <div line-highlight="1-3,24-28,30-34,36,38-44,only"></div>
<h3>Exercise</h3>
<ul>
<li>Refactor the existing <code>useState</code> and <code>useEffect</code> logic into a new <code>useStates</code> Hook.</li>
</ul>
<p>Hint: After moving the state and effect logic into <code>hooks.ts</code>, use your new Hook in <code>RestaurantList.tsx</code>.</p>
<h3>Solution</h3>
<p><details>
<summary>Click to see the solution</summary></p>
<p>✏️ Update <strong>src/pages/RestaurantList/RestaurantList.tsx</strong> to be:</p>
<pre><code class="language-tsx">import CheeseThumbnail from &quot;place-my-order-assets/images/2-thumbnail.jpg&quot;
import PoutineThumbnail from &quot;place-my-order-assets/images/4-thumbnail.jpg&quot;
import { useState } from &quot;react&quot;
import { useCities, useStates } from &quot;../../services/restaurant/hooks&quot;
import ListItem from &quot;./ListItem&quot;

const RestaurantList: React.FC = () =&gt; {
  const [state, setState] = useState(&quot;&quot;)
  const [city, setCity] = useState(&quot;&quot;)

  const statesResponse = useStates()

  const cities = useCities(state)

  const restaurants = {
    data: [
      {
        name: &quot;Cheese Curd City&quot;,
        slug: &quot;cheese-curd-city&quot;,
        images: {
          thumbnail: CheeseThumbnail,
        },
        address: {
          street: &quot;2451 W Washburne Ave&quot;,
          city: &quot;Green Bay&quot;,
          state: &quot;WI&quot;,
          zip: &quot;53295&quot;,
        },
        _id: &quot;Ar0qBJHxM3ecOhcr&quot;,
      },
      {
        name: &quot;Poutine Palace&quot;,
        slug: &quot;poutine-palace&quot;,
        images: {
          thumbnail: PoutineThumbnail,
        },
        address: {
          street: &quot;230 W Kinzie Street&quot;,
          city: &quot;Green Bay&quot;,
          state: &quot;WI&quot;,
          zip: &quot;53205&quot;,
        },
        _id: &quot;3ZOZyTY1LH26LnVw&quot;,
      },
    ],
  }

  const updateState = (stateShortCode: string) =&gt; {
    setState(stateShortCode)
    setCity(&quot;&quot;)
  }

  const updateCity = (cityName: string) =&gt; {
    setCity(cityName)
  }

  return (
    &lt;&gt;
      &lt;div className=&quot;restaurants&quot;&gt;
        &lt;h2 className=&quot;page-header&quot;&gt;Restaurants&lt;/h2&gt;

        &lt;form className=&quot;form&quot;&gt;
          &lt;div className=&quot;form-group&quot;&gt;
            &lt;label className=&quot;control-label&quot; htmlFor=&quot;stateSelect&quot;&gt;
              State
            &lt;/label&gt;
            &lt;select
              className=&quot;form-control&quot;
              id=&quot;stateSelect&quot;
              onChange={(event) =&gt; updateState(event.target.value)}
              value={state}
            &gt;
              &lt;option key=&quot;choose_state&quot; value=&quot;&quot;&gt;
                {statesResponse.isPending
                  ? &quot;Loading states…&quot;
                  : statesResponse.error
                    ? statesResponse.error.message
                    : &quot;Choose a state&quot;}
              &lt;/option&gt;
              {statesResponse.data?.map(({ short, name }) =&gt; (
                &lt;option key={short} value={short}&gt;
                  {name}
                &lt;/option&gt;
              ))}
            &lt;/select&gt;
          &lt;/div&gt;

          &lt;div className=&quot;form-group&quot;&gt;
            City:
            {state ? (
              cities.map(({ name }) =&gt; (
                &lt;button
                  key={name}
                  onClick={() =&gt; updateCity(name)}
                  type=&quot;button&quot;
                &gt;
                  {name}
                &lt;/button&gt;
              ))
            ) : (
              &lt;&gt; Choose a state before selecting a city&lt;/&gt;
            )}
            &lt;hr /&gt;
            &lt;p&gt;Current city: {city || &quot;(none)&quot;}&lt;/p&gt;
          &lt;/div&gt;
        &lt;/form&gt;

        {restaurants.data ? (
          restaurants.data.map(({ _id, address, images, name, slug }) =&gt; (
            &lt;ListItem
              key={_id}
              address={address}
              name={name}
              slug={slug}
              thumbnail={images.thumbnail}
            /&gt;
          ))
        ) : (
          &lt;p&gt;No restaurants.&lt;/p&gt;
        )}
      &lt;/div&gt;
    &lt;/&gt;
  )
}

export default RestaurantList

</code></pre>
 <div line-highlight="11,only"></div>
<p>✏️ Update <strong>src/services/restaurant/hooks.ts</strong> to be:</p>
<pre><code class="language-ts">import type { City, State } from &quot;./interfaces&quot;
import { useEffect, useState } from &quot;react&quot;

interface StatesResponse {
  data: State[] | null
  error: Error | null
  isPending: boolean
}

export function useCities(state: string): City[] {
  const cities = [
    { name: &quot;Madison&quot;, state: &quot;WI&quot; },
    { name: &quot;Springfield&quot;, state: &quot;IL&quot; },
  ]
  return cities.filter((city) =&gt; {
    return city.state === state
  })
}

export function useStates(): StatesResponse {
  const [response, setResponse] = useState&lt;StatesResponse&gt;({
    data: null,
    error: null,
    isPending: true,
  })

  useEffect(() =&gt; {
    const fetchData = async () =&gt; {
      const response = await fetch(`${import.meta.env.VITE_PMO_API}/states`, {
        method: &quot;GET&quot;,
      })

      const data = await response.json()

      setResponse({
        data: data?.data || null,
        error: null,
        isPending: false,
      })
    }
    fetchData()
  }, [])

  return response
}

</code></pre>
 <div line-highlight="4-7,18,20-25,27-31,33,35-42,44-45,only"></div>
<p></details></p>
<h2>Objective 3: Update the <code>useCities</code> Hook to fetch data from the API.</h2>
<p>In this section, we will:</p>
<ul>
<li>Learn about including query parameters in our API calls.</li>
</ul>
<h3>Including query parameters in API calls</h3>
<p>Query parameters are a defined set of parameters attached to the end of a URL.
They are used to define and pass data in the form of key-value pairs. The
parameters are separated from the URL itself by a <code>?</code> symbol, and individual
key-value pairs are separated by the <code>&amp;</code> symbol.</p>
<p>A basic URL with query parameters looks like this:</p>
<pre><code>http://www.example.com/page?param1=value1&amp;param2=value2
</code></pre>
<p>Here’s a breakdown of this URL:</p>
<ul>
<li>Base URL: <code>http://www.example.com/page</code></li>
<li>Query Parameter Indicator: <code>?</code></li>
<li>Query Parameters:
<ul>
<li><code>param1=value1</code></li>
<li><code>param2=value2</code></li>
</ul></li>
</ul>
<h3>Setup</h3>
<p>✏️ Update <strong>src/pages/RestaurantList/RestaurantList.tsx</strong> to be:</p>
<pre><code class="language-tsx">import CheeseThumbnail from &quot;place-my-order-assets/images/2-thumbnail.jpg&quot;
import PoutineThumbnail from &quot;place-my-order-assets/images/4-thumbnail.jpg&quot;
import { useState } from &quot;react&quot;
import { useCities, useStates } from &quot;../../services/restaurant/hooks&quot;
import ListItem from &quot;./ListItem&quot;

const RestaurantList: React.FC = () =&gt; {
  const [state, setState] = useState(&quot;&quot;)
  const [city, setCity] = useState(&quot;&quot;)

  const statesResponse = useStates()

  const cities = useCities(state)

  const restaurants = {
    data: [
      {
        name: &quot;Cheese Curd City&quot;,
        slug: &quot;cheese-curd-city&quot;,
        images: {
          thumbnail: CheeseThumbnail,
        },
        address: {
          street: &quot;2451 W Washburne Ave&quot;,
          city: &quot;Green Bay&quot;,
          state: &quot;WI&quot;,
          zip: &quot;53295&quot;,
        },
        _id: &quot;Ar0qBJHxM3ecOhcr&quot;,
      },
      {
        name: &quot;Poutine Palace&quot;,
        slug: &quot;poutine-palace&quot;,
        images: {
          thumbnail: PoutineThumbnail,
        },
        address: {
          street: &quot;230 W Kinzie Street&quot;,
          city: &quot;Green Bay&quot;,
          state: &quot;WI&quot;,
          zip: &quot;53205&quot;,
        },
        _id: &quot;3ZOZyTY1LH26LnVw&quot;,
      },
    ],
  }

  const updateState = (stateShortCode: string) =&gt; {
    setState(stateShortCode)
    setCity(&quot;&quot;)
  }

  const updateCity = (cityName: string) =&gt; {
    setCity(cityName)
  }

  return (
    &lt;&gt;
      &lt;div className=&quot;restaurants&quot;&gt;
        &lt;h2 className=&quot;page-header&quot;&gt;Restaurants&lt;/h2&gt;

        &lt;form className=&quot;form&quot;&gt;
          &lt;div className=&quot;form-group&quot;&gt;
            &lt;label className=&quot;control-label&quot; htmlFor=&quot;stateSelect&quot;&gt;
              State
            &lt;/label&gt;
            &lt;select
              className=&quot;form-control&quot;
              id=&quot;stateSelect&quot;
              onChange={(event) =&gt; updateState(event.target.value)}
              value={state}
            &gt;
              &lt;option key=&quot;choose_state&quot; value=&quot;&quot;&gt;
                {statesResponse.isPending
                  ? &quot;Loading states…&quot;
                  : statesResponse.error
                    ? statesResponse.error.message
                    : &quot;Choose a state&quot;}
              &lt;/option&gt;
              {statesResponse.data?.map(({ short, name }) =&gt; (
                &lt;option key={short} value={short}&gt;
                  {name}
                &lt;/option&gt;
              ))}
            &lt;/select&gt;
          &lt;/div&gt;

          &lt;div className=&quot;form-group&quot;&gt;
            &lt;label className=&quot;control-label&quot; htmlFor=&quot;citySelect&quot;&gt;
              City
            &lt;/label&gt;
            &lt;select
              className=&quot;form-control&quot;
              id=&quot;citySelect&quot;
              onChange={(event) =&gt; updateCity(event.target.value)}
              value={city}
            &gt;
              &lt;option key=&quot;choose_city&quot; value=&quot;&quot;&gt;
                {state
                  ? citiesResponse.isPending
                    ? &quot;Loading cities…&quot;
                    : citiesResponse.error
                      ? citiesResponse.error.message
                      : &quot;Choose a city&quot;
                  : &quot;Choose a state before selecting a city&quot;}
              &lt;/option&gt;
              {state &amp;&amp;
                citiesResponse.data?.map(({ name }) =&gt; (
                  &lt;option key={name} value={name}&gt;
                    {name}
                  &lt;/option&gt;
                ))}
            &lt;/select&gt;
          &lt;/div&gt;
        &lt;/form&gt;

        {restaurants.data ? (
          restaurants.data.map(({ _id, address, images, name, slug }) =&gt; (
            &lt;ListItem
              key={_id}
              address={address}
              name={name}
              slug={slug}
              thumbnail={images.thumbnail}
            /&gt;
          ))
        ) : (
          &lt;p&gt;No restaurants.&lt;/p&gt;
        )}
      &lt;/div&gt;
    &lt;/&gt;
  )
}

export default RestaurantList

</code></pre>
 <div line-highlight="89-113,only"></div>
<h3>Verify</h3>
<p>✏️ Update <strong>src/pages/RestaurantList/RestaurantList.test.tsx</strong> to be:</p>
<pre><code class="language-tsx">import &quot;@testing-library/jest-dom&quot;
import { act, render, screen } from &quot;@testing-library/react&quot;
import userEvent from &quot;@testing-library/user-event&quot;
import { describe, expect, it, vi } from &quot;vitest&quot;

import RestaurantList from &quot;./RestaurantList&quot;

import { useCities, useStates } from &quot;../../services/restaurant/hooks&quot;

// Mock the hooks used in the component
vi.mock(&quot;../../services/restaurant/hooks&quot;, () =&gt; ({
  useCities: vi.fn(() =&gt; {
    return {
      data: null,
      error: null,
      isPending: false,
    }
  }),
  useStates: vi.fn(() =&gt; {
    return {
      data: null,
      error: null,
      isPending: false,
    }
  }),
}))

describe(&quot;RestaurantList component&quot;, () =&gt; {
  it(&quot;renders the Restaurants header&quot;, async () =&gt; {
    render(&lt;RestaurantList /&gt;)
    await act(() =&gt; {})
    expect(screen.getByText(/Restaurants/i)).toBeInTheDocument()
  })

  it(&quot;renders state and city dropdowns&quot;, async () =&gt; {
    render(&lt;RestaurantList /&gt;)
    await act(() =&gt; {})
    expect(screen.getByLabelText(/State/i)).toBeInTheDocument()
    expect(screen.getByLabelText(/City/i)).toBeInTheDocument()
  })

  it(&quot;renders correctly with initial states&quot;, async () =&gt; {
    useStates.mockReturnValue({ data: null, isPending: true, error: null })
    useCities.mockReturnValue({ data: null, isPending: false, error: null })

    render(&lt;RestaurantList /&gt;)
    await act(() =&gt; {})

    expect(screen.getByText(/Restaurants/)).toBeInTheDocument()
    expect(screen.getByText(/Loading states…/)).toBeInTheDocument()
  })

  it(&quot;displays error messages correctly&quot;, async () =&gt; {
    useStates.mockReturnValue({
      data: null,
      isPending: false,
      error: { message: &quot;Error loading states&quot; },
    })
    useCities.mockReturnValue({
      data: null,
      isPending: false,
      error: { message: &quot;Error loading cities&quot; },
    })

    render(&lt;RestaurantList /&gt;)
    await act(() =&gt; {})

    expect(screen.getByText(/Error loading states/)).toBeInTheDocument()
  })

  it(&quot;renders restaurants correctly&quot;, async () =&gt; {
    useStates.mockReturnValue({
      data: [{ short: &quot;CA&quot;, name: &quot;California&quot; }],
      isPending: false,
      error: null,
    })
    useCities.mockReturnValue({
      data: [{ name: &quot;Los Angeles&quot; }],
      isPending: false,
      error: null,
    })

    render(&lt;RestaurantList /&gt;)
    await act(() =&gt; {})

    await userEvent.selectOptions(screen.getByLabelText(/State/), &quot;CA&quot;)
    await userEvent.selectOptions(screen.getByLabelText(/City/), &quot;Los Angeles&quot;)

    expect(screen.getByText(&quot;Cheese Curd City&quot;)).toBeInTheDocument()
  })
})

</code></pre>
 <div line-highlight="3,8,29,35-39,42-44,46-47,49-50,53-57,59-62,65-66,68,71-81,83-84,86-87,89,only"></div>
<p>✏️ Update <strong>src/services/restaurant/hooks.test.ts</strong> to be:</p>
<pre><code class="language-ts">import { renderHook, waitFor } from &quot;@testing-library/react&quot;
import { describe, expect, it, vi } from &quot;vitest&quot;
import { useCities, useStates } from &quot;./hooks&quot;

describe(&quot;useCities Hook&quot;, () =&gt; {
  beforeEach(() =&gt; {
    global.fetch = vi.fn()
  })

  it(&quot;initial state of useCities&quot;, async () =&gt; {
    vi.mocked(fetch).mockResolvedValueOnce({
      json: async () =&gt; ({ data: null }),
    })

    const { result } = renderHook(() =&gt; useCities(&quot;someState&quot;))
    await waitFor(() =&gt; {
      expect(result.current.isPending).toBe(true)
      expect(result.current.data).toBeNull()
      expect(result.current.error).toBeNull()
    })
  })

  it(&quot;fetches cities successfully&quot;, async () =&gt; {
    const mockCities = [
      { id: 1, name: &quot;City1&quot; },
      { id: 2, name: &quot;City2&quot; },
    ]
    vi.mocked(fetch).mockResolvedValueOnce({
      json: async () =&gt; ({ data: mockCities }),
    })

    const { result } = renderHook(() =&gt; useCities(&quot;someState&quot;))

    await waitFor(() =&gt; {
      expect(result.current.data).toEqual(mockCities)
      expect(result.current.isPending).toBe(false)
      expect(result.current.error).toBeNull()
    })
  })
})

describe(&quot;useStates Hook&quot;, () =&gt; {
  beforeEach(async () =&gt; {
    // Mocking the fetch function
    global.fetch = vi.fn()
  })

  it(&quot;should set the states data on successful fetch&quot;, async () =&gt; {
    const mockStates = [{ name: &quot;State1&quot; }, { name: &quot;State2&quot; }]
    fetch.mockResolvedValueOnce({
      json: () =&gt; Promise.resolve({ data: mockStates }),
    })

    const { result } = renderHook(() =&gt; useStates())

    await waitFor(() =&gt; {
      expect(result.current.isPending).toBe(false)
      expect(result.current.data).toEqual(mockStates)
      expect(result.current.error).toBeNull()
    })
  })
})

</code></pre>
 <div line-highlight="6,10-12,15,17-18,23-30,32,34-35,37-38,45,52,56-57,59-60,only"></div>
<h3>Exercise</h3>
<p>Update our useCities Hook to fetch cities from the Place My Order API, given a selected state.</p>
<p>When calling the Place My Order API, include the <code>state</code> query parameter:</p>
<pre><code>http://localhost:7070/cities?state=MO
</code></pre>
<h3>Solution</h3>
<p><details>
<summary>Click to see the solution</summary></p>
<p>✏️ Update <strong>src/pages/RestaurantList/RestaurantList.tsx</strong> to be:</p>
<pre><code class="language-tsx">import CheeseThumbnail from &quot;place-my-order-assets/images/2-thumbnail.jpg&quot;
import PoutineThumbnail from &quot;place-my-order-assets/images/4-thumbnail.jpg&quot;
import { useState } from &quot;react&quot;
import { useCities, useStates } from &quot;../../services/restaurant/hooks&quot;
import ListItem from &quot;./ListItem&quot;

const RestaurantList: React.FC = () =&gt; {
  const [state, setState] = useState(&quot;&quot;)
  const [city, setCity] = useState(&quot;&quot;)

  const statesResponse = useStates()

  const citiesResponse = useCities(state)

  const restaurants = {
    data: [
      {
        name: &quot;Cheese Curd City&quot;,
        slug: &quot;cheese-curd-city&quot;,
        images: {
          thumbnail: CheeseThumbnail,
        },
        address: {
          street: &quot;2451 W Washburne Ave&quot;,
          city: &quot;Green Bay&quot;,
          state: &quot;WI&quot;,
          zip: &quot;53295&quot;,
        },
        _id: &quot;Ar0qBJHxM3ecOhcr&quot;,
      },
      {
        name: &quot;Poutine Palace&quot;,
        slug: &quot;poutine-palace&quot;,
        images: {
          thumbnail: PoutineThumbnail,
        },
        address: {
          street: &quot;230 W Kinzie Street&quot;,
          city: &quot;Green Bay&quot;,
          state: &quot;WI&quot;,
          zip: &quot;53205&quot;,
        },
        _id: &quot;3ZOZyTY1LH26LnVw&quot;,
      },
    ],
  }

  const updateState = (stateShortCode: string) =&gt; {
    setState(stateShortCode)
    setCity(&quot;&quot;)
  }

  const updateCity = (cityName: string) =&gt; {
    setCity(cityName)
  }

  return (
    &lt;&gt;
      &lt;div className=&quot;restaurants&quot;&gt;
        &lt;h2 className=&quot;page-header&quot;&gt;Restaurants&lt;/h2&gt;

        &lt;form className=&quot;form&quot;&gt;
          &lt;div className=&quot;form-group&quot;&gt;
            &lt;label className=&quot;control-label&quot; htmlFor=&quot;stateSelect&quot;&gt;
              State
            &lt;/label&gt;
            &lt;select
              className=&quot;form-control&quot;
              id=&quot;stateSelect&quot;
              onChange={(event) =&gt; updateState(event.target.value)}
              value={state}
            &gt;
              &lt;option key=&quot;choose_state&quot; value=&quot;&quot;&gt;
                {statesResponse.isPending
                  ? &quot;Loading states…&quot;
                  : statesResponse.error
                    ? statesResponse.error.message
                    : &quot;Choose a state&quot;}
              &lt;/option&gt;
              {statesResponse.data?.map(({ short, name }) =&gt; (
                &lt;option key={short} value={short}&gt;
                  {name}
                &lt;/option&gt;
              ))}
            &lt;/select&gt;
          &lt;/div&gt;

          &lt;div className=&quot;form-group&quot;&gt;
            &lt;label className=&quot;control-label&quot; htmlFor=&quot;citySelect&quot;&gt;
              City
            &lt;/label&gt;
            &lt;select
              className=&quot;form-control&quot;
              id=&quot;citySelect&quot;
              onChange={(event) =&gt; updateCity(event.target.value)}
              value={city}
            &gt;
              &lt;option key=&quot;choose_city&quot; value=&quot;&quot;&gt;
                {state
                  ? citiesResponse.isPending
                    ? &quot;Loading cities…&quot;
                    : citiesResponse.error
                      ? citiesResponse.error.message
                      : &quot;Choose a city&quot;
                  : &quot;Choose a state before selecting a city&quot;}
              &lt;/option&gt;
              {state &amp;&amp;
                citiesResponse.data?.map(({ name }) =&gt; (
                  &lt;option key={name} value={name}&gt;
                    {name}
                  &lt;/option&gt;
                ))}
            &lt;/select&gt;
          &lt;/div&gt;
        &lt;/form&gt;

        {restaurants.data ? (
          restaurants.data.map(({ _id, address, images, name, slug }) =&gt; (
            &lt;ListItem
              key={_id}
              address={address}
              name={name}
              slug={slug}
              thumbnail={images.thumbnail}
            /&gt;
          ))
        ) : (
          &lt;p&gt;No restaurants.&lt;/p&gt;
        )}
      &lt;/div&gt;
    &lt;/&gt;
  )
}

export default RestaurantList

</code></pre>
 <div line-highlight="13,only"></div>
<p>✏️ Update <strong>src/services/restaurant/hooks.ts</strong> to be:</p>
<pre><code class="language-ts">import type { City, State } from &quot;./interfaces&quot;
import { useEffect, useState } from &quot;react&quot;

interface CitiesResponse {
  data: City[] | null
  error: Error | null
  isPending: boolean
}

interface StatesResponse {
  data: State[] | null
  error: Error | null
  isPending: boolean
}

export function useCities(state: string): CitiesResponse {
  const [response, setResponse] = useState&lt;CitiesResponse&gt;({
    data: null,
    error: null,
    isPending: true,
  })

  useEffect(() =&gt; {
    const fetchData = async () =&gt; {
      const response = await fetch(
        `${import.meta.env.VITE_PMO_API}/cities?state=${state}`,
        {
          method: &quot;GET&quot;,
        },
      )

      const data = await response.json()

      setResponse({
        data: data?.data || null,
        error: null,
        isPending: false,
      })
    }
    fetchData()
  }, [state])

  return response
}

export function useStates(): StatesResponse {
  const [response, setResponse] = useState&lt;StatesResponse&gt;({
    data: null,
    error: null,
    isPending: true,
  })

  useEffect(() =&gt; {
    const fetchData = async () =&gt; {
      const response = await fetch(`${import.meta.env.VITE_PMO_API}/states`, {
        method: &quot;GET&quot;,
      })

      const data = await response.json()

      setResponse({
        data: data?.data || null,
        error: null,
        isPending: false,
      })
    }
    fetchData()
  }, [])

  return response
}

</code></pre>
 <div line-highlight="4-5,12-13,16-17,25-30,41,48-50,53-54,59,61-67,70-71,only"></div>
<p></details></p>
<h2>Objective 4: Create an <code>apiRequest</code> helper and use it in the Hooks.</h2>
<p>In this section, we will learn how to:</p>
<ul>
<li>Handle HTTP error statuses (e.g. <code>404 Not Found</code>)</li>
<li>Catch network errors from <code>fetch()</code></li>
</ul>
<h3>Checking for error responses</h3>
<ul>
<li><code>.ok</code></li>
<li><code>.status</code></li>
<li><code>.statusText</code></li>
</ul>
<p>When you make a request with the Fetch API, it does not reject on HTTP error
statuses (like <code>404</code> or <code>500</code>). Instead, it resolves normally (with an <code>ok</code>
status set to <code>false</code>), and it only rejects on network failure or if anything
prevented the request from completing.</p>
<p>Here’s the API that <code>fetch</code> provides to handle these HTTP errors:</p>
<ul>
<li><code>.ok</code>: This is a shorthand property that returns <code>true</code> if the response’s status code is in the range <code>200</code>-<code>299</code>, indicating a successful request.</li>
<li><code>.status</code>: This property returns the status code of the response (e.g. <code>200</code> for success, <code>404</code> for <code>Not Found</code>, etc.).</li>
<li><code>.statusText</code>: This provides the status message corresponding to the status code (e.g. <code>'OK'</code>, <code>'Not Found'</code>, etc.).</li>
</ul>
<pre><code class="language-js">const response = await fetch('https://api.example.com/data', {
    method: &quot;GET&quot;,
})

const data = await response.json()
const error = response.ok ? null : new Error(`${response.status} (${response.statusText})`)
</code></pre>
<p>In the example above, we check the <code>response.ok</code> property to see if the status
code is in the <code>200</code>-<code>299</code> (successful) range. If not, we create an <code>error</code>
object that contains the status code and text (e.g. <code>404 Not Found</code>).</p>
<h3>Handling network errors</h3>
<p>Network errors occur when there is a problem in completing the request, like when
the user is offline, the server is unreachable, or there is a DNS lookup failure.</p>
<p>In these cases, the <code>fetch</code> API will <em>not</em> resolve with data, but instead it will
throw an error that needs to be caught.</p>
<p>Let’s take a look at how to handle these types of errors:</p>
<pre><code class="language-js">try {
    const response = await fetch('https://api.example.com/data', {
        method: &quot;GET&quot;,
    })

    const data = await response.json()
    const error = response.ok ? null : new Error(`${response.status} (${response.statusText})`)
    // Do something with data and error

} catch (error) {
    const parsedError = error instanceof Error ? error : new Error('An unknown error occurred')
    // Do something with parsedError
}
</code></pre>
<p>In the example above, we <code>catch</code> the <code>error</code> and check its type. If it’s already an
<code>instanceof Error</code>, then it will have a <code>message</code> property and we can use it as-is.
If it’s not, then we can create our own <code>new Error()</code> so we <em>always</em> have an error
to consume in our Hooks or components.</p>
<h3>Setup</h3>
<p>✏️ Create <strong>src/services/api.ts</strong> and update it to be:</p>
<pre><code class="language-ts">export async function apiRequest&lt;Data = never, Params = unknown&gt;({
  method,
  params,
  path,
}: {
  method: string
  params?: Params
  path: string
}): Promise&lt;{ data: Data | null; error: Error | null }&gt; {
  return {
    data: null,
    error: null,
  }
}

export function stringifyQuery(input: Record&lt;string, string&gt;): string {
  const output: string[] = []

  for (const [key, value] of Object.entries(input)) {
    if (typeof value !== &quot;undefined&quot; &amp;&amp; value !== null) {
      output.push(`${key}=${value}`)
    }
  }

  return output.join(&quot;&amp;&quot;)
}

</code></pre>
<p>✏️ Update <strong>src/services/restaurant/hooks.ts</strong> to be:</p>
<pre><code class="language-ts">import type { City, State } from &quot;./interfaces&quot;
import { useEffect, useState } from &quot;react&quot;
import { apiRequest } from &quot;../api&quot;

interface CitiesResponse {
  data: City[] | null
  error: Error | null
  isPending: boolean
}

interface StatesResponse {
  data: State[] | null
  error: Error | null
  isPending: boolean
}

export function useCities(state: string): CitiesResponse {
  const [response, setResponse] = useState&lt;CitiesResponse&gt;({
    data: null,
    error: null,
    isPending: true,
  })

  useEffect(() =&gt; {
    const fetchData = async () =&gt; {
      const response = await fetch(
        `${import.meta.env.VITE_PMO_API}/cities?state=${state}`,
        {
          method: &quot;GET&quot;,
        },
      )

      const data = await response.json()

      setResponse({
        data: data?.data || null,
        error: null,
        isPending: false,
      })
    }
    fetchData()
  }, [state])

  return response
}

export function useStates(): StatesResponse {
  const [response, setResponse] = useState&lt;StatesResponse&gt;({
    data: null,
    error: null,
    isPending: true,
  })

  useEffect(() =&gt; {
    const fetchData = async () =&gt; {
      const response = await fetch(`${import.meta.env.VITE_PMO_API}/states`, {
        method: &quot;GET&quot;,
      })

      const data = await response.json()

      setResponse({
        data: data?.data || null,
        error: null,
        isPending: false,
      })
    }
    fetchData()
  }, [])

  return response
}

</code></pre>
 <div line-highlight="3,only"></div>
<h3>Verify</h3>
<p>✏️ Create <strong>src/services/api.test.ts</strong> and update it to be:</p>
<pre><code class="language-ts">import { apiRequest, stringifyQuery } from &quot;./api&quot;
import { afterEach, beforeEach, describe, expect, it, vi } from &quot;vitest&quot;

// Mocking the global fetch function
const mockFetch = vi.fn()

global.fetch = mockFetch

beforeEach(() =&gt; {
  mockFetch.mockClear()
})

afterEach(() =&gt; {
  mockFetch.mockClear()
})

describe(&quot;apiRequest function&quot;, () =&gt; {
  it(&quot;should handle a successful request&quot;, async () =&gt; {
    // Mock the fetch response
    mockFetch.mockResolvedValueOnce({
      ok: true,
      json: () =&gt; Promise.resolve({ message: &quot;success&quot; }),
      statusText: &quot;OK&quot;,
      status: 200,
    })

    const response = await apiRequest({
      method: &quot;GET&quot;,
      path: &quot;/test&quot;,
    })

    expect(response).toEqual({ data: { message: &quot;success&quot; }, error: null })
    expect(mockFetch).toHaveBeenCalledWith(
      `${import.meta.env.VITE_PMO_API}/test?`,
      { method: &quot;GET&quot; },
    )
  })

  it(&quot;should handle a failed request&quot;, async () =&gt; {
    // Mock the fetch response
    mockFetch.mockResolvedValueOnce({
      ok: false,
      json: () =&gt; Promise.resolve({ message: &quot;error&quot; }),
      statusText: &quot;Bad Request&quot;,
      status: 400,
    })

    const response = await apiRequest({
      method: &quot;GET&quot;,
      path: &quot;/test&quot;,
    })

    expect(response).toEqual({
      data: { message: &quot;error&quot; },
      error: new Error(&quot;400 (Bad Request)&quot;),
    })
  })

  it(&quot;should handle network errors&quot;, async () =&gt; {
    // Mock a network error
    mockFetch.mockRejectedValueOnce(new Error(&quot;Network Error&quot;))

    const response = await apiRequest({
      method: &quot;GET&quot;,
      path: &quot;/test&quot;,
    })

    expect(response).toEqual({ data: null, error: new Error(&quot;Network Error&quot;) })
  })
})

describe(&quot;stringifyQuery function&quot;, () =&gt; {
  it(&quot;should correctly stringify query parameters&quot;, () =&gt; {
    const query = stringifyQuery({ foo: &quot;bar&quot;, baz: &quot;qux&quot; })
    expect(query).toBe(&quot;foo=bar&amp;baz=qux&quot;)
  })

  it(&quot;should omit undefined and null values&quot;, () =&gt; {
    const query = stringifyQuery({ foo: &quot;bar&quot;, baz: null, qux: undefined })
    expect(query).toBe(&quot;foo=bar&quot;)
  })
})

</code></pre>
<p>✏️ Update <strong>src/services/restaurant/hooks.test.ts</strong> to be:</p>
<pre><code class="language-ts">import { renderHook, waitFor } from &quot;@testing-library/react&quot;
import { beforeEach, describe, expect, it, vi } from &quot;vitest&quot;
import { apiRequest } from &quot;../api&quot;
import { useCities, useStates } from &quot;./hooks&quot;

// Mock the apiRequest function
vi.mock(&quot;../api&quot;, () =&gt; ({
  apiRequest: vi.fn(),
}))

describe(&quot;Hooks&quot;, () =&gt; {
  beforeEach(() =&gt; {
    vi.resetAllMocks()
  })

  describe(&quot;useCities hook&quot;, () =&gt; {
    it(&quot;should return cities data successfully&quot;, async () =&gt; {
      const mockCities = [
        { id: 1, name: &quot;City1&quot; },
        { id: 2, name: &quot;City2&quot; },
      ]
      apiRequest.mockResolvedValue({ data: { data: mockCities }, error: null })

      const { result } = renderHook(() =&gt; useCities(&quot;test-state&quot;))

      await waitFor(() =&gt; {
        expect(result.current.isPending).toBeFalsy()
        expect(result.current.data).toEqual(mockCities)
        expect(result.current.error).toBeNull()
      })
    })

    it(&quot;should handle error when fetching cities data&quot;, async () =&gt; {
      const mockError = new Error(&quot;Error fetching cities&quot;)
      apiRequest.mockResolvedValue({ data: null, error: mockError })

      const { result } = renderHook(() =&gt; useCities(&quot;test-state&quot;))

      await waitFor(() =&gt; {
        expect(result.current.isPending).toBeFalsy()
        expect(result.current.data).toBeNull()
        expect(result.current.error).toEqual(mockError)
      })
    })
  })

  describe(&quot;useStates hook&quot;, () =&gt; {
    it(&quot;should return states data successfully&quot;, async () =&gt; {
      const mockStates = [
        { id: 1, name: &quot;State1&quot; },
        { id: 2, name: &quot;State2&quot; },
      ]
      apiRequest.mockResolvedValue({ data: { data: mockStates }, error: null })

      const { result } = renderHook(() =&gt; useStates())

      await waitFor(() =&gt; {
        expect(result.current.isPending).toBeFalsy()
        expect(result.current.data).toEqual(mockStates)
        expect(result.current.error).toBeNull()
      })
    })

    it(&quot;should handle error when fetching states data&quot;, async () =&gt; {
      const mockError = new Error(&quot;Error fetching states&quot;)
      apiRequest.mockResolvedValue({ data: null, error: mockError })

      const { result } = renderHook(() =&gt; useStates())

      await waitFor(() =&gt; {
        expect(result.current.isPending).toBeFalsy()
        expect(result.current.data).toBeNull()
        expect(result.current.error).toEqual(mockError)
      })
    })
  })
})

</code></pre>
 <div line-highlight="2-3,6-9,11,13,16-22,24,26-30,33-35,37,39-43,47-53,55,57-61,64-66,68,70-74,only"></div>
<h3>Exercise</h3>
<ul>
<li>Implement the <code>apiRequest</code> helper function to handle errors returned and thrown from <code>fetch()</code>.</li>
<li>Update the <code>useCities</code> and <code>useStates</code> Hooks to use the <code>data</code> and <code>error</code> returned from <code>apiRequest</code>.</li>
</ul>
<p>Hint: Use the new <code>stringifyQuery</code> function to convert an object of query parameters to a string:</p>
<pre><code class="language-js">stringifyQuery({
    param1: &quot;value1&quot;,
    param2: &quot;value2&quot;,
})
</code></pre>
<h3>Solution</h3>
<p><details>
<summary>Click to see the solution</summary></p>
<p>✏️ Update <strong>src/services/api.ts</strong> to be:</p>
<pre><code class="language-ts">export async function apiRequest&lt;Data = never, Params = unknown&gt;({
  method,
  params,
  path,
}: {
  method: string
  params?: Params
  path: string
}): Promise&lt;{ data: Data | null; error: Error | null }&gt; {
  try {
    const query = params ? stringifyQuery(params) : &quot;&quot;
    const response = await fetch(
      `${import.meta.env.VITE_PMO_API}${path}?${query}`,
      {
        method,
      },
    )

    const data = await response.json()
    const error = response.ok
      ? null
      : new Error(`${response.status} (${response.statusText})`)

    return {
      data: data,
      error: error,
    }
  } catch (error) {
    return {
      data: null,
      error:
        error instanceof Error ? error : new Error(&quot;An unknown error occurred&quot;),
    }
  }
}

export function stringifyQuery(input: Record&lt;string, string&gt;): string {
  const output: string[] = []

  for (const [key, value] of Object.entries(input)) {
    if (typeof value !== &quot;undefined&quot; &amp;&amp; value !== null) {
      output.push(`${key}=${value}`)
    }
  }

  return output.join(&quot;&amp;&quot;)
}

</code></pre>
 <div line-highlight="10-17,19-22,24-26,28-33,43,only"></div>
<p>✏️ Update <strong>src/services/restaurant/hooks.ts</strong> to be:</p>
<pre><code class="language-ts">import type { City, State } from &quot;./interfaces&quot;
import { useEffect, useState } from &quot;react&quot;
import { apiRequest } from &quot;../api&quot;

interface CitiesResponse {
  data: City[] | null
  error: Error | null
  isPending: boolean
}

interface StatesResponse {
  data: State[] | null
  error: Error | null
  isPending: boolean
}

export function useCities(state: string): CitiesResponse {
  const [response, setResponse] = useState&lt;CitiesResponse&gt;({
    data: null,
    error: null,
    isPending: true,
  })

  useEffect(() =&gt; {
    const fetchData = async () =&gt; {
      const { data, error } = await apiRequest&lt;CitiesResponse&gt;({
        method: &quot;GET&quot;,
        path: &quot;/cities&quot;,
        params: {
          state: state,
        },
      })

      setResponse({
        data: data?.data || null,
        error: error,
        isPending: false,
      })
    }
    fetchData()
  }, [state])

  return response
}

export function useStates(): StatesResponse {
  const [response, setResponse] = useState&lt;StatesResponse&gt;({
    data: null,
    error: null,
    isPending: true,
  })

  useEffect(() =&gt; {
    const fetchData = async () =&gt; {
      const { data, error } = await apiRequest&lt;StatesResponse&gt;({
        method: &quot;GET&quot;,
        path: &quot;/states&quot;,
      })

      setResponse({
        data: data?.data || null,
        error: error,
        isPending: false,
      })
    }
    fetchData()
  }, [])

  return response
}

</code></pre>
 <div line-highlight="26,28-30,36,55-57,62,64,only"></div>
<p></details></p>
<h2>Objective 5: Fetch restaurant data</h2>
<p>In this section, we will:</p>
<ul>
<li>Create a <code>useRestaurants</code> Hook for fetching the restaurant data.</li>
</ul>
<p><img src="../static/img/react-vite/09-making-http-requests/5-problem.png"
style="border: solid 1px black; max-width: 800px;"/></p>
<p>Now that we are able to capture a user’s state and city preferences, we want to only
return restaurants in the selected city.:</p>
<p><img src="../static/img/react-vite/09-making-http-requests/5-solution.png"
style="border: solid 1px black; max-width: 800px;"/></p>
<h3>Setup</h3>
<p>✏️ Update <strong>src/pages/RestaurantList/RestaurantList.tsx</strong> to be:</p>
<pre><code class="language-tsx">import CheeseThumbnail from &quot;place-my-order-assets/images/2-thumbnail.jpg&quot;
import PoutineThumbnail from &quot;place-my-order-assets/images/4-thumbnail.jpg&quot;
import { useState } from &quot;react&quot;
import {
  useCities,
  useRestaurants,
  useStates,
} from &quot;../../services/restaurant/hooks&quot;
import ListItem from &quot;./ListItem&quot;

const RestaurantList: React.FC = () =&gt; {
  const [state, setState] = useState(&quot;&quot;)
  const [city, setCity] = useState(&quot;&quot;)

  const statesResponse = useStates()

  const citiesResponse = useCities(state)

  const restaurants = {
    data: [
      {
        name: &quot;Cheese Curd City&quot;,
        slug: &quot;cheese-curd-city&quot;,
        images: {
          thumbnail: CheeseThumbnail,
        },
        address: {
          street: &quot;2451 W Washburne Ave&quot;,
          city: &quot;Green Bay&quot;,
          state: &quot;WI&quot;,
          zip: &quot;53295&quot;,
        },
        _id: &quot;Ar0qBJHxM3ecOhcr&quot;,
      },
      {
        name: &quot;Poutine Palace&quot;,
        slug: &quot;poutine-palace&quot;,
        images: {
          thumbnail: PoutineThumbnail,
        },
        address: {
          street: &quot;230 W Kinzie Street&quot;,
          city: &quot;Green Bay&quot;,
          state: &quot;WI&quot;,
          zip: &quot;53205&quot;,
        },
        _id: &quot;3ZOZyTY1LH26LnVw&quot;,
      },
    ],
  }

  const updateState = (stateShortCode: string) =&gt; {
    setState(stateShortCode)
    setCity(&quot;&quot;)
  }

  const updateCity = (cityName: string) =&gt; {
    setCity(cityName)
  }

  return (
    &lt;&gt;
      &lt;div className=&quot;restaurants&quot;&gt;
        &lt;h2 className=&quot;page-header&quot;&gt;Restaurants&lt;/h2&gt;

        &lt;form className=&quot;form&quot;&gt;
          &lt;div className=&quot;form-group&quot;&gt;
            &lt;label className=&quot;control-label&quot; htmlFor=&quot;stateSelect&quot;&gt;
              State
            &lt;/label&gt;
            &lt;select
              className=&quot;form-control&quot;
              id=&quot;stateSelect&quot;
              onChange={(event) =&gt; updateState(event.target.value)}
              value={state}
            &gt;
              &lt;option key=&quot;choose_state&quot; value=&quot;&quot;&gt;
                {statesResponse.isPending
                  ? &quot;Loading states…&quot;
                  : statesResponse.error
                    ? statesResponse.error.message
                    : &quot;Choose a state&quot;}
              &lt;/option&gt;
              {statesResponse.data?.map(({ short, name }) =&gt; (
                &lt;option key={short} value={short}&gt;
                  {name}
                &lt;/option&gt;
              ))}
            &lt;/select&gt;
          &lt;/div&gt;

          &lt;div className=&quot;form-group&quot;&gt;
            &lt;label className=&quot;control-label&quot; htmlFor=&quot;citySelect&quot;&gt;
              City
            &lt;/label&gt;
            &lt;select
              className=&quot;form-control&quot;
              id=&quot;citySelect&quot;
              onChange={(event) =&gt; updateCity(event.target.value)}
              value={city}
            &gt;
              &lt;option key=&quot;choose_city&quot; value=&quot;&quot;&gt;
                {state
                  ? citiesResponse.isPending
                    ? &quot;Loading cities…&quot;
                    : citiesResponse.error
                      ? citiesResponse.error.message
                      : &quot;Choose a city&quot;
                  : &quot;Choose a state before selecting a city&quot;}
              &lt;/option&gt;
              {state &amp;&amp;
                citiesResponse.data?.map(({ name }) =&gt; (
                  &lt;option key={name} value={name}&gt;
                    {name}
                  &lt;/option&gt;
                ))}
            &lt;/select&gt;
          &lt;/div&gt;
        &lt;/form&gt;

        {city &amp;&amp; restaurantsResponse.error &amp;&amp; (
          &lt;p aria-live=&quot;polite&quot; className=&quot;restaurant&quot;&gt;
            Error loading restaurants: {restaurantsResponse.error.message}
          &lt;/p&gt;
        )}

        {city &amp;&amp; restaurantsResponse.isPending &amp;&amp; (
          &lt;p aria-live=&quot;polite&quot; className=&quot;restaurant loading&quot;&gt;
            Loading restaurants…
          &lt;/p&gt;
        )}

        {city &amp;&amp;
          restaurantsResponse.data &amp;&amp;
          (restaurantsResponse.data.length === 0
            ? !restaurantsResponse.isPending &amp;&amp; (
                &lt;p aria-live=&quot;polite&quot;&gt;No restaurants found.&lt;/p&gt;
              )
            : restaurantsResponse.data.map(
                ({ _id, slug, name, address, images }) =&gt; (
                  &lt;ListItem
                    key={_id}
                    address={address}
                    name={name}
                    slug={slug}
                    thumbnail={images.thumbnail}
                  /&gt;
                ),
              ))}
      &lt;/div&gt;
    &lt;/&gt;
  )
}

export default RestaurantList

</code></pre>
 <div line-highlight="4-8,121-124,127-131,133-149,only"></div>
<p>✏️ Update <strong>src/services/restaurant/interfaces.ts</strong> to be:</p>
<pre><code class="language-ts">export interface City {
  name: string
  state: string
}

interface Item {
  name: string
  price: number
}

interface Menu {
  dinner: Item[]
  lunch: Item[]
}

interface Address {
  city: string
  state: string
  street: string
  zip: string
}

interface Images {
  banner: string
  owner: string
  thumbnail: string
}

export interface Restaurant {
  _id: string
  address?: Address
  images: Images
  menu: Menu
  name: string
  slug: string
}

export interface State {
  name: string
  short: string
}

</code></pre>
 <div line-highlight="6,8,11-14,16-21,23-27,29-36,39,41,only"></div>
<p>✏️ Update <strong>src/services/restaurant/hooks.ts</strong> to be:</p>
<pre><code class="language-ts">import type { City, Restaurant, State } from &quot;./interfaces&quot;
import { useEffect, useState } from &quot;react&quot;
import { apiRequest } from &quot;../api&quot;

interface CitiesResponse {
  data: City[] | null
  error: Error | null
  isPending: boolean
}

interface StatesResponse {
  data: State[] | null
  error: Error | null
  isPending: boolean
}

export function useCities(state: string): CitiesResponse {
  const [response, setResponse] = useState&lt;CitiesResponse&gt;({
    data: null,
    error: null,
    isPending: true,
  })

  useEffect(() =&gt; {
    const fetchData = async () =&gt; {
      const { data, error } = await apiRequest&lt;CitiesResponse&gt;({
        method: &quot;GET&quot;,
        path: &quot;/cities&quot;,
        params: {
          state: state,
        },
      })

      setResponse({
        data: data?.data || null,
        error: error,
        isPending: false,
      })
    }
    fetchData()
  }, [state])

  return response
}

export function useStates(): StatesResponse {
  const [response, setResponse] = useState&lt;StatesResponse&gt;({
    data: null,
    error: null,
    isPending: true,
  })

  useEffect(() =&gt; {
    const fetchData = async () =&gt; {
      const { data, error } = await apiRequest&lt;StatesResponse&gt;({
        method: &quot;GET&quot;,
        path: &quot;/states&quot;,
      })

      setResponse({
        data: data?.data || null,
        error: error,
        isPending: false,
      })
    }
    fetchData()
  }, [])

  return response
}

</code></pre>
 <div line-highlight="1,only"></div>
<h3>Verify</h3>
<p>If you’ve implemented the solution correctly, when you use the select boxes to choose state
and city, you should see a list of just restaurants from the selected city returned.</p>
<p>✏️ Update <strong>src/pages/RestaurantList/RestaurantList.test.tsx</strong> to be:</p>
<pre><code class="language-tsx">import &quot;@testing-library/jest-dom&quot;
import { render, screen } from &quot;@testing-library/react&quot;
import userEvent from &quot;@testing-library/user-event&quot;
import { describe, expect, it, vi } from &quot;vitest&quot;

import RestaurantList from &quot;./RestaurantList&quot;

import {
  useCities,
  useRestaurants,
  useStates,
} from &quot;../../services/restaurant/hooks&quot;

// Mock the hooks used in the component
vi.mock(&quot;../../services/restaurant/hooks&quot;, () =&gt; ({
  useCities: vi.fn(() =&gt; {
    return {
      data: null,
      error: null,
      isPending: false,
    }
  }),
  useRestaurants: vi.fn(() =&gt; {
    return {
      data: null,
      error: null,
      isPending: false,
    }
  }),
  useStates: vi.fn(() =&gt; {
    return {
      data: null,
      error: null,
      isPending: false,
    }
  }),
}))

describe(&quot;RestaurantList component&quot;, () =&gt; {
  it(&quot;renders the Restaurants header&quot;, () =&gt; {
    render(&lt;RestaurantList /&gt;)
    expect(screen.getByText(/Restaurants/i)).toBeInTheDocument()
  })

  it(&quot;renders state and city dropdowns&quot;, () =&gt; {
    render(&lt;RestaurantList /&gt;)
    expect(screen.getByLabelText(/State/i)).toBeInTheDocument()
    expect(screen.getByLabelText(/City/i)).toBeInTheDocument()
  })

  it(&quot;renders correctly with initial states&quot;, () =&gt; {
    useStates.mockReturnValue({ data: null, isPending: true, error: null })
    useCities.mockReturnValue({ data: null, isPending: false, error: null })
    useRestaurants.mockReturnValue({
      data: null,
      isPending: false,
      error: null,
    })

    render(&lt;RestaurantList /&gt;)

    expect(screen.getByText(/Restaurants/)).toBeInTheDocument()
    expect(screen.getByText(/Loading states…/)).toBeInTheDocument()
  })

  it(&quot;displays error messages correctly&quot;, () =&gt; {
    useStates.mockReturnValue({
      data: null,
      isPending: false,
      error: { message: &quot;Error loading states&quot; },
    })
    useCities.mockReturnValue({
      data: null,
      isPending: false,
      error: { message: &quot;Error loading cities&quot; },
    })
    useRestaurants.mockReturnValue({
      data: null,
      isPending: false,
      error: { message: &quot;Error loading restaurants&quot; },
    })

    render(&lt;RestaurantList /&gt;)

    expect(screen.getByText(/Error loading states/)).toBeInTheDocument()
  })

  it(&quot;renders restaurants correctly&quot;, async () =&gt; {
    useStates.mockReturnValue({
      data: [{ short: &quot;CA&quot;, name: &quot;California&quot; }],
      isPending: false,
      error: null,
    })
    useCities.mockReturnValue({
      data: [{ name: &quot;Los Angeles&quot; }],
      isPending: false,
      error: null,
    })
    useRestaurants.mockReturnValue({
      data: [
        {
          _id: &quot;1&quot;,
          slug: &quot;test-restaurant&quot;,
          name: &quot;Test Restaurant&quot;,
          address: &quot;123 Test St&quot;,
          images: { thumbnail: &quot;test.jpg&quot; },
        },
      ],
      isPending: false,
      error: null,
    })

    render(&lt;RestaurantList /&gt;)

    await userEvent.selectOptions(screen.getByLabelText(/State/), &quot;CA&quot;)
    await userEvent.selectOptions(screen.getByLabelText(/City/), &quot;Los Angeles&quot;)

    expect(screen.getByText(&quot;Test Restaurant&quot;)).toBeInTheDocument()
  })
})

</code></pre>
 <div line-highlight="2,8-12,23,31,35-36,40,45,51,54,66,68,73,77-80,91-93,96-111,118,only"></div>
<p>✏️ Update <strong>src/services/restaurant/hooks.test.ts</strong> to be:</p>
<pre><code class="language-ts">import { renderHook, waitFor } from &quot;@testing-library/react&quot;
import { beforeEach, describe, expect, it, vi } from &quot;vitest&quot;
import { apiRequest } from &quot;../api&quot;
import { useCities, useRestaurants, useStates } from &quot;./hooks&quot;

// Mock the apiRequest function
vi.mock(&quot;../api&quot;, () =&gt; ({
  apiRequest: vi.fn(),
}))

describe(&quot;Hooks&quot;, () =&gt; {
  beforeEach(() =&gt; {
    vi.resetAllMocks()
  })

  describe(&quot;useCities hook&quot;, () =&gt; {
    it(&quot;should return cities data successfully&quot;, async () =&gt; {
      const mockCities = [
        { id: 1, name: &quot;City1&quot; },
        { id: 2, name: &quot;City2&quot; },
      ]
      apiRequest.mockResolvedValue({ data: { data: mockCities }, error: null })

      const { result } = renderHook(() =&gt; useCities(&quot;test-state&quot;))

      await waitFor(() =&gt; {
        expect(result.current.isPending).toBeFalsy()
        expect(result.current.data).toEqual(mockCities)
        expect(result.current.error).toBeNull()
      })
    })

    it(&quot;should handle error when fetching cities data&quot;, async () =&gt; {
      const mockError = new Error(&quot;Error fetching cities&quot;)
      apiRequest.mockResolvedValue({ data: null, error: mockError })

      const { result } = renderHook(() =&gt; useCities(&quot;test-state&quot;))

      await waitFor(() =&gt; {
        expect(result.current.isPending).toBeFalsy()
        expect(result.current.data).toBeNull()
        expect(result.current.error).toEqual(mockError)
      })
    })
  })

  describe(&quot;useRestaurants hook&quot;, () =&gt; {
    it(&quot;should return restaurants data successfully&quot;, async () =&gt; {
      const mockRestaurants = [
        { id: 1, name: &quot;Restaurant1&quot; },
        { id: 2, name: &quot;Restaurant2&quot; },
      ]
      apiRequest.mockResolvedValue({
        data: { data: mockRestaurants },
        error: null,
      })

      const { result } = renderHook(() =&gt;
        useRestaurants(&quot;test-state&quot;, &quot;test-city&quot;),
      )

      await waitFor(() =&gt; {
        expect(result.current.isPending).toBeFalsy()
        expect(result.current.data).toEqual(mockRestaurants)
        expect(result.current.error).toBeNull()
      })
    })

    it(&quot;should handle error when fetching restaurants data&quot;, async () =&gt; {
      const mockError = new Error(&quot;Error fetching restaurants&quot;)
      apiRequest.mockResolvedValue({ data: null, error: mockError })

      const { result } = renderHook(() =&gt;
        useRestaurants(&quot;test-state&quot;, &quot;test-city&quot;),
      )

      await waitFor(() =&gt; {
        expect(result.current.isPending).toBeFalsy()
        expect(result.current.data).toBeNull()
        expect(result.current.error).toEqual(mockError)
      })
    })
  })

  describe(&quot;useStates hook&quot;, () =&gt; {
    it(&quot;should return states data successfully&quot;, async () =&gt; {
      const mockStates = [
        { id: 1, name: &quot;State1&quot; },
        { id: 2, name: &quot;State2&quot; },
      ]
      apiRequest.mockResolvedValue({ data: { data: mockStates }, error: null })

      const { result } = renderHook(() =&gt; useStates())

      await waitFor(() =&gt; {
        expect(result.current.isPending).toBeFalsy()
        expect(result.current.data).toEqual(mockStates)
        expect(result.current.error).toBeNull()
      })
    })

    it(&quot;should handle error when fetching states data&quot;, async () =&gt; {
      const mockError = new Error(&quot;Error fetching states&quot;)
      apiRequest.mockResolvedValue({ data: null, error: mockError })

      const { result } = renderHook(() =&gt; useStates())

      await waitFor(() =&gt; {
        expect(result.current.isPending).toBeFalsy()
        expect(result.current.data).toBeNull()
        expect(result.current.error).toEqual(mockError)
      })
    })
  })
})

</code></pre>
 <div line-highlight="4,47-51,53-55,58-60,64,69-70,73-75,81,90,95-96,98-100,104,108-114,only"></div>
<h3>Exercise</h3>
<ul>
<li>Implement a <code>useRestaurants</code> Hook to fetch restaurant data.</li>
<li>Update <code>RestaurantList.tsx</code> to use your new <code>useRestaurants</code> Hook.</li>
</ul>
<p>Hint: The requested URL with query parameters should look like this:
<code>'/api/restaurants?filter[address.state]=IL&amp;filter[address.city]=Chicago'</code></p>
<h3>Solution</h3>
<p><details>
<summary>Click to see the solution</summary></p>
<p>✏️ Update <strong>src/pages/RestaurantList/RestaurantList.tsx</strong> to be:</p>
<pre><code class="language-tsx">import { useState } from &quot;react&quot;
import {
  useCities,
  useRestaurants,
  useStates,
} from &quot;../../services/restaurant/hooks&quot;
import ListItem from &quot;./ListItem&quot;

const RestaurantList: React.FC = () =&gt; {
  const [state, setState] = useState(&quot;&quot;)
  const [city, setCity] = useState(&quot;&quot;)

  const statesResponse = useStates()

  const citiesResponse = useCities(state)

  const restaurantsResponse = useRestaurants(state, city)

  const updateState = (stateShortCode: string) =&gt; {
    setState(stateShortCode)
    setCity(&quot;&quot;)
  }

  const updateCity = (cityName: string) =&gt; {
    setCity(cityName)
  }

  return (
    &lt;&gt;
      &lt;div className=&quot;restaurants&quot;&gt;
        &lt;h2 className=&quot;page-header&quot;&gt;Restaurants&lt;/h2&gt;

        &lt;form className=&quot;form&quot;&gt;
          &lt;div className=&quot;form-group&quot;&gt;
            &lt;label className=&quot;control-label&quot; htmlFor=&quot;stateSelect&quot;&gt;
              State
            &lt;/label&gt;
            &lt;select
              className=&quot;form-control&quot;
              id=&quot;stateSelect&quot;
              onChange={(event) =&gt; updateState(event.target.value)}
              value={state}
            &gt;
              &lt;option key=&quot;choose_state&quot; value=&quot;&quot;&gt;
                {statesResponse.isPending
                  ? &quot;Loading states…&quot;
                  : statesResponse.error
                    ? statesResponse.error.message
                    : &quot;Choose a state&quot;}
              &lt;/option&gt;
              {statesResponse.data?.map(({ short, name }) =&gt; (
                &lt;option key={short} value={short}&gt;
                  {name}
                &lt;/option&gt;
              ))}
            &lt;/select&gt;
          &lt;/div&gt;

          &lt;div className=&quot;form-group&quot;&gt;
            &lt;label className=&quot;control-label&quot; htmlFor=&quot;citySelect&quot;&gt;
              City
            &lt;/label&gt;
            &lt;select
              className=&quot;form-control&quot;
              id=&quot;citySelect&quot;
              onChange={(event) =&gt; updateCity(event.target.value)}
              value={city}
            &gt;
              &lt;option key=&quot;choose_city&quot; value=&quot;&quot;&gt;
                {state
                  ? citiesResponse.isPending
                    ? &quot;Loading cities…&quot;
                    : citiesResponse.error
                      ? citiesResponse.error.message
                      : &quot;Choose a city&quot;
                  : &quot;Choose a state before selecting a city&quot;}
              &lt;/option&gt;
              {state &amp;&amp;
                citiesResponse.data?.map(({ name }) =&gt; (
                  &lt;option key={name} value={name}&gt;
                    {name}
                  &lt;/option&gt;
                ))}
            &lt;/select&gt;
          &lt;/div&gt;
        &lt;/form&gt;

        {city &amp;&amp; restaurantsResponse.error &amp;&amp; (
          &lt;p aria-live=&quot;polite&quot; className=&quot;restaurant&quot;&gt;
            Error loading restaurants: {restaurantsResponse.error.message}
          &lt;/p&gt;
        )}

        {city &amp;&amp; restaurantsResponse.isPending &amp;&amp; (
          &lt;p aria-live=&quot;polite&quot; className=&quot;restaurant loading&quot;&gt;
            Loading restaurants…
          &lt;/p&gt;
        )}

        {city &amp;&amp;
          restaurantsResponse.data &amp;&amp;
          (restaurantsResponse.data.length === 0
            ? !restaurantsResponse.isPending &amp;&amp; (
                &lt;p aria-live=&quot;polite&quot;&gt;No restaurants found.&lt;/p&gt;
              )
            : restaurantsResponse.data.map(
                ({ _id, slug, name, address, images }) =&gt; (
                  &lt;ListItem
                    key={_id}
                    address={address}
                    name={name}
                    slug={slug}
                    thumbnail={images.thumbnail}
                  /&gt;
                ),
              ))}
      &lt;/div&gt;
    &lt;/&gt;
  )
}

export default RestaurantList

</code></pre>
 <div line-highlight="17,only"></div>
<p>✏️ Update <strong>src/services/restaurant/hooks.ts</strong> to be:</p>
<pre><code class="language-ts">import type { City, Restaurant, State } from &quot;./interfaces&quot;
import { useEffect, useState } from &quot;react&quot;
import { apiRequest } from &quot;../api&quot;

interface CitiesResponse {
  data: City[] | null
  error: Error | null
  isPending: boolean
}

interface RestaurantsResponse {
  data: Restaurant[] | null
  error: Error | null
  isPending: boolean
}

interface StatesResponse {
  data: State[] | null
  error: Error | null
  isPending: boolean
}

export function useCities(state: string): CitiesResponse {
  const [response, setResponse] = useState&lt;CitiesResponse&gt;({
    data: null,
    error: null,
    isPending: true,
  })

  useEffect(() =&gt; {
    const fetchData = async () =&gt; {
      const { data, error } = await apiRequest&lt;CitiesResponse&gt;({
        method: &quot;GET&quot;,
        path: &quot;/cities&quot;,
        params: {
          state: state,
        },
      })

      setResponse({
        data: data?.data || null,
        error: error,
        isPending: false,
      })
    }
    fetchData()
  }, [state])

  return response
}

export function useRestaurants(
  state: string,
  city: string,
): RestaurantsResponse {
  const [response, setResponse] = useState&lt;RestaurantsResponse&gt;({
    data: null,
    error: null,
    isPending: true,
  })

  useEffect(() =&gt; {
    const fetchData = async () =&gt; {
      const { data, error } = await apiRequest&lt;RestaurantsResponse&gt;({
        method: &quot;GET&quot;,
        path: &quot;/restaurants&quot;,
        params: {
          &quot;filter[address.state]&quot;: state,
          &quot;filter[address.city]&quot;: city,
        },
      })

      setResponse({
        data: data?.data || null,
        error: error,
        isPending: false,
      })
    }
    fetchData()
  }, [state, city])

  return response
}

export function useStates(): StatesResponse {
  const [response, setResponse] = useState&lt;StatesResponse&gt;({
    data: null,
    error: null,
    isPending: true,
  })

  useEffect(() =&gt; {
    const fetchData = async () =&gt; {
      const { data, error } = await apiRequest&lt;StatesResponse&gt;({
        method: &quot;GET&quot;,
        path: &quot;/states&quot;,
      })

      setResponse({
        data: data?.data || null,
        error: error,
        isPending: false,
      })
    }
    fetchData()
  }, [])

  return response
}

</code></pre>
 <div line-highlight="11-12,19-20,52-56,64,66-70,80,83,87-90,92-93,95,97,99-105,108-109,only"></div>
<p></details></p>
<h2>Next steps</h2>
<p>TODO</p>

</section>

  			
  			<bit-prev-next class="footer" list-selector=".sidebar-left ul li.parent.expanded ul"></bit-prev-next>
  		
    </div>

    
      <div class="sidebar-right">
        <div class="content-nav on-this-page-container">
          <h6>On this page...</h6>
          <div class="list-items" id="scroll-toc">
            <bit-toc heading-container-selector="article.main" scroll-selector="#scroll-toc"></bit-toc>
          </div>
        </div>
        <div class="pullout discord">
          <h6>Get help</h6>
          <p>If you need <a href="https://discord.gg/J7ejFsZnJ4">help</a> with an exercise, please reach out to us on
             <a href="https://discord.gg/J7ejFsZnJ4">Discord</a></p>
        </div>
        <div class="pullout bug">
          <p>If you find a bug, please
             <a href="https://github.com/bitovi/academy/issues/new">create an issue</a> or email
             <a href="mailto:contact@bitovi.com?Subject=Training%20Suggestion" target="_blank">contact@bitovi.com</a></p>
        </div>
      </div>
    

	</article>
</div>



  <footer></footer>

  <div id="scripts">
    <script type="text/javascript">
      var docObject = {"src":{"path":"src/react-native/10-making-http-requests/making-http-requests.md"},"description":"Learn about how to make `fetch` requests and render requested data in React components. \n","name":"learn-react-native/making-http-requests","title":"Making HTTP Requests","type":"page","parent":"learn-react-native","order":10,"comment":" ","pathToRoot":"../.."};
    </script>

    
      <script>
        steal = {
          instantiated: {
            "bundles/bit-docs-site/static.css!$css" : null
          }
        }
      </script>
      <script type='text/javascript'
          data-main="bit-docs-site/static"
          src="../static/steal.production.js"></script>
    

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-2302003-12"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-2302003-12');
    </script>

  </div>
  <div id="email-modal" role="dialog" aria-modal="true" aria-labelledby="dialog_label" style="display: none;">
    <div aria-hidden="true" class="email-modal-backdrop"></div>
    <div role="region" class="email-modal-content">
      <h2 id="dialog_label">Join the Bitovi Newsletter</h2>
      <p>
        Do you want to receive updates about new Bitovi Academy courses, Bitovi open source projects, and dev community news? If so, please provide your email. We won’t spam you or give it away for any reason!<br />
        <i style="font-size: 0.8rem;">By providing your email you agree to receive communications from Bitovi</i>
      </p>
      <div id="academy-hubspot-form-embed"></div>
      <script charset="utf-8" type="text/javascript" src="//js.hsforms.net/forms/embed/v2.js"></script>
      <button id="email-modal-close" title="dismiss"><img src="../static/img/close.svg" height="24" width="24"></button>
    </div>
  </div>
</body>
</html>

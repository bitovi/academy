<!DOCTYPE html>
<!--####################################################################
	THIS IS A GENERATED FILE — ANY CHANGES MADE WILL BE OVERWRITTEN

	INSTEAD CHANGE:
	source: src/react-native/17-offline-support/offline-support.md
	@page learn-react-native/offline-support
######################################################################## -->
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="google-site-verification" content="UMCgjrWAjJW_tHmYo6AerdZvVdmh8QHdY9Ywb59tpHw" />
  <meta name="description" content="Learn device-first strategies for storing data and syncing it to a server. 
">
  
  <!-- Google Tag Manager -->
  <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-P9MQVJS');</script>
  <!-- End Google Tag Manager -->

  <title>Bitovi Academy - Adding Offline Support</title>
  
  <link rel="stylesheet" type="text/css" href="../static/bundles/bit-docs-site/static.css">
  
</head>

<body>
  <!-- Google Tag Manager (noscript) -->
  <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-P9MQVJS"
  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  <!-- End Google Tag Manager (noscript) -->
  
  <div class="header">
    <div class="logo">
      <a href="https://www.bitovi.com/">Bitovi</a>
    </div>
    <ul>
      <li><a href="https://www.bitovi.com/services">Services</a></li>
      <li><a href="https://www.bitovi.com/client-work">Client Work</a></li>
      <li><a href="https://www.bitovi.com/about">Our Team</a></li>
      <li><a href="https://www.bitovi.com/open-source">Open Source</a></li>
      <li><a href="https://www.bitovi.com/blog">Blog</a></li>
      <li><a href=".." class="active">Academy</a></li>
     </ul>
     <a class="contact-popup hs-button brand button-smallest" href="https://www.bitovi.com/contact">Contact Us</a>
  </div>

  <div class="content">
	
		<div class="sidebar-left">
  
    
	<ul>
		
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-advanced-javascript.html"
							title="This course covers all the hard but important stuff you should know when learning JavaScript.">
							Advanced JavaScript
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-dom-jquery.html"
							title="Learn jQuery and the DOM APIs by building your own version of jQuery and using it to make a basic tabs widget. We strongly suggest finishing learn-advanced-javascript prior to starting this course.">
							DOM and jQuery
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-to-debug-javascript.html"
							title="This course covers the basics of JavaScript debugging.">
							Debug JavaScript
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-typescript.html"
							title="This course covers the basic essentials of TypeScript. At the end, you should be ready to develop projects in TypeScript.">
							Learn TypeScript
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						parent
           						expanded">
						<a class="page"
							href="../learn-react-native.html"
							title="Learn React Native by building the feature-rich Place My Order application in this beginner React Native guide. This hands-on course will introduce you to fundamental React Native concepts! By the end of this course, you will have a strong understanding of JSX, function components, styling, state management, Hooks, data fetching, routing, and testing.">
							Learn React Native
						</a>
						
							
	<ul>
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="intro-to-react-native.html"
							title="Discover why React Native is a great choice for modern mobile application development.">
							Introduction to React Native
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="setting-up-your-environment.html"
							title="Learn how to set up your environment for React Native development.">
							Setting Up Your Environment
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="creating-a-new-app.html"
							title="Generate a new React Native application using the CLI.">
							Creating a New Application
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="intro-to-jsx.html"
							title="Learn how to use JSX to define your UI in React Native.">
							Introduction to JSX
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="intro-to-testing.html"
							title="Learn about testing solutions in React Native.">
							Introduction to Testing
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="building-custom-components.html"
							title="Learn about components, the core building blocks of every React application.">
							Building Custom Components
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="debugging-devtools.html"
							title="Learn how to set up and use both DevTools and Debugger.">
							Debugging and DevTools
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="styling.html"
							title="Learn how to use the style prop and the StyleSheet API in React Native.">
							Styling in React Native
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="react-context.html"
							title="Learn how to share a common theme by creating a React Context.">
							Using React Context
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="managing-state.html"
							title="Work with React’s useState Hook to manage a component’s state.">
							Managing State with useState
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="navigation.html"
							title="Learn how to use navigation to move between screens in a React Native app.">
							Navigation in React Native
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="navigation-params.html"
							title="Maintain the React state with React Native Navigation Parameters">
							Storing State in Navigation Parameters
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="making-http-requests.html"
							title="Learn about how to make fetch requests and render requested data in React Native components.">
							Making HTTP Requests
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="user-inputs.html"
							title="Use switch controls and inputs to collect information.">
							Handling User Inputs
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="using-asyncstorage.html"
							title="Store data locally on device with Async Storage and run data migrations with new versions of your application.">
							Using Async Storage
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="security-and-auth.html"
							title="Learn about OAuth, google-signin, and how to secure your React Native app.">
							Security and Authentication
						</a>
						
					</li>
				
			
		
			
				
					<li class="current
           						parent
           						expanded">
						<a class="page"
							href="offline-support.html"
							title="Learn device-first strategies for storing data and syncing it to a server.">
							Adding Offline Support
						</a>
						
							

						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="google-maps.html"
							title="Learn how to integrate Google Maps into your React Native application.">
							Integrating Maps
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="performance-optimization.html"
							title="Improve the application’s launch time by implementing lazy loading.">
							Performance and Optimization
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="building.html"
							title="Learn how to build Android App Bundles (AAB).">
							Building React Native Apps
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="publishing-and-updating.html"
							title="Preparation for the steps to Publish and Update a production application on Stores.">
							Publishing and Updating
						</a>
						
					</li>
				
			
		
	</ul>


						
					</li>
				
			
		
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-web-components.html"
							title="">
							Learn Web Components
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-agile-program-management-with-jira.html"
							title="Learn how to build, maintain, and report on accurate multi-team plans with Jira.">
							Agile Program Management With Jira
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-rxjs.html"
							title="Learn RxJS by creating a validating credit card form.">
							Learn RxJS
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../training.html"
							title="Learn how to prepare and give a training.">
							Giving a Training
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-technology-consulting.html"
							title="Learn how to move beyond writing code to be an excellent technology consultant!">
							Learn Technology Consulting
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-react.html"
							title="Learn React by building the feature-rich Place My Order application in this beginner React guide. This hands-on course will introduce you to fundamental React concepts! By the end of this course, you will have a strong understanding of JSX, function components, styling, state management, Hooks, data fetching, routing, and testing.">
							Learn React
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-ngrx.html"
							title="Learn how to manage state in an Angular application using NgRx.">
							Learn NgRx
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-graphql.html"
							title="Build a backend application for property rentals using Node JS, GraphQL and Apollo Server.         Learn about using ORMs like Mongoose and Prisma with a NoSQL Mongo database!
Write testcases testing created endpoints.">
							Learn Graphql
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-docker.html"
							title="Build and containerize a Node.js app then orchestrate multiple containers with docker-compose in this Docker guide.">
							Learn Docker
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-canjs.html"
							title="This tutorial walks through building TodoMVC with StealJS. It includes KeyNote presentations
covering CanJS core libraries.">
							Learn CanJS
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-angular.html"
							title="Learn how to build a moderately complex application with Angular.">
							Learn Angular
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../advanced-typescript.html"
							title="This is the second course in the TypeScript series. By the end, you will be comfortable with any types you come across and possess the knowledge to create your own advanced types. The only prerequisite is the first course in the TypeScript series found here.">
							Advanced TypeScript
						</a>
						
					</li>
				
			
		
	</ul>


  
  <p class="border">
      <a href="..#courses">View More Courses</a>
      <a class='bit-academy-fullscreen' title='fullscreen' href="javascript://">[ ]</a>
  </p>
</div>

	
	<article class="main">
    <div class="main-content">
  		
  			<section class="title">
	<h1>Adding Offline Support <code>page</code></h1>
</section>

  		

  		
  			
  				<section class="description">
    <p>Learn device-first strategies for storing data and syncing it to a server.</p>

</section>

  			
  		

  		
  			
  				
  			
  			
  				<section class="body">
    <h2>Overview</h2>
<p>In this section, you will:</p>
<ul>
<li>Listen for changes to the network connection state.</li>
<li>Make an API call when the user signs in.</li>
<li>Design offline-syncing behavior.</li>
<li>Sync data between the device and server.</li>
</ul>
<h2>Objective 1: Show the current connection status</h2>
<p>Most mobile applications use a network connection for critical functionality.
It’s important to communicate to the user when their device is offline and some functionality in the application may be disabled because of their current connection status.</p>
<p>The way you communicate this info will depend on your application.
In ours, we’re going to add some text to the Settings view that shows the current connection status.</p>
<p><img alt="Screenshot of the application settings page with the connection status." src="../static/img/react-native/17-offline-support/01-solution.png" style="max-height: 640px; border: 4px solid black; border-radius: 25px;"/></p>
<h3>Listening for the network connection state</h3>
<p>The <code>@react-native-community/netinfo</code> is an incredible useful package for detecting the network status of the device.</p>
<p>This package allows you to:</p>
<ul>
<li>Detect whether the device is connected to the internet.</li>
<li>Determine the type of network connection (WiFi, cellular, etc.).</li>
<li>React to changes in the network status, allowing the app to adapt accordingly.</li>
</ul>
<h3>Getting the current connection state</h3>
<p>The <code>useNetInfo</code> Hook provided by the package simplifies the process of accessing network state information in functional components.
This Hook returns an object containing details about the network status.</p>
<pre><code class="language-tsx">import { useNetInfo } from &quot;@react-native-community/netinfo&quot;
import React from &quot;react&quot;
import { Text, View } from &quot;react-native&quot;

const NetworkStatusComponent = () =&gt; {
  const { isConnected } = useNetInfo()

  return (
    &lt;View&gt;
      &lt;Text&gt;Is connected: {isConnected ? &quot;Yes&quot; : &quot;No&quot;}&lt;/Text&gt;
    &lt;/View&gt;
  )
}

export default NetworkStatusComponent

</code></pre>
<div line-highlight='1, 6, 10, only'></div>
<h3>Setup 1</h3>
<p>✏️ Install the new dependency:</p>
<pre><code class="language-bash">npm install @react-native-community/netinfo@11
</code></pre>
<p>✏️ Update <strong>jest-setup.ts</strong> to be:</p>
<pre><code class="language-ts">import &quot;@testing-library/react-native/extend-expect&quot;

import &quot;react-native-gesture-handler/jestSetup&quot;
import &quot;@react-native-google-signin/google-signin/jest/build/setup&quot;

import mockRNCNetInfo from &quot;@react-native-community/netinfo/jest/netinfo-mock&quot;

jest.mock(&quot;@react-native-community/netinfo&quot;, () =&gt; mockRNCNetInfo)

jest.mock(&quot;@react-navigation/native&quot;, () =&gt; {
  const actualNav = jest.requireActual(&quot;@react-navigation/native&quot;)
  return {
    ...actualNav,
    useNavigation: () =&gt; ({
      navigate: jest.fn(),
      setOptions: jest.fn(),
    }),
  }
})

jest.mock(&quot;./src/services/storage/storage&quot;, () =&gt;
  require(&quot;./src/services/storage/storage.mock&quot;),
)

jest.mock(&quot;@react-native-async-storage/async-storage&quot;, () =&gt;
  require(&quot;@react-native-async-storage/async-storage/jest/async-storage-mock&quot;),
)

const consoleError = console.error
console.error = (message, ...args) =&gt; {
  if (
    typeof message === &quot;string&quot; &amp;&amp;
    message.match(
      /Warning: An update to .+ inside a test was not wrapped in act\(\.\.\.\)\./,
    )
  ) {
    return
  }

  return consoleError(message, ...args)
}

</code></pre>
 <div line-highlight="6,8,only"></div>
<p>✏️ Update <strong>src/screens/Settings/Settings.tsx</strong> to be:</p>
<pre><code class="language-tsx">import { useNetInfo } from &quot;@react-native-community/netinfo&quot;
import { GoogleSigninButton } from &quot;@react-native-google-signin/google-signin&quot;
import { StyleSheet, Switch, View } from &quot;react-native&quot;

import Button from &quot;../../design/Button&quot;
import Card from &quot;../../design/Card&quot;
import Screen from &quot;../../design/Screen&quot;
import { useThemeMode } from &quot;../../design/theme&quot;
import Typography from &quot;../../design/Typography&quot;
import { useAuthentication, useUser } from &quot;../../services/auth&quot;

const Settings: React.FC = () =&gt; {
  const { signIn, signOut } = useAuthentication()
  const user = useUser()
  const { mode, setMode } = useThemeMode()
  // Exercise: Get the current connection state with the `useNetInfo()` Hook.

  return (
    &lt;Screen&gt;
      &lt;Card&gt;
        {user ? (
          &lt;&gt;
            &lt;Typography variant=&quot;heading&quot;&gt;Welcome back, {user.name}&lt;/Typography&gt;
            &lt;Button onPress={signOut}&gt;Sign Out&lt;/Button&gt;
          &lt;/&gt;
        ) : (
          &lt;GoogleSigninButton onPress={signIn} style={{ width: &quot;100%&quot; }} /&gt;
        )}
      &lt;/Card&gt;
      &lt;Card&gt;
        &lt;View style={styles.row}&gt;
          &lt;Typography variant=&quot;heading&quot;&gt;Dark mode&lt;/Typography&gt;
          &lt;Switch
            onValueChange={(value) =&gt; setMode(value ? &quot;dark&quot; : &quot;light&quot;)}
            value={mode === &quot;dark&quot;}
          /&gt;
        &lt;/View&gt;
      &lt;/Card&gt;
      {/* Exercise: Display the connection state in the Settings view. */}
    &lt;/Screen&gt;
  )
}

const styles = StyleSheet.create({
  row: {
    flexDirection: &quot;row&quot;,
    alignItems: &quot;center&quot;,
    justifyContent: &quot;space-between&quot;,
  },
})

export default Settings

</code></pre>
 <div line-highlight="1,16,39,only"></div>
<h3>Verify 1</h3>
<p>TODO: We need tests for this exercise.</p>
<h3>Exercise 1</h3>
<ul>
<li>Get the current connection state with the <code>useNetInfo()</code> Hook.</li>
<li>Display the connection state in the Settings view.</li>
</ul>
<h3>Solution 1</h3>
<p>If you’ve implemented the solution correctly, the tests will pass when you run <code>npm run test</code>!</p>
<p><details>
<summary>Click to see the solution</summary></p>
<p>✏️ Update <strong>src/screens/Settings/Settings.tsx</strong> to be:</p>
<pre><code class="language-tsx">import { useNetInfo } from &quot;@react-native-community/netinfo&quot;
import { GoogleSigninButton } from &quot;@react-native-google-signin/google-signin&quot;
import { StyleSheet, Switch, View } from &quot;react-native&quot;

import Button from &quot;../../design/Button&quot;
import Card from &quot;../../design/Card&quot;
import Screen from &quot;../../design/Screen&quot;
import { useThemeMode } from &quot;../../design/theme&quot;
import Typography from &quot;../../design/Typography&quot;
import { useAuthentication, useUser } from &quot;../../services/auth&quot;

const Settings: React.FC = () =&gt; {
  const { signIn, signOut } = useAuthentication()
  const user = useUser()
  const { mode, setMode } = useThemeMode()
  const { isConnected } = useNetInfo()

  return (
    &lt;Screen&gt;
      &lt;Card&gt;
        {user ? (
          &lt;&gt;
            &lt;Typography variant=&quot;heading&quot;&gt;Welcome back, {user.name}&lt;/Typography&gt;
            &lt;Button onPress={signOut}&gt;Sign Out&lt;/Button&gt;
          &lt;/&gt;
        ) : (
          &lt;GoogleSigninButton onPress={signIn} style={{ width: &quot;100%&quot; }} /&gt;
        )}
      &lt;/Card&gt;
      &lt;Card&gt;
        &lt;View style={styles.row}&gt;
          &lt;Typography variant=&quot;heading&quot;&gt;Dark mode&lt;/Typography&gt;
          &lt;Switch
            onValueChange={(value) =&gt; setMode(value ? &quot;dark&quot; : &quot;light&quot;)}
            value={mode === &quot;dark&quot;}
          /&gt;
        &lt;/View&gt;
      &lt;/Card&gt;
      &lt;Card&gt;
        &lt;Typography&gt;
          Connection Status: {isConnected ? &quot;Online&quot; : &quot;Offline&quot;}
        &lt;/Typography&gt;
      &lt;/Card&gt;
    &lt;/Screen&gt;
  )
}

const styles = StyleSheet.create({
  row: {
    flexDirection: &quot;row&quot;,
    alignItems: &quot;center&quot;,
    justifyContent: &quot;space-between&quot;,
  },
})

export default Settings

</code></pre>
 <div line-highlight="16,39-43,only"></div>
<p></details></p>
<h2>Objective 2: Store restaurant favorites on device</h2>
<p>Now that you can detect when the device is online or offline, let’s build a feature that can work offline!</p>
<p>Let’s add the ability to “favorite” a restaurant.
In the <code>RestaurantDetails</code>, we’ll add an “Add to favorites” button when the user is signed in, and if they favorite a restaurant, we’ll change it to “Remove from favorites.”</p>
<p>For right now, we’ll write the code for adding and removing favorites in a way that will gracefully handle the user’s device being offline.
In the third objective, we’ll expand that to handle syncing when the device comes back online.</p>
<div style="display: flex; flex-direction: row; gap: 2rem">
  <img alt="Screenshot of the application's Restaurant Details screen displaying the add favorite button." src="../static/img/react-native/17-offline-support/02-solution-addFavorites.png" style="max-height: 640px; border: 4px solid black; border-radius: 25px;"/>
  <img alt="Screenshot of the application's Restaurant Details screen displaying the remove favorite button." src="../static/img/react-native/17-offline-support/02-solution-removeFavorites.png" style="max-height: 640px; border: 4px solid black; border-radius: 25px;"/>
</div>
<h3>Defining the “favorites” feature</h3>
<p>There’s a lot that goes into building even a one or two-button feature like the “add to favorites” and “remove from favorites” feature that we’re about to build.</p>
<p>Let’s think through what we want in the restaurant details view:</p>
<ul>
<li>When the user is not signed in or they haven’t added the restaurant as a favorite, there should be an “Add to favorites” button.</li>
<li>When the user has added the restaurant as a favorite, there should be a “Remove from favorites” button.</li>
<li>When the “Add” button is clicked and the user is not signed in, they should be sent through the sign-in flow.</li>
<li>When the “Add” or “Remove” buttons are clicked and the user is signed in, that change should immediately be saved in our Async Storage and sent to the API.</li>
<li>If there’s a problem with the API call (the server is down, the device is offline, etc.), then the change should still be saved to Async Storage.</li>
</ul>
<p>Features like this are great to build into Hooks because it makes the logic more easily testable and reusable.
Let’s look at the Hook code we are going to copy in the Setup step for this exercise.</p>
<h3>Creating a <code>useFavorites()</code> Hook</h3>
<p>Our <code>useFavorites()</code> Hook will accept two arguments:</p>
<pre><code class="language-ts">import { useEffect, useState } from &quot;react&quot;

import { storeData, getData } from &quot;../../storage/storage&quot;
import { apiRequest } from &quot;../api&quot;

interface Favorite {
  userId: string
  restaurantId: string
  favorite: boolean
  datetimeUpdated: Date
  _id?: string
}

interface FavoritesResponse {
  data: Favorite[] | undefined
  error: Error | undefined
  isPending: boolean
}

interface FavoriteResponse {
  data: Favorite | undefined
  error: Error | undefined
  isPending: boolean
}

interface LocalStorageFavorites {
  lastSynced: Date
  favorites: Favorite[]
}

export const useFavorites = (
  userId?: string,
  restaurantId?: string,
): FavoritesResponse &amp; {
  updateFavorites: (restaurantId: Favorite[&quot;restaurantId&quot;]) =&gt; void
  favorite: Favorite | undefined
} =&gt; {
  const [response, setResponse] = useState&lt;FavoritesResponse&gt;({
    data: undefined,
    error: undefined,
    isPending: true,
  })
  const [localFavorites, setLocalFavorites] = useState&lt;
    LocalStorageFavorites | undefined
  &gt;()
  const [favorite, setFavorite] = useState&lt;Favorite | undefined&gt;()

  useEffect(() =&gt; {
    // Gathering favorites from both DB and local storage.
    const fetchData = async () =&gt; {
      const localFavorites = await getData&lt;LocalStorageFavorites&gt;(&quot;my-favorite&quot;)
      setLocalFavorites(
        localFavorites
          ? localFavorites
          : { favorites: [], lastSynced: new Date() },
      )

      const { data, error } = await apiRequest&lt;FavoritesResponse&gt;({
        method: &quot;GET&quot;,
        path: &quot;/favorites&quot;,
        params: {
          userId: userId,
        },
      })

      setResponse({
        data: Array.isArray(data) ? data : data?.data ?? undefined,
        error: error,
        isPending: false,
      })
    }
    if (userId) {
      fetchData()
    }
  }, [userId])

  useEffect(() =&gt; {
    // Finding the restaurant's favorite status.
    if (restaurantId) {
      const getFavorite = async (restaurantId: Favorite[&quot;restaurantId&quot;]) =&gt; {
        const foundFavorite = localFavorites?.favorites.find(
          (favorite) =&gt; favorite.restaurantId === restaurantId,
        )
        setFavorite(foundFavorite)
      }

      getFavorite(restaurantId)
    }
  }, [restaurantId, localFavorites])

  const updateFavorites = async (restaurantId: Favorite[&quot;restaurantId&quot;]) =&gt; {
    if (localFavorites?.favorites) {
      const favoriteIndex = localFavorites.favorites.findIndex(
        (favorite) =&gt; favorite.restaurantId === restaurantId,
      )
      const newFavorites = [...localFavorites.favorites]
      const timestamp = new Date()
      let newFavorite = {}

      if (favoriteIndex === -1) {
        // If the favorite isn’t in storage, then create a new entry.
        newFavorite = {
          userId: userId,
          restaurantId: restaurantId,
          favorite: true,
          datetimeUpdated: timestamp,
        }
        newFavorites.push(newFavorite as Favorite)
      } else {
        // Otherwise, if the favorite is in storage, then update the existing entry.
        newFavorite = {
          ...newFavorites[favoriteIndex],
          favorite: !newFavorites[favoriteIndex].favorite,
          datetimeUpdated: timestamp,
        }
        newFavorites[favoriteIndex] = newFavorite as Favorite
      }

      const { data: postRes, error } = await apiRequest&lt;FavoriteResponse&gt;({
        method: &quot;POST&quot;,
        path: &quot;/favorites&quot;,
        body: newFavorite,
      })

      if (!(&quot;_id&quot; in newFavorite) &amp;&amp; postRes &amp;&amp; postRes.data) {
        // Assign the _id property created from the API call to the new favorite.
        newFavorites[newFavorites.length - 1]._id = postRes.data._id
      }

      /*
        Exercise:
          1) Update the `my-favorite` storage item with an object that contains the `newFavorites`.
          2) Update the `localFavorites` state.
          3) Update the `response` state.
      */
    }
  }

  return {
    ...response,
    updateFavorites,
    favorite,
  }
}

</code></pre>
<div line-highlight='32-33, only'></div>
<p>You’ll remember that the Rules of Hooks state that Hooks must always be called at the top level of a component, so this Hook makes these properties optional because, for example, you may not be signed in (and thus won’t have a <code>userId</code>).</p>
<h3>Determining if a restaurant is a favorite</h3>
<p>The Hook will return a <code>true</code> or <code>false</code> value for <code>favorite</code>, depending on whether the restaurant is a favorite:</p>
<pre><code class="language-ts">import { useEffect, useState } from &quot;react&quot;

import { storeData, getData } from &quot;../../storage/storage&quot;
import { apiRequest } from &quot;../api&quot;

interface Favorite {
  userId: string
  restaurantId: string
  favorite: boolean
  datetimeUpdated: Date
  _id?: string
}

interface FavoritesResponse {
  data: Favorite[] | undefined
  error: Error | undefined
  isPending: boolean
}

interface FavoriteResponse {
  data: Favorite | undefined
  error: Error | undefined
  isPending: boolean
}

interface LocalStorageFavorites {
  lastSynced: Date
  favorites: Favorite[]
}

export const useFavorites = (
  userId?: string,
  restaurantId?: string,
): FavoritesResponse &amp; {
  updateFavorites: (restaurantId: Favorite[&quot;restaurantId&quot;]) =&gt; void
  favorite: Favorite | undefined
} =&gt; {
  const [response, setResponse] = useState&lt;FavoritesResponse&gt;({
    data: undefined,
    error: undefined,
    isPending: true,
  })
  const [localFavorites, setLocalFavorites] = useState&lt;
    LocalStorageFavorites | undefined
  &gt;()
  const [favorite, setFavorite] = useState&lt;Favorite | undefined&gt;()

  useEffect(() =&gt; {
    // Gathering favorites from both DB and local storage.
    const fetchData = async () =&gt; {
      const localFavorites = await getData&lt;LocalStorageFavorites&gt;(&quot;my-favorite&quot;)
      setLocalFavorites(
        localFavorites
          ? localFavorites
          : { favorites: [], lastSynced: new Date() },
      )

      const { data, error } = await apiRequest&lt;FavoritesResponse&gt;({
        method: &quot;GET&quot;,
        path: &quot;/favorites&quot;,
        params: {
          userId: userId,
        },
      })

      setResponse({
        data: Array.isArray(data) ? data : data?.data ?? undefined,
        error: error,
        isPending: false,
      })
    }
    if (userId) {
      fetchData()
    }
  }, [userId])

  useEffect(() =&gt; {
    // Finding the restaurant's favorite status.
    if (restaurantId) {
      const getFavorite = async (restaurantId: Favorite[&quot;restaurantId&quot;]) =&gt; {
        const foundFavorite = localFavorites?.favorites.find(
          (favorite) =&gt; favorite.restaurantId === restaurantId,
        )
        setFavorite(foundFavorite)
      }

      getFavorite(restaurantId)
    }
  }, [restaurantId, localFavorites])

  const updateFavorites = async (restaurantId: Favorite[&quot;restaurantId&quot;]) =&gt; {
    if (localFavorites?.favorites) {
      const favoriteIndex = localFavorites.favorites.findIndex(
        (favorite) =&gt; favorite.restaurantId === restaurantId,
      )
      const newFavorites = [...localFavorites.favorites]
      const timestamp = new Date()
      let newFavorite = {}

      if (favoriteIndex === -1) {
        // If the favorite isn’t in storage, then create a new entry.
        newFavorite = {
          userId: userId,
          restaurantId: restaurantId,
          favorite: true,
          datetimeUpdated: timestamp,
        }
        newFavorites.push(newFavorite as Favorite)
      } else {
        // Otherwise, if the favorite is in storage, then update the existing entry.
        newFavorite = {
          ...newFavorites[favoriteIndex],
          favorite: !newFavorites[favoriteIndex].favorite,
          datetimeUpdated: timestamp,
        }
        newFavorites[favoriteIndex] = newFavorite as Favorite
      }

      const { data: postRes, error } = await apiRequest&lt;FavoriteResponse&gt;({
        method: &quot;POST&quot;,
        path: &quot;/favorites&quot;,
        body: newFavorite,
      })

      if (!(&quot;_id&quot; in newFavorite) &amp;&amp; postRes &amp;&amp; postRes.data) {
        // Assign the _id property created from the API call to the new favorite.
        newFavorites[newFavorites.length - 1]._id = postRes.data._id
      }

      /*
        Exercise:
          1) Update the `my-favorite` storage item with an object that contains the `newFavorites`.
          2) Update the `localFavorites` state.
          3) Update the `response` state.
      */
    }
  }

  return {
    ...response,
    updateFavorites,
    favorite,
  }
}

</code></pre>
<div line-highlight='9, 46, 81-84, 142, only'></div>
<h3>Fetching favorites when the user signs in</h3>
<p>When the user signs in (thus <code>userId</code> is set), the Hook will fetch all the favorites from Async Storage and the <code>/favorites</code> API:</p>
<pre><code class="language-ts">import { useEffect, useState } from &quot;react&quot;

import { storeData, getData } from &quot;../../storage/storage&quot;
import { apiRequest } from &quot;../api&quot;

interface Favorite {
  userId: string
  restaurantId: string
  favorite: boolean
  datetimeUpdated: Date
  _id?: string
}

interface FavoritesResponse {
  data: Favorite[] | undefined
  error: Error | undefined
  isPending: boolean
}

interface FavoriteResponse {
  data: Favorite | undefined
  error: Error | undefined
  isPending: boolean
}

interface LocalStorageFavorites {
  lastSynced: Date
  favorites: Favorite[]
}

export const useFavorites = (
  userId?: string,
  restaurantId?: string,
): FavoritesResponse &amp; {
  updateFavorites: (restaurantId: Favorite[&quot;restaurantId&quot;]) =&gt; void
  favorite: Favorite | undefined
} =&gt; {
  const [response, setResponse] = useState&lt;FavoritesResponse&gt;({
    data: undefined,
    error: undefined,
    isPending: true,
  })
  const [localFavorites, setLocalFavorites] = useState&lt;
    LocalStorageFavorites | undefined
  &gt;()
  const [favorite, setFavorite] = useState&lt;Favorite | undefined&gt;()

  useEffect(() =&gt; {
    // Gathering favorites from both DB and local storage.
    const fetchData = async () =&gt; {
      const localFavorites = await getData&lt;LocalStorageFavorites&gt;(&quot;my-favorite&quot;)
      setLocalFavorites(
        localFavorites
          ? localFavorites
          : { favorites: [], lastSynced: new Date() },
      )

      const { data, error } = await apiRequest&lt;FavoritesResponse&gt;({
        method: &quot;GET&quot;,
        path: &quot;/favorites&quot;,
        params: {
          userId: userId,
        },
      })

      setResponse({
        data: Array.isArray(data) ? data : data?.data ?? undefined,
        error: error,
        isPending: false,
      })
    }
    if (userId) {
      fetchData()
    }
  }, [userId])

  useEffect(() =&gt; {
    // Finding the restaurant's favorite status.
    if (restaurantId) {
      const getFavorite = async (restaurantId: Favorite[&quot;restaurantId&quot;]) =&gt; {
        const foundFavorite = localFavorites?.favorites.find(
          (favorite) =&gt; favorite.restaurantId === restaurantId,
        )
        setFavorite(foundFavorite)
      }

      getFavorite(restaurantId)
    }
  }, [restaurantId, localFavorites])

  const updateFavorites = async (restaurantId: Favorite[&quot;restaurantId&quot;]) =&gt; {
    if (localFavorites?.favorites) {
      const favoriteIndex = localFavorites.favorites.findIndex(
        (favorite) =&gt; favorite.restaurantId === restaurantId,
      )
      const newFavorites = [...localFavorites.favorites]
      const timestamp = new Date()
      let newFavorite = {}

      if (favoriteIndex === -1) {
        // If the favorite isn’t in storage, then create a new entry.
        newFavorite = {
          userId: userId,
          restaurantId: restaurantId,
          favorite: true,
          datetimeUpdated: timestamp,
        }
        newFavorites.push(newFavorite as Favorite)
      } else {
        // Otherwise, if the favorite is in storage, then update the existing entry.
        newFavorite = {
          ...newFavorites[favoriteIndex],
          favorite: !newFavorites[favoriteIndex].favorite,
          datetimeUpdated: timestamp,
        }
        newFavorites[favoriteIndex] = newFavorite as Favorite
      }

      const { data: postRes, error } = await apiRequest&lt;FavoriteResponse&gt;({
        method: &quot;POST&quot;,
        path: &quot;/favorites&quot;,
        body: newFavorite,
      })

      if (!(&quot;_id&quot; in newFavorite) &amp;&amp; postRes &amp;&amp; postRes.data) {
        // Assign the _id property created from the API call to the new favorite.
        newFavorites[newFavorites.length - 1]._id = postRes.data._id
      }

      /*
        Exercise:
          1) Update the `my-favorite` storage item with an object that contains the `newFavorites`.
          2) Update the `localFavorites` state.
          3) Update the `response` state.
      */
    }
  }

  return {
    ...response,
    updateFavorites,
    favorite,
  }
}

</code></pre>
<div line-highlight='48-75, only'></div>
<h3>Toggling a restaurant’s favorite status</h3>
<p>The Hook returns a <code>updateFavorites</code> function that can be called to toggle whether the restaurant is a favorite or not:</p>
<pre><code class="language-ts">import { useEffect, useState } from &quot;react&quot;

import { storeData, getData } from &quot;../../storage/storage&quot;
import { apiRequest } from &quot;../api&quot;

interface Favorite {
  userId: string
  restaurantId: string
  favorite: boolean
  datetimeUpdated: Date
  _id?: string
}

interface FavoritesResponse {
  data: Favorite[] | undefined
  error: Error | undefined
  isPending: boolean
}

interface FavoriteResponse {
  data: Favorite | undefined
  error: Error | undefined
  isPending: boolean
}

interface LocalStorageFavorites {
  lastSynced: Date
  favorites: Favorite[]
}

export const useFavorites = (
  userId?: string,
  restaurantId?: string,
): FavoritesResponse &amp; {
  updateFavorites: (restaurantId: Favorite[&quot;restaurantId&quot;]) =&gt; void
  favorite: Favorite | undefined
} =&gt; {
  const [response, setResponse] = useState&lt;FavoritesResponse&gt;({
    data: undefined,
    error: undefined,
    isPending: true,
  })
  const [localFavorites, setLocalFavorites] = useState&lt;
    LocalStorageFavorites | undefined
  &gt;()
  const [favorite, setFavorite] = useState&lt;Favorite | undefined&gt;()

  useEffect(() =&gt; {
    // Gathering favorites from both DB and local storage.
    const fetchData = async () =&gt; {
      const localFavorites = await getData&lt;LocalStorageFavorites&gt;(&quot;my-favorite&quot;)
      setLocalFavorites(
        localFavorites
          ? localFavorites
          : { favorites: [], lastSynced: new Date() },
      )

      const { data, error } = await apiRequest&lt;FavoritesResponse&gt;({
        method: &quot;GET&quot;,
        path: &quot;/favorites&quot;,
        params: {
          userId: userId,
        },
      })

      setResponse({
        data: Array.isArray(data) ? data : data?.data ?? undefined,
        error: error,
        isPending: false,
      })
    }
    if (userId) {
      fetchData()
    }
  }, [userId])

  useEffect(() =&gt; {
    // Finding the restaurant's favorite status.
    if (restaurantId) {
      const getFavorite = async (restaurantId: Favorite[&quot;restaurantId&quot;]) =&gt; {
        const foundFavorite = localFavorites?.favorites.find(
          (favorite) =&gt; favorite.restaurantId === restaurantId,
        )
        setFavorite(foundFavorite)
      }

      getFavorite(restaurantId)
    }
  }, [restaurantId, localFavorites])

  const updateFavorites = async (restaurantId: Favorite[&quot;restaurantId&quot;]) =&gt; {
    if (localFavorites?.favorites) {
      const favoriteIndex = localFavorites.favorites.findIndex(
        (favorite) =&gt; favorite.restaurantId === restaurantId,
      )
      const newFavorites = [...localFavorites.favorites]
      const timestamp = new Date()
      let newFavorite = {}

      if (favoriteIndex === -1) {
        // If the favorite isn’t in storage, then create a new entry.
        newFavorite = {
          userId: userId,
          restaurantId: restaurantId,
          favorite: true,
          datetimeUpdated: timestamp,
        }
        newFavorites.push(newFavorite as Favorite)
      } else {
        // Otherwise, if the favorite is in storage, then update the existing entry.
        newFavorite = {
          ...newFavorites[favoriteIndex],
          favorite: !newFavorites[favoriteIndex].favorite,
          datetimeUpdated: timestamp,
        }
        newFavorites[favoriteIndex] = newFavorite as Favorite
      }

      const { data: postRes, error } = await apiRequest&lt;FavoriteResponse&gt;({
        method: &quot;POST&quot;,
        path: &quot;/favorites&quot;,
        body: newFavorite,
      })

      if (!(&quot;_id&quot; in newFavorite) &amp;&amp; postRes &amp;&amp; postRes.data) {
        // Assign the _id property created from the API call to the new favorite.
        newFavorites[newFavorites.length - 1]._id = postRes.data._id
      }

      /*
        Exercise:
          1) Update the `my-favorite` storage item with an object that contains the `newFavorites`.
          2) Update the `localFavorites` state.
          3) Update the `response` state.
      */
    }
  }

  return {
    ...response,
    updateFavorites,
    favorite,
  }
}

</code></pre>
<div line-highlight='91, 101, 105, 110, 113, 141, only'></div>
<h3>Updating the API with the changed favorite status</h3>
<p>The Hook calls the API to update the favorite status for the restaurant:</p>
<pre><code class="language-ts">import { useEffect, useState } from &quot;react&quot;

import { storeData, getData } from &quot;../../storage/storage&quot;
import { apiRequest } from &quot;../api&quot;

interface Favorite {
  userId: string
  restaurantId: string
  favorite: boolean
  datetimeUpdated: Date
  _id?: string
}

interface FavoritesResponse {
  data: Favorite[] | undefined
  error: Error | undefined
  isPending: boolean
}

interface FavoriteResponse {
  data: Favorite | undefined
  error: Error | undefined
  isPending: boolean
}

interface LocalStorageFavorites {
  lastSynced: Date
  favorites: Favorite[]
}

export const useFavorites = (
  userId?: string,
  restaurantId?: string,
): FavoritesResponse &amp; {
  updateFavorites: (restaurantId: Favorite[&quot;restaurantId&quot;]) =&gt; void
  favorite: Favorite | undefined
} =&gt; {
  const [response, setResponse] = useState&lt;FavoritesResponse&gt;({
    data: undefined,
    error: undefined,
    isPending: true,
  })
  const [localFavorites, setLocalFavorites] = useState&lt;
    LocalStorageFavorites | undefined
  &gt;()
  const [favorite, setFavorite] = useState&lt;Favorite | undefined&gt;()

  useEffect(() =&gt; {
    // Gathering favorites from both DB and local storage.
    const fetchData = async () =&gt; {
      const localFavorites = await getData&lt;LocalStorageFavorites&gt;(&quot;my-favorite&quot;)
      setLocalFavorites(
        localFavorites
          ? localFavorites
          : { favorites: [], lastSynced: new Date() },
      )

      const { data, error } = await apiRequest&lt;FavoritesResponse&gt;({
        method: &quot;GET&quot;,
        path: &quot;/favorites&quot;,
        params: {
          userId: userId,
        },
      })

      setResponse({
        data: Array.isArray(data) ? data : data?.data ?? undefined,
        error: error,
        isPending: false,
      })
    }
    if (userId) {
      fetchData()
    }
  }, [userId])

  useEffect(() =&gt; {
    // Finding the restaurant's favorite status.
    if (restaurantId) {
      const getFavorite = async (restaurantId: Favorite[&quot;restaurantId&quot;]) =&gt; {
        const foundFavorite = localFavorites?.favorites.find(
          (favorite) =&gt; favorite.restaurantId === restaurantId,
        )
        setFavorite(foundFavorite)
      }

      getFavorite(restaurantId)
    }
  }, [restaurantId, localFavorites])

  const updateFavorites = async (restaurantId: Favorite[&quot;restaurantId&quot;]) =&gt; {
    if (localFavorites?.favorites) {
      const favoriteIndex = localFavorites.favorites.findIndex(
        (favorite) =&gt; favorite.restaurantId === restaurantId,
      )
      const newFavorites = [...localFavorites.favorites]
      const timestamp = new Date()
      let newFavorite = {}

      if (favoriteIndex === -1) {
        // If the favorite isn’t in storage, then create a new entry.
        newFavorite = {
          userId: userId,
          restaurantId: restaurantId,
          favorite: true,
          datetimeUpdated: timestamp,
        }
        newFavorites.push(newFavorite as Favorite)
      } else {
        // Otherwise, if the favorite is in storage, then update the existing entry.
        newFavorite = {
          ...newFavorites[favoriteIndex],
          favorite: !newFavorites[favoriteIndex].favorite,
          datetimeUpdated: timestamp,
        }
        newFavorites[favoriteIndex] = newFavorite as Favorite
      }

      const { data: postRes, error } = await apiRequest&lt;FavoriteResponse&gt;({
        method: &quot;POST&quot;,
        path: &quot;/favorites&quot;,
        body: newFavorite,
      })

      if (!(&quot;_id&quot; in newFavorite) &amp;&amp; postRes &amp;&amp; postRes.data) {
        // Assign the _id property created from the API call to the new favorite.
        newFavorites[newFavorites.length - 1]._id = postRes.data._id
      }

      /*
        Exercise:
          1) Update the `my-favorite` storage item with an object that contains the `newFavorites`.
          2) Update the `localFavorites` state.
          3) Update the `response` state.
      */
    }
  }

  return {
    ...response,
    updateFavorites,
    favorite,
  }
}

</code></pre>
<div line-highlight='119, 122, 125-128, only'></div>
<p>The API may return an <code>error</code>, and that’s ok!
The Hook can check if the API response was good and store the <code>_id</code> if it was.
If there was an issue with the API call (e.g. the server was down, the device was offline, etc.) then there won’t be an <code>_id</code> in our Async Storage and we’ll know that we need to submit that favorite to the API.</p>
<h3>Setup 2</h3>
<p>✏️ Create <strong>src/services/pmo/favorite/hooks.ts</strong> and update it to be:</p>
<pre><code class="language-ts">import { useEffect, useState } from &quot;react&quot;

import { storeData, getData } from &quot;../../storage/storage&quot;
import { apiRequest } from &quot;../api&quot;

interface Favorite {
  userId: string
  restaurantId: string
  favorite: boolean
  datetimeUpdated: Date
  _id?: string
}

interface FavoritesResponse {
  data: Favorite[] | undefined
  error: Error | undefined
  isPending: boolean
}

interface FavoriteResponse {
  data: Favorite | undefined
  error: Error | undefined
  isPending: boolean
}

interface LocalStorageFavorites {
  lastSynced: Date
  favorites: Favorite[]
}

export const useFavorites = (
  userId?: string,
  restaurantId?: string,
): FavoritesResponse &amp; {
  updateFavorites: (restaurantId: Favorite[&quot;restaurantId&quot;]) =&gt; void
  favorite: Favorite | undefined
} =&gt; {
  const [response, setResponse] = useState&lt;FavoritesResponse&gt;({
    data: undefined,
    error: undefined,
    isPending: true,
  })
  const [localFavorites, setLocalFavorites] = useState&lt;
    LocalStorageFavorites | undefined
  &gt;()
  const [favorite, setFavorite] = useState&lt;Favorite | undefined&gt;()

  useEffect(() =&gt; {
    // Gathering favorites from both DB and local storage.
    const fetchData = async () =&gt; {
      const localFavorites = await getData&lt;LocalStorageFavorites&gt;(&quot;my-favorite&quot;)
      setLocalFavorites(
        localFavorites
          ? localFavorites
          : { favorites: [], lastSynced: new Date() },
      )

      const { data, error } = await apiRequest&lt;FavoritesResponse&gt;({
        method: &quot;GET&quot;,
        path: &quot;/favorites&quot;,
        params: {
          userId: userId,
        },
      })

      setResponse({
        data: Array.isArray(data) ? data : data?.data ?? undefined,
        error: error,
        isPending: false,
      })
    }
    if (userId) {
      fetchData()
    }
  }, [userId])

  useEffect(() =&gt; {
    // Finding the restaurant's favorite status.
    if (restaurantId) {
      const getFavorite = async (restaurantId: Favorite[&quot;restaurantId&quot;]) =&gt; {
        const foundFavorite = localFavorites?.favorites.find(
          (favorite) =&gt; favorite.restaurantId === restaurantId,
        )
        setFavorite(foundFavorite)
      }

      getFavorite(restaurantId)
    }
  }, [restaurantId, localFavorites])

  const updateFavorites = async (restaurantId: Favorite[&quot;restaurantId&quot;]) =&gt; {
    if (localFavorites?.favorites) {
      const favoriteIndex = localFavorites.favorites.findIndex(
        (favorite) =&gt; favorite.restaurantId === restaurantId,
      )
      const newFavorites = [...localFavorites.favorites]
      const timestamp = new Date()
      let newFavorite = {}

      if (favoriteIndex === -1) {
        // If the favorite isn’t in storage, then create a new entry.
        newFavorite = {
          userId: userId,
          restaurantId: restaurantId,
          favorite: true,
          datetimeUpdated: timestamp,
        }
        newFavorites.push(newFavorite as Favorite)
      } else {
        // Otherwise, if the favorite is in storage, then update the existing entry.
        newFavorite = {
          ...newFavorites[favoriteIndex],
          favorite: !newFavorites[favoriteIndex].favorite,
          datetimeUpdated: timestamp,
        }
        newFavorites[favoriteIndex] = newFavorite as Favorite
      }

      const { data: postRes, error } = await apiRequest&lt;FavoriteResponse&gt;({
        method: &quot;POST&quot;,
        path: &quot;/favorites&quot;,
        body: newFavorite,
      })

      if (!(&quot;_id&quot; in newFavorite) &amp;&amp; postRes &amp;&amp; postRes.data) {
        // Assign the _id property created from the API call to the new favorite.
        newFavorites[newFavorites.length - 1]._id = postRes.data._id
      }

      /*
        Exercise:
          1) Update the `my-favorite` storage item with an object that contains the `newFavorites`.
          2) Update the `localFavorites` state.
          3) Update the `response` state.
      */
    }
  }

  return {
    ...response,
    updateFavorites,
    favorite,
  }
}

</code></pre>
<div line-highlight='130-135, only'></div>
<p>✏️ Create <strong>src/services/pmo/favorite/index.ts</strong> and update it to be:</p>
<pre><code class="language-ts">export * from &quot;./hooks&quot;

</code></pre>
<p>✏️ Update <strong>src/screens/RestaurantDetails/RestaurantDetails.tsx</strong> to be:</p>
<pre><code class="language-tsx">import { useNavigation } from &quot;@react-navigation/native&quot;
import { StackScreenProps } from &quot;@react-navigation/stack&quot;
import { useEffect } from &quot;react&quot;

import { RestaurantsStackParamList } from &quot;../../App&quot;
import Loading from &quot;../../components/Loading&quot;
import RestaurantHeader from &quot;../../components/RestaurantHeader&quot;
import Button from &quot;../../design/Button&quot;
import Screen from &quot;../../design/Screen&quot;
import Typography from &quot;../../design/Typography&quot;
import {
  useAuthenticated,
  useUser,
  useAuthentication,
} from &quot;../../services/auth&quot;
import { useFavorites } from &quot;../../services/pmo/favorite/hooks&quot;
import { useRestaurant } from &quot;../../services/pmo/restaurant&quot;

export interface RestaurantDetailsProps
  extends StackScreenProps&lt;RestaurantsStackParamList, &quot;RestaurantDetails&quot;&gt; {}

const RestaurantDetails: React.FC&lt;RestaurantDetailsProps&gt; = ({ route }) =&gt; {
  const { slug } = route.params
  const navigation = useNavigation()
  const { data: restaurant, error, isPending } = useRestaurant({ slug })

  // Exercise: Add a button that uses the `updateFavorites` helper.

  useEffect(() =&gt; {
    if (restaurant) {
      navigation.setOptions({ title: `${restaurant.name}` })
    }
  }, [restaurant, navigation])

  if (error) {
    return (
      &lt;Screen&gt;
        &lt;Typography variant=&quot;heading&quot;&gt;
          Error loading restaurant details:{&quot; &quot;}
        &lt;/Typography&gt;
        &lt;Typography variant=&quot;body&quot;&gt;{error.message}&lt;/Typography&gt;
      &lt;/Screen&gt;
    )
  }

  if (isPending) {
    return &lt;Loading /&gt;
  }

  return (
    &lt;Screen&gt;
      &lt;RestaurantHeader restaurant={restaurant} /&gt;

      &lt;Button
        onPress={() =&gt; {
          navigation.navigate(&quot;RestaurantOrder&quot;, { slug: slug })
        }}
      &gt;
        Place My Order!
      &lt;/Button&gt;
    &lt;/Screen&gt;
  )
}

export default RestaurantDetails

</code></pre>
 <div line-highlight="11-16,27,only"></div>
<h3>Verify 2</h3>
<p>✏️ Create <strong>src/services/pmo/favorite/hooks.test.ts</strong> and update it to be:</p>
<pre><code class="language-ts">import { renderHook, waitFor } from &quot;@testing-library/react-native&quot;

import * as api from &quot;../api/api&quot;

import { useFavorites } from &quot;./hooks&quot;

describe(&quot;Services/PMO/Favorite&quot;, () =&gt; {
  // Mock the apiRequest function
  let apiRequest: jest.SpyInstance&lt;ReturnType&lt;typeof api.apiRequest&gt;&gt;
  beforeEach(() =&gt; {
    jest.resetAllMocks()
    apiRequest = jest.spyOn(api, &quot;apiRequest&quot;)
  })

  describe(&quot;useFavorites&quot;, () =&gt; {
    const mockFavorites = [
      {
        userId: &quot;user-id&quot;,
        restaurantId: &quot;WKQjvzup7QWSFXvH&quot;,
        favorite: false,
        datetimeUpdated: &quot;2024-04-03T14:12:16.314Z&quot;,
        _id: &quot;UslYVUxnBuBwqn0s&quot;,
      },
      {
        userId: &quot;user-id&quot;,
        restaurantId: &quot;7iiKc0akJPYzaMyw&quot;,
        favorite: true,
        datetimeUpdated: &quot;2024-04-02T20:16:18.746Z&quot;,
        _id: &quot;dmTvyAYw3o0xjAIk&quot;,
      },
    ]

    it(&quot;returns favorites from the server&quot;, async () =&gt; {
      apiRequest.mockResolvedValue({
        data: { data: mockFavorites },
        error: undefined,
      })

      const { result } = renderHook(() =&gt; useFavorites(&quot;user-id&quot;))

      await waitFor(() =&gt; {
        expect(result.current.isPending).toBeFalsy()
      })

      expect(result.current.data).toEqual(mockFavorites)
      expect(result.current.error).toBeUndefined()
    })
  })
})

</code></pre>
<div line-highlight='35, only'></div>
<p>✏️ Update <strong>src/screens/RestaurantDetails/RestaurantDetails.test.tsx</strong> to be:</p>
<pre><code class="language-tsx">import { NavigationContainer } from &quot;@react-navigation/native&quot;
import { render, screen } from &quot;@testing-library/react-native&quot;

import AuthProvider from &quot;../../services/auth/AuthProvider&quot;
import * as restaurantHooks from &quot;../../services/pmo/restaurant/hooks&quot;

import RestaurantDetails from &quot;./RestaurantDetails&quot;

const route = {
  key: &quot;RestaurantDetails&quot;,
  name: &quot;RestaurantDetails&quot;,
  params: {
    state: {
      name: &quot;name&quot;,
      short: &quot;short&quot;,
    },
    city: {
      name: &quot;name&quot;,
      state: &quot;state&quot;,
    },
    slug: &quot;test&quot;,
  },
} as const

jest.mock(&quot;@react-navigation/native&quot;, () =&gt; {
  const actualNav = jest.requireActual(&quot;@react-navigation/native&quot;)
  return {
    ...actualNav,
    useNavigation: () =&gt; ({
      navigate: jest.fn(),
      setOptions: jest.fn(),
    }),
  }
})

describe(&quot;Screens/RestaurantDetails&quot;, () =&gt; {
  // Mock the hooks and components used in RestaurantDetails

  let useRestaurant: jest.SpyInstance&lt;
    ReturnType&lt;typeof restaurantHooks.useRestaurant&gt;
  &gt;
  beforeEach(() =&gt; {
    jest.resetAllMocks()
    useRestaurant = jest.spyOn(restaurantHooks, &quot;useRestaurant&quot;)
  })

  const mockRestaurantData = {
    data: {
      _id: &quot;1&quot;,
      name: &quot;Test Restaurant&quot;,
      slug: &quot;test-restaurant&quot;,
      images: {
        banner: &quot;banner.jpg&quot;,
        owner: &quot;owner.jpg&quot;,
        thumbnail: &quot;thumbnail.jpg&quot;,
      },
      menu: {
        dinner: [{ name: &quot;yum&quot;, price: 1 }],
        lunch: [{ name: &quot;snack&quot;, price: 2 }],
      },
      coordinate: { latitude: 0, longitude: 0 },
    },
    isPending: false,
    error: undefined,
  }

  it(&quot;renders&quot;, () =&gt; {
    useRestaurant.mockReturnValue(mockRestaurantData)

    render(
      &lt;NavigationContainer&gt;
        &lt;AuthProvider&gt;
          {/* @ts-ignore */}
          &lt;RestaurantDetails route={route} /&gt;
        &lt;/AuthProvider&gt;
      &lt;/NavigationContainer&gt;,
    )

    expect(screen.getByText(&quot;Test Restaurant&quot;)).toBeOnTheScreen()
  })

  it(&quot;renders before data loads&quot;, () =&gt; {
    useRestaurant.mockReturnValue({ ...mockRestaurantData, data: undefined })
    render(
      &lt;NavigationContainer&gt;
        &lt;AuthProvider&gt;
          {/* @ts-ignore */}
          &lt;RestaurantDetails route={route} /&gt;
        &lt;/AuthProvider&gt;
      &lt;/NavigationContainer&gt;,
    )

    expect(screen.getByText(&quot;&quot;)).toBeOnTheScreen()
  })

  it(&quot;renders loading state&quot;, () =&gt; {
    useRestaurant.mockReturnValue({
      data: undefined,
      isPending: true,
      error: undefined,
    })

    render(
      &lt;NavigationContainer&gt;
        &lt;AuthProvider&gt;
          {/* @ts-ignore */}
          &lt;RestaurantDetails route={route} /&gt;
        &lt;/AuthProvider&gt;
      &lt;/NavigationContainer&gt;,
    )

    expect(screen.getByText(/Loading/i)).toBeOnTheScreen()
  })

  it(&quot;renders error state&quot;, () =&gt; {
    useRestaurant.mockReturnValue({
      data: undefined,
      isPending: false,
      error: { name: &quot;Error&quot;, message: &quot;Mock error&quot; },
    })

    render(
      &lt;NavigationContainer&gt;
        &lt;AuthProvider&gt;
          {/* @ts-ignore */}
          &lt;RestaurantDetails route={route} /&gt;
        &lt;/AuthProvider&gt;
      &lt;/NavigationContainer&gt;,
    )

    expect(
      screen.getByText(/Error loading restaurant details:/i, {
        exact: false,
      }),
    ).toBeOnTheScreen()
    expect(screen.getByText(/Mock error/i)).toBeOnTheScreen()
  })
})

</code></pre>
 <div line-highlight="4,72-75,86-89,93,105-108,124-127,only"></div>
<h3>Exercise 2</h3>
<p>In <code>RestaurantDetails</code>, add a button that uses the <code>updateFavorites</code> helper.</p>
<p>In <code>favorite/hooks.ts</code>, finish the <code>updateFavorites</code> implementation to:</p>
<ul>
<li>Update the <code>my-favorite</code> storage item with an object that contains the <code>newFavorites</code>.</li>
<li>Update the <code>localFavorites</code> state.</li>
<li>Update the <code>response</code> state.</li>
</ul>
<h3>Solution 2</h3>
<p>If you’ve implemented the solution correctly, the tests will pass when you run <code>npm run test</code>!</p>
<p><details>
<summary>Click to see the solution</summary></p>
<p>✏️ Update <strong>src/services/pmo/favorite/hooks.ts</strong> to be:</p>
<pre><code class="language-ts">import { useEffect, useState } from &quot;react&quot;

import { storeData, getData } from &quot;../../storage/storage&quot;
import { apiRequest } from &quot;../api&quot;

interface Favorite {
  userId: string
  restaurantId: string
  favorite: boolean
  datetimeUpdated: Date
  _id?: string
}

interface FavoritesResponse {
  data: Favorite[] | undefined
  error: Error | undefined
  isPending: boolean
}

interface FavoriteResponse {
  data: Favorite | undefined
  error: Error | undefined
  isPending: boolean
}

interface LocalStorageFavorites {
  lastSynced: Date
  favorites: Favorite[]
}

export const useFavorites = (
  userId?: string,
  restaurantId?: string,
): FavoritesResponse &amp; {
  updateFavorites: (restaurantId: Favorite[&quot;restaurantId&quot;]) =&gt; void
  favorite: Favorite | undefined
} =&gt; {
  const [response, setResponse] = useState&lt;FavoritesResponse&gt;({
    data: undefined,
    error: undefined,
    isPending: true,
  })
  const [localFavorites, setLocalFavorites] = useState&lt;
    LocalStorageFavorites | undefined
  &gt;()
  const [favorite, setFavorite] = useState&lt;Favorite | undefined&gt;()

  useEffect(() =&gt; {
    // Gathering favorites from both DB and local storage.
    const fetchData = async () =&gt; {
      const localFavorites = await getData&lt;LocalStorageFavorites&gt;(&quot;my-favorite&quot;)
      setLocalFavorites(
        localFavorites
          ? localFavorites
          : { favorites: [], lastSynced: new Date() },
      )

      const { data, error } = await apiRequest&lt;FavoritesResponse&gt;({
        method: &quot;GET&quot;,
        path: &quot;/favorites&quot;,
        params: {
          userId: userId,
        },
      })

      setResponse({
        data: Array.isArray(data) ? data : data?.data ?? undefined,
        error: error,
        isPending: false,
      })
    }
    if (userId) {
      fetchData()
    }
  }, [userId])

  useEffect(() =&gt; {
    // Finding the restaurant's favorite status.
    if (restaurantId) {
      const getFavorite = async (restaurantId: Favorite[&quot;restaurantId&quot;]) =&gt; {
        const foundFavorite = localFavorites?.favorites.find(
          (favorite) =&gt; favorite.restaurantId === restaurantId,
        )
        setFavorite(foundFavorite)
      }

      getFavorite(restaurantId)
    }
  }, [restaurantId, localFavorites])

  const updateFavorites = async (restaurantId: Favorite[&quot;restaurantId&quot;]) =&gt; {
    if (localFavorites?.favorites) {
      const favoriteIndex = localFavorites.favorites.findIndex(
        (favorite) =&gt; favorite.restaurantId === restaurantId,
      )
      const newFavorites = [...localFavorites.favorites]
      const timestamp = new Date()
      let newFavorite = {}

      if (favoriteIndex === -1) {
        // If the favorite isn’t in storage, then create a new entry.
        newFavorite = {
          userId: userId,
          restaurantId: restaurantId,
          favorite: true,
          datetimeUpdated: timestamp,
        }
        newFavorites.push(newFavorite as Favorite)
      } else {
        // Otherwise, if the favorite is in storage, then update the existing entry.
        newFavorite = {
          ...newFavorites[favoriteIndex],
          favorite: !newFavorites[favoriteIndex].favorite,
          datetimeUpdated: timestamp,
        }
        newFavorites[favoriteIndex] = newFavorite as Favorite
      }

      const { data: postRes, error } = await apiRequest&lt;FavoriteResponse&gt;({
        method: &quot;POST&quot;,
        path: &quot;/favorites&quot;,
        body: newFavorite,
      })

      if (!(&quot;_id&quot; in newFavorite) &amp;&amp; postRes &amp;&amp; postRes.data) {
        // Assign the _id property created from the API call to the new favorite.
        newFavorites[newFavorites.length - 1]._id = postRes.data._id
      }

      const newLocalFavorites = {
        lastSynced: error ? localFavorites.lastSynced : timestamp,
        favorites: newFavorites,
      }

      await storeData&lt;LocalStorageFavorites&gt;(&quot;my-favorite&quot;, newLocalFavorites)
      setLocalFavorites(newLocalFavorites)
      setResponse({ data: newFavorites, error: error, isPending: false })
    }
  }

  return {
    ...response,
    updateFavorites,
    favorite,
  }
}

</code></pre>
 <div line-highlight="130-133,135-137,only"></div>
<p>✏️ Update <strong>src/screens/RestaurantDetails/RestaurantDetails.tsx</strong> to be:</p>
<pre><code class="language-tsx">import { useNavigation } from &quot;@react-navigation/native&quot;
import { StackScreenProps } from &quot;@react-navigation/stack&quot;
import { useEffect } from &quot;react&quot;

import { RestaurantsStackParamList } from &quot;../../App&quot;
import Loading from &quot;../../components/Loading&quot;
import RestaurantHeader from &quot;../../components/RestaurantHeader&quot;
import Button from &quot;../../design/Button&quot;
import Screen from &quot;../../design/Screen&quot;
import Typography from &quot;../../design/Typography&quot;
import {
  useAuthenticated,
  useUser,
  useAuthentication,
} from &quot;../../services/auth&quot;
import { useFavorites } from &quot;../../services/pmo/favorite/hooks&quot;
import { useRestaurant } from &quot;../../services/pmo/restaurant&quot;

export interface RestaurantDetailsProps
  extends StackScreenProps&lt;RestaurantsStackParamList, &quot;RestaurantDetails&quot;&gt; {}

const RestaurantDetails: React.FC&lt;RestaurantDetailsProps&gt; = ({ route }) =&gt; {
  const { slug } = route.params
  const navigation = useNavigation()
  const { data: restaurant, error, isPending } = useRestaurant({ slug })
  const isAuthenticated = useAuthenticated()
  const user = useUser()
  const { signIn } = useAuthentication()
  const { updateFavorites, favorite } = useFavorites(user?.id, restaurant?._id)

  useEffect(() =&gt; {
    if (restaurant) {
      navigation.setOptions({ title: `${restaurant.name}` })
    }
  }, [restaurant, navigation])

  if (error) {
    return (
      &lt;Screen&gt;
        &lt;Typography variant=&quot;heading&quot;&gt;
          Error loading restaurant details:{&quot; &quot;}
        &lt;/Typography&gt;
        &lt;Typography variant=&quot;body&quot;&gt;{error.message}&lt;/Typography&gt;
      &lt;/Screen&gt;
    )
  }

  if (isPending) {
    return &lt;Loading /&gt;
  }

  return (
    &lt;Screen&gt;
      &lt;RestaurantHeader restaurant={restaurant} /&gt;
      &lt;Button
        onPress={() =&gt; {
          if (isAuthenticated) {
            updateFavorites(restaurant!._id)
          } else {
            signIn()
          }
        }}
      &gt;
        {isAuthenticated &amp;&amp; favorite?.favorite
          ? &quot;Remove from favorites&quot;
          : &quot;Add to favorites&quot;}
      &lt;/Button&gt;

      &lt;Button
        onPress={() =&gt; {
          navigation.navigate(&quot;RestaurantOrder&quot;, { slug: slug })
        }}
      &gt;
        Place My Order!
      &lt;/Button&gt;
    &lt;/Screen&gt;
  )
}

export default RestaurantDetails

</code></pre>
 <div line-highlight="26-29,57-61,64-66,69-70,72-73,75,only"></div>
<p></details></p>
<h2>Objective 3: Sync offline data when connectivity changes</h2>
<p>Our app can handle when the API calls fail and it’ll still store the favorites on device in Async Storage.
When the user’s device is offline, we can improve the app a lot by syncing the favorites to the API when the device comes back online.</p>
<h3>Designing the sync behavior</h3>
<p>Here’s an overview of how we want our sync to work.</p>
<p>If a favorite is modified:</p>
<ul>
<li>By another device while our current device is offline, our device should fetch those changes when it comes back online.</li>
<li>On our current device while it’s offline, that change should be synced back to the API as soon as the device comes online.</li>
<li>In both places (in the API and on the device), the data with the last modified date should “win.”</li>
</ul>
<h3>Fetching the favorites modified on the server</h3>
<p>The Hook’s <code>syncWithServer</code> will first fetch the favorites modified on the server:</p>
<pre><code class="language-ts">import { useEffect, useState } from &quot;react&quot;

import { storeData, getData } from &quot;../../storage/storage&quot;
import { apiRequest } from &quot;../api&quot;

interface Favorite {
  userId: string
  restaurantId: string
  favorite: boolean
  datetimeUpdated: Date
  _id?: string
}

interface FavoritesResponse {
  data: Favorite[] | undefined
  error: Error | undefined
  isPending: boolean
}

interface FavoriteResponse {
  data: Favorite | undefined
  error: Error | undefined
  isPending: boolean
}

interface LocalStorageFavorites {
  lastSynced: Date
  favorites: Favorite[]
}

export const useFavorites = (
  userId?: string,
  restaurantId?: string,
): FavoritesResponse &amp; {
  updateFavorites: (restaurantId: Favorite[&quot;restaurantId&quot;]) =&gt; void
  favorite: Favorite | undefined
  syncWithServer: () =&gt; void
  localFavorites: LocalStorageFavorites | undefined
} =&gt; {
  const [response, setResponse] = useState&lt;FavoritesResponse&gt;({
    data: undefined,
    error: undefined,
    isPending: true,
  })
  const [localFavorites, setLocalFavorites] = useState&lt;
    LocalStorageFavorites | undefined
  &gt;()
  const [favorite, setFavorite] = useState&lt;Favorite | undefined&gt;()

  useEffect(() =&gt; {
    // Gathering favorites from both DB and local storage.
    const fetchData = async () =&gt; {
      const localFavorites = await getData&lt;LocalStorageFavorites&gt;(&quot;my-favorite&quot;)
      setLocalFavorites(
        localFavorites
          ? localFavorites
          : { favorites: [], lastSynced: new Date() },
      )

      const { data, error } = await apiRequest&lt;FavoritesResponse&gt;({
        method: &quot;GET&quot;,
        path: &quot;/favorites&quot;,
        params: {
          userId: userId,
        },
      })

      setResponse({
        data: Array.isArray(data) ? data : data?.data ?? undefined,
        error: error,
        isPending: false,
      })
    }
    if (userId) {
      fetchData()
    }
  }, [userId])

  useEffect(() =&gt; {
    // Finding the restaurant's favorite status.
    if (restaurantId) {
      const getFavorite = async (restaurantId: Favorite[&quot;restaurantId&quot;]) =&gt; {
        const foundFavorite = localFavorites?.favorites.find(
          (favorite) =&gt; favorite.restaurantId === restaurantId,
        )
        setFavorite(foundFavorite)
      }

      getFavorite(restaurantId)
    }
  }, [restaurantId, localFavorites])

  const updateFavorites = async (restaurantId: Favorite[&quot;restaurantId&quot;]) =&gt; {
    if (localFavorites?.favorites) {
      const favoriteIndex = localFavorites.favorites.findIndex(
        (favorite) =&gt; favorite.restaurantId === restaurantId,
      )
      const newFavorites = [...localFavorites.favorites]
      const timestamp = new Date()
      let newFavorite = {}

      if (favoriteIndex === -1) {
        // If the favorite isn’t in storage, then create a new entry.
        newFavorite = {
          userId: userId,
          restaurantId: restaurantId,
          favorite: true,
          datetimeUpdated: timestamp,
        }
        newFavorites.push(newFavorite as Favorite)
      } else {
        // Otherwise, if the favorite is in storage, then update the existing entry.
        newFavorite = {
          ...newFavorites[favoriteIndex],
          favorite: !newFavorites[favoriteIndex].favorite,
          datetimeUpdated: timestamp,
        }
        newFavorites[favoriteIndex] = newFavorite as Favorite
      }

      const { data: postRes, error } = await apiRequest&lt;FavoriteResponse&gt;({
        method: &quot;POST&quot;,
        path: &quot;/favorites&quot;,
        body: newFavorite,
      })

      if (!(&quot;_id&quot; in newFavorite) &amp;&amp; postRes &amp;&amp; postRes.data) {
        // Assign the _id property created from the API call to the new favorite.
        newFavorites[newFavorites.length - 1]._id = postRes.data._id
      }

      const newLocalFavorites = {
        lastSynced: error ? localFavorites.lastSynced : timestamp,
        favorites: newFavorites,
      }

      await storeData&lt;LocalStorageFavorites&gt;(&quot;my-favorite&quot;, newLocalFavorites)
      setLocalFavorites(newLocalFavorites)
      setResponse({ data: newFavorites, error: error, isPending: false })
    }
  }

  const syncWithServer = async () =&gt; {
    // Updating the DB with the local data.
    if (localFavorites) {
      const { data: serverData } = await apiRequest&lt;FavoritesResponse&gt;({
        method: &quot;GET&quot;,
        path: &quot;/favorites&quot;,
        params: {
          userId: userId,
          &quot;datetimeUpdated[$gt]&quot;: localFavorites?.lastSynced,
        },
      })

      const newLocalFavorites = {
        lastSynced: new Date(),
        favorites: [...localFavorites.favorites],
      }

      if (serverData?.data) {
        if (serverData.data.length !== 0) {
          serverData.data.forEach((serverFavorite) =&gt; {
            // Looping through the server data and updating it with the local.
            const updateIndex = newLocalFavorites.favorites.findIndex(
              (localFavorite) =&gt; localFavorite._id === serverFavorite._id,
            )
            newLocalFavorites.favorites[updateIndex] = { ...serverFavorite }
          })
        }
        await Promise.all(
          // Calling the server to update the DB.
          newLocalFavorites.favorites.map(async (newLocalFavorite, index) =&gt; {
            if (
              new Date(localFavorites.lastSynced) &lt;
                new Date(newLocalFavorite.datetimeUpdated) &amp;&amp;
              serverData.data?.findIndex(
                (serverFavorite) =&gt; newLocalFavorite._id === serverFavorite._id,
              ) === -1
            ) {
              const { data: postRes, error } =
                await apiRequest&lt;FavoriteResponse&gt;({
                  method: &quot;POST&quot;,
                  path: &quot;/favorites&quot;,
                  body: {
                    ...newLocalFavorite,
                    datetimeUpdated: newLocalFavorites.lastSynced,
                  },
                })
              if (error) {
                newLocalFavorites.lastSynced = localFavorites.lastSynced
              }
              if (postRes &amp;&amp; postRes.data) {
                // Updating local data with any missing _id.
                newLocalFavorites.favorites[index] = { ...postRes.data }
              }
            }
          }),
        )

        await storeData&lt;LocalStorageFavorites&gt;(&quot;my-favorite&quot;, newLocalFavorites)
      }
    }
  }

  return {
    ...response,
    updateFavorites,
    favorite,
    syncWithServer,
    localFavorites,
  }
}

</code></pre>
<div line-highlight='146-153, only'></div>
<p>The code above will fetch the favorites with the <code>datetimeUpdated</code> parameter set to the <code>lastSynced</code> datetime.</p>
<h3>Updating favorites modified on the device</h3>
<p>Next, the Hook will send any favorites that were modified while the device was offline to the API:</p>
<pre><code class="language-ts">import { useEffect, useState } from &quot;react&quot;

import { storeData, getData } from &quot;../../storage/storage&quot;
import { apiRequest } from &quot;../api&quot;

interface Favorite {
  userId: string
  restaurantId: string
  favorite: boolean
  datetimeUpdated: Date
  _id?: string
}

interface FavoritesResponse {
  data: Favorite[] | undefined
  error: Error | undefined
  isPending: boolean
}

interface FavoriteResponse {
  data: Favorite | undefined
  error: Error | undefined
  isPending: boolean
}

interface LocalStorageFavorites {
  lastSynced: Date
  favorites: Favorite[]
}

export const useFavorites = (
  userId?: string,
  restaurantId?: string,
): FavoritesResponse &amp; {
  updateFavorites: (restaurantId: Favorite[&quot;restaurantId&quot;]) =&gt; void
  favorite: Favorite | undefined
  syncWithServer: () =&gt; void
  localFavorites: LocalStorageFavorites | undefined
} =&gt; {
  const [response, setResponse] = useState&lt;FavoritesResponse&gt;({
    data: undefined,
    error: undefined,
    isPending: true,
  })
  const [localFavorites, setLocalFavorites] = useState&lt;
    LocalStorageFavorites | undefined
  &gt;()
  const [favorite, setFavorite] = useState&lt;Favorite | undefined&gt;()

  useEffect(() =&gt; {
    // Gathering favorites from both DB and local storage.
    const fetchData = async () =&gt; {
      const localFavorites = await getData&lt;LocalStorageFavorites&gt;(&quot;my-favorite&quot;)
      setLocalFavorites(
        localFavorites
          ? localFavorites
          : { favorites: [], lastSynced: new Date() },
      )

      const { data, error } = await apiRequest&lt;FavoritesResponse&gt;({
        method: &quot;GET&quot;,
        path: &quot;/favorites&quot;,
        params: {
          userId: userId,
        },
      })

      setResponse({
        data: Array.isArray(data) ? data : data?.data ?? undefined,
        error: error,
        isPending: false,
      })
    }
    if (userId) {
      fetchData()
    }
  }, [userId])

  useEffect(() =&gt; {
    // Finding the restaurant's favorite status.
    if (restaurantId) {
      const getFavorite = async (restaurantId: Favorite[&quot;restaurantId&quot;]) =&gt; {
        const foundFavorite = localFavorites?.favorites.find(
          (favorite) =&gt; favorite.restaurantId === restaurantId,
        )
        setFavorite(foundFavorite)
      }

      getFavorite(restaurantId)
    }
  }, [restaurantId, localFavorites])

  const updateFavorites = async (restaurantId: Favorite[&quot;restaurantId&quot;]) =&gt; {
    if (localFavorites?.favorites) {
      const favoriteIndex = localFavorites.favorites.findIndex(
        (favorite) =&gt; favorite.restaurantId === restaurantId,
      )
      const newFavorites = [...localFavorites.favorites]
      const timestamp = new Date()
      let newFavorite = {}

      if (favoriteIndex === -1) {
        // If the favorite isn’t in storage, then create a new entry.
        newFavorite = {
          userId: userId,
          restaurantId: restaurantId,
          favorite: true,
          datetimeUpdated: timestamp,
        }
        newFavorites.push(newFavorite as Favorite)
      } else {
        // Otherwise, if the favorite is in storage, then update the existing entry.
        newFavorite = {
          ...newFavorites[favoriteIndex],
          favorite: !newFavorites[favoriteIndex].favorite,
          datetimeUpdated: timestamp,
        }
        newFavorites[favoriteIndex] = newFavorite as Favorite
      }

      const { data: postRes, error } = await apiRequest&lt;FavoriteResponse&gt;({
        method: &quot;POST&quot;,
        path: &quot;/favorites&quot;,
        body: newFavorite,
      })

      if (!(&quot;_id&quot; in newFavorite) &amp;&amp; postRes &amp;&amp; postRes.data) {
        // Assign the _id property created from the API call to the new favorite.
        newFavorites[newFavorites.length - 1]._id = postRes.data._id
      }

      const newLocalFavorites = {
        lastSynced: error ? localFavorites.lastSynced : timestamp,
        favorites: newFavorites,
      }

      await storeData&lt;LocalStorageFavorites&gt;(&quot;my-favorite&quot;, newLocalFavorites)
      setLocalFavorites(newLocalFavorites)
      setResponse({ data: newFavorites, error: error, isPending: false })
    }
  }

  const syncWithServer = async () =&gt; {
    // Updating the DB with the local data.
    if (localFavorites) {
      const { data: serverData } = await apiRequest&lt;FavoritesResponse&gt;({
        method: &quot;GET&quot;,
        path: &quot;/favorites&quot;,
        params: {
          userId: userId,
          &quot;datetimeUpdated[$gt]&quot;: localFavorites?.lastSynced,
        },
      })

      const newLocalFavorites = {
        lastSynced: new Date(),
        favorites: [...localFavorites.favorites],
      }

      if (serverData?.data) {
        if (serverData.data.length !== 0) {
          serverData.data.forEach((serverFavorite) =&gt; {
            // Looping through the server data and updating it with the local.
            const updateIndex = newLocalFavorites.favorites.findIndex(
              (localFavorite) =&gt; localFavorite._id === serverFavorite._id,
            )
            newLocalFavorites.favorites[updateIndex] = { ...serverFavorite }
          })
        }
        await Promise.all(
          // Calling the server to update the DB.
          newLocalFavorites.favorites.map(async (newLocalFavorite, index) =&gt; {
            if (
              new Date(localFavorites.lastSynced) &lt;
                new Date(newLocalFavorite.datetimeUpdated) &amp;&amp;
              serverData.data?.findIndex(
                (serverFavorite) =&gt; newLocalFavorite._id === serverFavorite._id,
              ) === -1
            ) {
              const { data: postRes, error } =
                await apiRequest&lt;FavoriteResponse&gt;({
                  method: &quot;POST&quot;,
                  path: &quot;/favorites&quot;,
                  body: {
                    ...newLocalFavorite,
                    datetimeUpdated: newLocalFavorites.lastSynced,
                  },
                })
              if (error) {
                newLocalFavorites.lastSynced = localFavorites.lastSynced
              }
              if (postRes &amp;&amp; postRes.data) {
                // Updating local data with any missing _id.
                newLocalFavorites.favorites[index] = { ...postRes.data }
              }
            }
          }),
        )

        await storeData&lt;LocalStorageFavorites&gt;(&quot;my-favorite&quot;, newLocalFavorites)
      }
    }
  }

  return {
    ...response,
    updateFavorites,
    favorite,
    syncWithServer,
    localFavorites,
  }
}

</code></pre>
<div line-highlight='180-188, only'></div>
<h3>Updating favorites modified on the device</h3>
<p>Last, the Hook will update Async Storage with all the changes that have accumulated through the sync process:</p>
<pre><code class="language-ts">import { useEffect, useState } from &quot;react&quot;

import { storeData, getData } from &quot;../../storage/storage&quot;
import { apiRequest } from &quot;../api&quot;

interface Favorite {
  userId: string
  restaurantId: string
  favorite: boolean
  datetimeUpdated: Date
  _id?: string
}

interface FavoritesResponse {
  data: Favorite[] | undefined
  error: Error | undefined
  isPending: boolean
}

interface FavoriteResponse {
  data: Favorite | undefined
  error: Error | undefined
  isPending: boolean
}

interface LocalStorageFavorites {
  lastSynced: Date
  favorites: Favorite[]
}

export const useFavorites = (
  userId?: string,
  restaurantId?: string,
): FavoritesResponse &amp; {
  updateFavorites: (restaurantId: Favorite[&quot;restaurantId&quot;]) =&gt; void
  favorite: Favorite | undefined
  syncWithServer: () =&gt; void
  localFavorites: LocalStorageFavorites | undefined
} =&gt; {
  const [response, setResponse] = useState&lt;FavoritesResponse&gt;({
    data: undefined,
    error: undefined,
    isPending: true,
  })
  const [localFavorites, setLocalFavorites] = useState&lt;
    LocalStorageFavorites | undefined
  &gt;()
  const [favorite, setFavorite] = useState&lt;Favorite | undefined&gt;()

  useEffect(() =&gt; {
    // Gathering favorites from both DB and local storage.
    const fetchData = async () =&gt; {
      const localFavorites = await getData&lt;LocalStorageFavorites&gt;(&quot;my-favorite&quot;)
      setLocalFavorites(
        localFavorites
          ? localFavorites
          : { favorites: [], lastSynced: new Date() },
      )

      const { data, error } = await apiRequest&lt;FavoritesResponse&gt;({
        method: &quot;GET&quot;,
        path: &quot;/favorites&quot;,
        params: {
          userId: userId,
        },
      })

      setResponse({
        data: Array.isArray(data) ? data : data?.data ?? undefined,
        error: error,
        isPending: false,
      })
    }
    if (userId) {
      fetchData()
    }
  }, [userId])

  useEffect(() =&gt; {
    // Finding the restaurant's favorite status.
    if (restaurantId) {
      const getFavorite = async (restaurantId: Favorite[&quot;restaurantId&quot;]) =&gt; {
        const foundFavorite = localFavorites?.favorites.find(
          (favorite) =&gt; favorite.restaurantId === restaurantId,
        )
        setFavorite(foundFavorite)
      }

      getFavorite(restaurantId)
    }
  }, [restaurantId, localFavorites])

  const updateFavorites = async (restaurantId: Favorite[&quot;restaurantId&quot;]) =&gt; {
    if (localFavorites?.favorites) {
      const favoriteIndex = localFavorites.favorites.findIndex(
        (favorite) =&gt; favorite.restaurantId === restaurantId,
      )
      const newFavorites = [...localFavorites.favorites]
      const timestamp = new Date()
      let newFavorite = {}

      if (favoriteIndex === -1) {
        // If the favorite isn’t in storage, then create a new entry.
        newFavorite = {
          userId: userId,
          restaurantId: restaurantId,
          favorite: true,
          datetimeUpdated: timestamp,
        }
        newFavorites.push(newFavorite as Favorite)
      } else {
        // Otherwise, if the favorite is in storage, then update the existing entry.
        newFavorite = {
          ...newFavorites[favoriteIndex],
          favorite: !newFavorites[favoriteIndex].favorite,
          datetimeUpdated: timestamp,
        }
        newFavorites[favoriteIndex] = newFavorite as Favorite
      }

      const { data: postRes, error } = await apiRequest&lt;FavoriteResponse&gt;({
        method: &quot;POST&quot;,
        path: &quot;/favorites&quot;,
        body: newFavorite,
      })

      if (!(&quot;_id&quot; in newFavorite) &amp;&amp; postRes &amp;&amp; postRes.data) {
        // Assign the _id property created from the API call to the new favorite.
        newFavorites[newFavorites.length - 1]._id = postRes.data._id
      }

      const newLocalFavorites = {
        lastSynced: error ? localFavorites.lastSynced : timestamp,
        favorites: newFavorites,
      }

      await storeData&lt;LocalStorageFavorites&gt;(&quot;my-favorite&quot;, newLocalFavorites)
      setLocalFavorites(newLocalFavorites)
      setResponse({ data: newFavorites, error: error, isPending: false })
    }
  }

  const syncWithServer = async () =&gt; {
    // Updating the DB with the local data.
    if (localFavorites) {
      const { data: serverData } = await apiRequest&lt;FavoritesResponse&gt;({
        method: &quot;GET&quot;,
        path: &quot;/favorites&quot;,
        params: {
          userId: userId,
          &quot;datetimeUpdated[$gt]&quot;: localFavorites?.lastSynced,
        },
      })

      const newLocalFavorites = {
        lastSynced: new Date(),
        favorites: [...localFavorites.favorites],
      }

      if (serverData?.data) {
        if (serverData.data.length !== 0) {
          serverData.data.forEach((serverFavorite) =&gt; {
            // Looping through the server data and updating it with the local.
            const updateIndex = newLocalFavorites.favorites.findIndex(
              (localFavorite) =&gt; localFavorite._id === serverFavorite._id,
            )
            newLocalFavorites.favorites[updateIndex] = { ...serverFavorite }
          })
        }
        await Promise.all(
          // Calling the server to update the DB.
          newLocalFavorites.favorites.map(async (newLocalFavorite, index) =&gt; {
            if (
              new Date(localFavorites.lastSynced) &lt;
                new Date(newLocalFavorite.datetimeUpdated) &amp;&amp;
              serverData.data?.findIndex(
                (serverFavorite) =&gt; newLocalFavorite._id === serverFavorite._id,
              ) === -1
            ) {
              const { data: postRes, error } =
                await apiRequest&lt;FavoriteResponse&gt;({
                  method: &quot;POST&quot;,
                  path: &quot;/favorites&quot;,
                  body: {
                    ...newLocalFavorite,
                    datetimeUpdated: newLocalFavorites.lastSynced,
                  },
                })
              if (error) {
                newLocalFavorites.lastSynced = localFavorites.lastSynced
              }
              if (postRes &amp;&amp; postRes.data) {
                // Updating local data with any missing _id.
                newLocalFavorites.favorites[index] = { ...postRes.data }
              }
            }
          }),
        )

        await storeData&lt;LocalStorageFavorites&gt;(&quot;my-favorite&quot;, newLocalFavorites)
      }
    }
  }

  return {
    ...response,
    updateFavorites,
    favorite,
    syncWithServer,
    localFavorites,
  }
}

</code></pre>
<div line-highlight='200, only'></div>
<h3>Setup 3</h3>
<p>✏️ Update <strong>src/App.tsx</strong> to be:</p>
<pre><code class="language-tsx">import { createBottomTabNavigator } from &quot;@react-navigation/bottom-tabs&quot;
import { NavigationContainer } from &quot;@react-navigation/native&quot;
import { createStackNavigator } from &quot;@react-navigation/stack&quot;
import { Pressable } from &quot;react-native&quot;
import { SafeAreaView } from &quot;react-native-safe-area-context&quot;
import Icon from &quot;react-native-vector-icons/Ionicons&quot;

import Box from &quot;./design/Box&quot;
import ThemeProvider, { useTheme } from &quot;./design/theme/ThemeProvider&quot;
import Typography from &quot;./design/Typography&quot;
import CityList from &quot;./screens/CityList&quot;
import RestaurantDetails from &quot;./screens/RestaurantDetails&quot;
import RestaurantList from &quot;./screens/RestaurantList&quot;
import RestaurantOrder from &quot;./screens/RestaurantOrder&quot;
import Settings from &quot;./screens/Settings&quot;
import StateList from &quot;./screens/StateList&quot;
import AuthProvider from &quot;./services/auth/AuthProvider&quot;
import DataMigration from &quot;./services/DataMigration&quot;
import FavoritesSync from &quot;./services/pmo/favorite&quot;

declare global {
  // eslint-disable-next-line @typescript-eslint/no-namespace
  namespace ReactNavigation {
    // eslint-disable-next-line @typescript-eslint/no-empty-interface
    interface RootParamList extends RestaurantsStackParamList {}
  }
}

export type RestaurantsStackParamList = {
  StateList: undefined
  CityList: {
    state: {
      name: string
      short: string
    }
  }
  RestaurantList: {
    state: {
      name: string
      short: string
    }
    city: {
      name: string
      state: string
    }
  }
  RestaurantDetails: {
    slug: string
  }
  RestaurantOrder: {
    slug: string
  }
}

const RestaurantsStack = createStackNavigator&lt;RestaurantsStackParamList&gt;()
const RestaurantsNavigator: React.FC = () =&gt; {
  return (
    &lt;RestaurantsStack.Navigator
      initialRouteName=&quot;StateList&quot;
      screenOptions={{
        header: ({ route, navigation }) =&gt; {
          if (!navigation.canGoBack()) return null

          return (
            &lt;Pressable onPress={navigation.goBack}&gt;
              &lt;Box
                padding=&quot;m&quot;
                style={{ flexDirection: &quot;row&quot;, gap: 8, alignItems: &quot;center&quot; }}
              &gt;
                &lt;Icon name=&quot;arrow-back&quot; size={20} /&gt;
                &lt;Typography variant=&quot;heading&quot;&gt;
                  {/* @ts-ignore */}
                  {[route.params?.city?.name, route.params?.state?.name]
                    .filter(Boolean)
                    .join(&quot;, &quot;)}
                &lt;/Typography&gt;
              &lt;/Box&gt;
            &lt;/Pressable&gt;
          )
        },
      }}
    &gt;
      &lt;RestaurantsStack.Screen name=&quot;StateList&quot; component={StateList} /&gt;
      &lt;RestaurantsStack.Screen name=&quot;CityList&quot; component={CityList} /&gt;
      &lt;RestaurantsStack.Screen
        name=&quot;RestaurantList&quot;
        component={RestaurantList}
      /&gt;
      &lt;RestaurantsStack.Screen
        name=&quot;RestaurantDetails&quot;
        component={RestaurantDetails}
      /&gt;
      &lt;RestaurantsStack.Screen
        name=&quot;RestaurantOrder&quot;
        component={RestaurantOrder}
      /&gt;
    &lt;/RestaurantsStack.Navigator&gt;
  )
}

const AppTabs = createBottomTabNavigator()
const AppNavigator: React.FC = () =&gt; {
  const theme = useTheme()

  return (
    &lt;AppTabs.Navigator
      initialRouteName=&quot;RestaurantsStack&quot;
      screenOptions={({ route }) =&gt; ({
        headerStyle: {
          backgroundColor: theme.palette.screen.main,
        },
        headerTitleStyle: {
          color: theme.palette.screen.contrast,
          ...theme.typography.title,
        },
        tabBarStyle: {
          backgroundColor: theme.palette.screen.main,
        },
        tabBarActiveTintColor: theme.palette.primary.strong,
        tabBarInactiveTintColor: theme.palette.screen.contrast,
        tabBarIcon: ({ focused, color }) =&gt; {
          let icon = &quot;settings&quot;
          if (route.name === &quot;Settings&quot;) {
            icon = focused ? &quot;settings&quot; : &quot;settings-outline&quot;
          } else if (route.name === &quot;Restaurants&quot;) {
            icon = focused ? &quot;restaurant&quot; : &quot;restaurant-outline&quot;
          }

          return &lt;Icon name={icon} size={20} color={color} /&gt;
        },
      })}
    &gt;
      &lt;AppTabs.Screen
        name=&quot;Restaurants&quot;
        component={RestaurantsNavigator}
        options={{ title: &quot;Place My Order&quot; }}
      /&gt;
      &lt;AppTabs.Screen
        name=&quot;Settings&quot;
        component={Settings}
        options={{ title: &quot;Settings&quot; }}
      /&gt;
    &lt;/AppTabs.Navigator&gt;
  )
}

// Exercise: Add the `FavoritesSync` component to the `App` JSX.
const App: React.FC = () =&gt; {
  return (
    &lt;SafeAreaView style={{ flex: 1 }}&gt;
      &lt;ThemeProvider&gt;
        &lt;AuthProvider&gt;
          &lt;DataMigration&gt;
            &lt;NavigationContainer&gt;
              &lt;AppNavigator /&gt;
            &lt;/NavigationContainer&gt;
          &lt;/DataMigration&gt;
        &lt;/AuthProvider&gt;
      &lt;/ThemeProvider&gt;
    &lt;/SafeAreaView&gt;
  )
}

export default App

</code></pre>
 <div line-highlight="19,147,only"></div>
<p>✏️ Update <strong>src/services/pmo/favorite/hooks.ts</strong> to be:</p>
<pre><code class="language-ts">import { useEffect, useState } from &quot;react&quot;

import { storeData, getData } from &quot;../../storage/storage&quot;
import { apiRequest } from &quot;../api&quot;

interface Favorite {
  userId: string
  restaurantId: string
  favorite: boolean
  datetimeUpdated: Date
  _id?: string
}

interface FavoritesResponse {
  data: Favorite[] | undefined
  error: Error | undefined
  isPending: boolean
}

interface FavoriteResponse {
  data: Favorite | undefined
  error: Error | undefined
  isPending: boolean
}

interface LocalStorageFavorites {
  lastSynced: Date
  favorites: Favorite[]
}

export const useFavorites = (
  userId?: string,
  restaurantId?: string,
): FavoritesResponse &amp; {
  updateFavorites: (restaurantId: Favorite[&quot;restaurantId&quot;]) =&gt; void
  favorite: Favorite | undefined
  syncWithServer: () =&gt; void
  localFavorites: LocalStorageFavorites | undefined
} =&gt; {
  const [response, setResponse] = useState&lt;FavoritesResponse&gt;({
    data: undefined,
    error: undefined,
    isPending: true,
  })
  const [localFavorites, setLocalFavorites] = useState&lt;
    LocalStorageFavorites | undefined
  &gt;()
  const [favorite, setFavorite] = useState&lt;Favorite | undefined&gt;()

  useEffect(() =&gt; {
    // Gathering favorites from both DB and local storage.
    const fetchData = async () =&gt; {
      const localFavorites = await getData&lt;LocalStorageFavorites&gt;(&quot;my-favorite&quot;)
      setLocalFavorites(
        localFavorites
          ? localFavorites
          : { favorites: [], lastSynced: new Date() },
      )

      const { data, error } = await apiRequest&lt;FavoritesResponse&gt;({
        method: &quot;GET&quot;,
        path: &quot;/favorites&quot;,
        params: {
          userId: userId,
        },
      })

      setResponse({
        data: Array.isArray(data) ? data : data?.data ?? undefined,
        error: error,
        isPending: false,
      })
    }
    if (userId) {
      fetchData()
    }
  }, [userId])

  useEffect(() =&gt; {
    // Finding the restaurant's favorite status.
    if (restaurantId) {
      const getFavorite = async (restaurantId: Favorite[&quot;restaurantId&quot;]) =&gt; {
        const foundFavorite = localFavorites?.favorites.find(
          (favorite) =&gt; favorite.restaurantId === restaurantId,
        )
        setFavorite(foundFavorite)
      }

      getFavorite(restaurantId)
    }
  }, [restaurantId, localFavorites])

  const updateFavorites = async (restaurantId: Favorite[&quot;restaurantId&quot;]) =&gt; {
    if (localFavorites?.favorites) {
      const favoriteIndex = localFavorites.favorites.findIndex(
        (favorite) =&gt; favorite.restaurantId === restaurantId,
      )
      const newFavorites = [...localFavorites.favorites]
      const timestamp = new Date()
      let newFavorite = {}

      if (favoriteIndex === -1) {
        // If the favorite isn’t in storage, then create a new entry.
        newFavorite = {
          userId: userId,
          restaurantId: restaurantId,
          favorite: true,
          datetimeUpdated: timestamp,
        }
        newFavorites.push(newFavorite as Favorite)
      } else {
        // Otherwise, if the favorite is in storage, then update the existing entry.
        newFavorite = {
          ...newFavorites[favoriteIndex],
          favorite: !newFavorites[favoriteIndex].favorite,
          datetimeUpdated: timestamp,
        }
        newFavorites[favoriteIndex] = newFavorite as Favorite
      }

      const { data: postRes, error } = await apiRequest&lt;FavoriteResponse&gt;({
        method: &quot;POST&quot;,
        path: &quot;/favorites&quot;,
        body: newFavorite,
      })

      if (!(&quot;_id&quot; in newFavorite) &amp;&amp; postRes &amp;&amp; postRes.data) {
        // Assign the _id property created from the API call to the new favorite.
        newFavorites[newFavorites.length - 1]._id = postRes.data._id
      }

      const newLocalFavorites = {
        lastSynced: error ? localFavorites.lastSynced : timestamp,
        favorites: newFavorites,
      }

      await storeData&lt;LocalStorageFavorites&gt;(&quot;my-favorite&quot;, newLocalFavorites)
      setLocalFavorites(newLocalFavorites)
      setResponse({ data: newFavorites, error: error, isPending: false })
    }
  }

  const syncWithServer = async () =&gt; {
    // Updating the DB with the local data.
    if (localFavorites) {
      const { data: serverData } = await apiRequest&lt;FavoritesResponse&gt;({
        method: &quot;GET&quot;,
        path: &quot;/favorites&quot;,
        params: {
          userId: userId,
          &quot;datetimeUpdated[$gt]&quot;: localFavorites?.lastSynced,
        },
      })

      const newLocalFavorites = {
        lastSynced: new Date(),
        favorites: [...localFavorites.favorites],
      }

      if (serverData?.data) {
        if (serverData.data.length !== 0) {
          serverData.data.forEach((serverFavorite) =&gt; {
            // Looping through the server data and updating it with the local.
            const updateIndex = newLocalFavorites.favorites.findIndex(
              (localFavorite) =&gt; localFavorite._id === serverFavorite._id,
            )
            newLocalFavorites.favorites[updateIndex] = { ...serverFavorite }
          })
        }
        await Promise.all(
          // Calling the server to update the DB.
          newLocalFavorites.favorites.map(async (newLocalFavorite, index) =&gt; {
            if (
              new Date(localFavorites.lastSynced) &lt;
                new Date(newLocalFavorite.datetimeUpdated) &amp;&amp;
              serverData.data?.findIndex(
                (serverFavorite) =&gt; newLocalFavorite._id === serverFavorite._id,
              ) === -1
            ) {
              const { data: postRes, error } =
                await apiRequest&lt;FavoriteResponse&gt;({
                  method: &quot;POST&quot;,
                  path: &quot;/favorites&quot;,
                  body: {
                    ...newLocalFavorite,
                    datetimeUpdated: newLocalFavorites.lastSynced,
                  },
                })
              if (error) {
                newLocalFavorites.lastSynced = localFavorites.lastSynced
              }
              if (postRes &amp;&amp; postRes.data) {
                // Updating local data with any missing _id.
                newLocalFavorites.favorites[index] = { ...postRes.data }
              }
            }
          }),
        )

        await storeData&lt;LocalStorageFavorites&gt;(&quot;my-favorite&quot;, newLocalFavorites)
      }
    }
  }

  return {
    ...response,
    updateFavorites,
    favorite,
    syncWithServer,
    localFavorites,
  }
}

</code></pre>
 <div line-highlight="37-38,143-153,155-158,160-198,200-202,209-211,only"></div>
<p>✏️ Create <strong>src/services/pmo/favorite/favorite.tsx</strong> and update it to be:</p>
<pre><code class="language-tsx">import { useNetInfo } from &quot;@react-native-community/netinfo&quot;
import { useEffect } from &quot;react&quot;

import { useUser } from &quot;../../auth&quot;

import { useFavorites } from &quot;./hooks&quot;

export const useFavoritesSync = (): void =&gt; {
  // Exercise: When the user is signed in and has a network connection, sync with the server.

  return
}

const FavoritesSync: React.FC = () =&gt; {
  useFavoritesSync()

  return null
}

export default FavoritesSync

</code></pre>
<p>✏️ Update <strong>src/services/pmo/favorite/index.ts</strong> to be:</p>
<pre><code class="language-ts">export { default } from &quot;./favorite&quot;
export * from &quot;./hooks&quot;

</code></pre>
 <div line-highlight="1,only"></div>
<h3>Verify 3</h3>
<p>✏️ Update <strong>src/services/pmo/favorite/hooks.test.ts</strong> to be:</p>
<pre><code class="language-ts">import { renderHook, waitFor } from &quot;@testing-library/react-native&quot;

import * as storage from &quot;../../storage/storage&quot;
import * as api from &quot;../api/api&quot;

import { useFavorites } from &quot;./hooks&quot;

describe(&quot;Services/PMO/Favorite&quot;, () =&gt; {
  // Mock the apiRequest function
  let apiRequest: jest.SpyInstance&lt;ReturnType&lt;typeof api.apiRequest&gt;&gt;
  let mockStorage: jest.SpyInstance&lt;ReturnType&lt;typeof storage.getData&gt;&gt;
  beforeEach(() =&gt; {
    jest.resetAllMocks()
    apiRequest = jest.spyOn(api, &quot;apiRequest&quot;)
    mockStorage = jest.spyOn(storage, &quot;getData&quot;)
  })

  describe(&quot;useFavorites&quot;, () =&gt; {
    const mockFavorites = [
      {
        userId: &quot;user-id&quot;,
        restaurantId: &quot;WKQjvzup7QWSFXvH&quot;,
        favorite: false,
        datetimeUpdated: &quot;2024-04-03T14:12:16.314Z&quot;,
        _id: &quot;UslYVUxnBuBwqn0s&quot;,
      },
      {
        userId: &quot;user-id&quot;,
        restaurantId: &quot;7iiKc0akJPYzaMyw&quot;,
        favorite: true,
        datetimeUpdated: &quot;2024-04-02T20:16:18.746Z&quot;,
        _id: &quot;dmTvyAYw3o0xjAIk&quot;,
      },
    ]

    it(&quot;returns favorites from the server&quot;, async () =&gt; {
      apiRequest.mockResolvedValue({
        data: { data: mockFavorites },
        error: undefined,
      })

      const { result } = renderHook(() =&gt; useFavorites(&quot;user-id&quot;))

      await waitFor(() =&gt; {
        expect(result.current.isPending).toBeFalsy()
      })

      expect(result.current.data).toEqual(mockFavorites)
      expect(result.current.error).toBeUndefined()
    })

    it(&quot;returns favorites from storage&quot;, async () =&gt; {
      const mockLocalFavorites = {
        lastSynced: &quot;Date&quot;,
        favorites: mockFavorites,
      }
      apiRequest.mockResolvedValue({
        data: { data: mockFavorites },
        error: undefined,
      })
      mockStorage.mockResolvedValue(mockLocalFavorites)

      const { result } = renderHook(() =&gt; useFavorites(&quot;user-id&quot;))

      await waitFor(() =&gt; {
        expect(result.current.localFavorites).toBeTruthy()
      })

      expect(result.current.localFavorites).toEqual(mockLocalFavorites)
    })
  })
})

</code></pre>
 <div line-highlight="3,11,15,52-61,63,65-67,69-70,only"></div>
<h3>Exercise 3</h3>
<ul>
<li>Create a <code>FavoritesSync</code> component that does the following:
<ul>
<li>When the user is signed in and has a network connection, sync with the server.</li>
</ul></li>
<li>Add the <code>FavoritesSync</code> component to the <code>App</code> JSX.</li>
</ul>
<p><strong>Hint:</strong> Use all of the imports provided in the <code>favorite.tsx</code> file.</p>
<h3>Solution 3</h3>
<p>If you’ve implemented the solution correctly, the tests will pass when you run <code>npm run test</code>!</p>
<p><details>
<summary>Click to see the solution</summary></p>
<p>✏️ Update <strong>src/services/pmo/favorite/favorite.tsx</strong> to be:</p>
<pre><code class="language-tsx">import { useNetInfo } from &quot;@react-native-community/netinfo&quot;
import { useEffect } from &quot;react&quot;

import { useUser } from &quot;../../auth&quot;

import { useFavorites } from &quot;./hooks&quot;

const useFavoritesSync = (): void =&gt; {
  const user = useUser()
  const { isConnected } = useNetInfo()
  const { syncWithServer, localFavorites } = useFavorites(user?.id)

  useEffect(() =&gt; {
    if (user &amp;&amp; isConnected &amp;&amp; localFavorites) {
      syncWithServer()
    }
  }, [isConnected, localFavorites, syncWithServer, user])

  return
}

const FavoritesSync: React.FC = () =&gt; {
  useFavoritesSync()

  return null
}

export default FavoritesSync

</code></pre>
 <div line-highlight="8-11,13-17,only"></div>
<p>✏️ Update <strong>src/App.tsx</strong> to be:</p>
<pre><code class="language-tsx">import { createBottomTabNavigator } from &quot;@react-navigation/bottom-tabs&quot;
import { NavigationContainer } from &quot;@react-navigation/native&quot;
import { createStackNavigator } from &quot;@react-navigation/stack&quot;
import { Pressable } from &quot;react-native&quot;
import { SafeAreaView } from &quot;react-native-safe-area-context&quot;
import Icon from &quot;react-native-vector-icons/Ionicons&quot;

import Box from &quot;./design/Box&quot;
import ThemeProvider, { useTheme } from &quot;./design/theme/ThemeProvider&quot;
import Typography from &quot;./design/Typography&quot;
import CityList from &quot;./screens/CityList&quot;
import RestaurantDetails from &quot;./screens/RestaurantDetails&quot;
import RestaurantList from &quot;./screens/RestaurantList&quot;
import RestaurantOrder from &quot;./screens/RestaurantOrder&quot;
import Settings from &quot;./screens/Settings&quot;
import StateList from &quot;./screens/StateList&quot;
import AuthProvider from &quot;./services/auth/AuthProvider&quot;
import DataMigration from &quot;./services/DataMigration&quot;
import FavoritesSync from &quot;./services/pmo/favorite&quot;

declare global {
  // eslint-disable-next-line @typescript-eslint/no-namespace
  namespace ReactNavigation {
    // eslint-disable-next-line @typescript-eslint/no-empty-interface
    interface RootParamList extends RestaurantsStackParamList {}
  }
}

export type RestaurantsStackParamList = {
  StateList: undefined
  CityList: {
    state: {
      name: string
      short: string
    }
  }
  RestaurantList: {
    state: {
      name: string
      short: string
    }
    city: {
      name: string
      state: string
    }
  }
  RestaurantDetails: {
    slug: string
  }
  RestaurantOrder: {
    slug: string
  }
}

const RestaurantsStack = createStackNavigator&lt;RestaurantsStackParamList&gt;()
const RestaurantsNavigator: React.FC = () =&gt; {
  return (
    &lt;RestaurantsStack.Navigator
      initialRouteName=&quot;StateList&quot;
      screenOptions={{
        header: ({ route, navigation }) =&gt; {
          if (!navigation.canGoBack()) return null

          return (
            &lt;Pressable onPress={navigation.goBack}&gt;
              &lt;Box
                padding=&quot;m&quot;
                style={{ flexDirection: &quot;row&quot;, gap: 8, alignItems: &quot;center&quot; }}
              &gt;
                &lt;Icon name=&quot;arrow-back&quot; size={20} /&gt;
                &lt;Typography variant=&quot;heading&quot;&gt;
                  {/* @ts-ignore */}
                  {[route.params?.city?.name, route.params?.state?.name]
                    .filter(Boolean)
                    .join(&quot;, &quot;)}
                &lt;/Typography&gt;
              &lt;/Box&gt;
            &lt;/Pressable&gt;
          )
        },
      }}
    &gt;
      &lt;RestaurantsStack.Screen name=&quot;StateList&quot; component={StateList} /&gt;
      &lt;RestaurantsStack.Screen name=&quot;CityList&quot; component={CityList} /&gt;
      &lt;RestaurantsStack.Screen
        name=&quot;RestaurantList&quot;
        component={RestaurantList}
      /&gt;
      &lt;RestaurantsStack.Screen
        name=&quot;RestaurantDetails&quot;
        component={RestaurantDetails}
      /&gt;
      &lt;RestaurantsStack.Screen
        name=&quot;RestaurantOrder&quot;
        component={RestaurantOrder}
      /&gt;
    &lt;/RestaurantsStack.Navigator&gt;
  )
}

const AppTabs = createBottomTabNavigator()
const AppNavigator: React.FC = () =&gt; {
  const theme = useTheme()

  return (
    &lt;AppTabs.Navigator
      initialRouteName=&quot;RestaurantsStack&quot;
      screenOptions={({ route }) =&gt; ({
        headerStyle: {
          backgroundColor: theme.palette.screen.main,
        },
        headerTitleStyle: {
          color: theme.palette.screen.contrast,
          ...theme.typography.title,
        },
        tabBarStyle: {
          backgroundColor: theme.palette.screen.main,
        },
        tabBarActiveTintColor: theme.palette.primary.strong,
        tabBarInactiveTintColor: theme.palette.screen.contrast,
        tabBarIcon: ({ focused, color }) =&gt; {
          let icon = &quot;settings&quot;
          if (route.name === &quot;Settings&quot;) {
            icon = focused ? &quot;settings&quot; : &quot;settings-outline&quot;
          } else if (route.name === &quot;Restaurants&quot;) {
            icon = focused ? &quot;restaurant&quot; : &quot;restaurant-outline&quot;
          }

          return &lt;Icon name={icon} size={20} color={color} /&gt;
        },
      })}
    &gt;
      &lt;AppTabs.Screen
        name=&quot;Restaurants&quot;
        component={RestaurantsNavigator}
        options={{ title: &quot;Place My Order&quot; }}
      /&gt;
      &lt;AppTabs.Screen
        name=&quot;Settings&quot;
        component={Settings}
        options={{ title: &quot;Settings&quot; }}
      /&gt;
    &lt;/AppTabs.Navigator&gt;
  )
}

const App: React.FC = () =&gt; {
  return (
    &lt;SafeAreaView style={{ flex: 1 }}&gt;
      &lt;ThemeProvider&gt;
        &lt;AuthProvider&gt;
          &lt;DataMigration&gt;
            &lt;NavigationContainer&gt;
              &lt;AppNavigator /&gt;
            &lt;/NavigationContainer&gt;
            &lt;FavoritesSync /&gt;
          &lt;/DataMigration&gt;
        &lt;/AuthProvider&gt;
      &lt;/ThemeProvider&gt;
    &lt;/SafeAreaView&gt;
  )
}

export default App

</code></pre>
 <div line-highlight="156,only"></div>
<p></details></p>
<h2>Next steps</h2>
<p>Next, we will learn about <a href="google-maps.html" title="Learn how to integrate Google Maps into your React Native application.">Integrating Maps</a> to our application.</p>

</section>

  			
  			<bit-prev-next class="footer" list-selector=".sidebar-left ul li.parent.expanded ul"></bit-prev-next>
  		
    </div>

    
      <div class="sidebar-right">
        <div class="content-nav on-this-page-container">
          <h6>On this page...</h6>
          <div class="list-items" id="scroll-toc">
            <bit-toc heading-container-selector="article.main" scroll-selector="#scroll-toc"></bit-toc>
          </div>
        </div>
        <div class="pullout discord">
          <h6>Get help</h6>
          <p>If you need <a href="https://discord.gg/J7ejFsZnJ4">help</a> with an exercise, please reach out to us on
             <a href="https://discord.gg/J7ejFsZnJ4">Discord</a></p>
        </div>
        <div class="pullout bug">
          <p>If you find a bug, please
             <a href="https://github.com/bitovi/academy/issues/new">create an issue</a> or email
             <a href="mailto:contact@bitovi.com?Subject=Training%20Suggestion" target="_blank">contact@bitovi.com</a></p>
        </div>
      </div>
    

	</article>
</div>



  <footer></footer>

  <div id="scripts">
    <script type="text/javascript">
      var docObject = {"src":{"path":"src/react-native/17-offline-support/offline-support.md"},"description":"Learn device-first strategies for storing data and syncing it to a server. \n","name":"learn-react-native/offline-support","title":"Adding Offline Support","type":"page","parent":"learn-react-native","order":17,"outline":{"depth":3},"comment":" ","pathToRoot":"../.."};
    </script>

    
      <script>
        steal = {
          instantiated: {
            "bundles/bit-docs-site/static.css!$css" : null
          }
        }
      </script>
      <script type='text/javascript'
          data-main="bit-docs-site/static"
          src="../static/steal.production.js"></script>
    

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-2302003-12"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-2302003-12');
    </script>

  </div>
  <div id="email-modal" role="dialog" aria-modal="true" aria-labelledby="dialog_label" style="display: none;">
    <div aria-hidden="true" class="email-modal-backdrop"></div>
    <div role="region" class="email-modal-content">
      <h2 id="dialog_label">Join the Bitovi Newsletter</h2>
      <p>
        Do you want to receive updates about new Bitovi Academy courses, Bitovi open source projects, and dev community news? If so, please provide your email. We won’t spam you or give it away for any reason!<br />
        <i style="font-size: 0.8rem;">By providing your email you agree to receive communications from Bitovi</i>
      </p>
      <div id="academy-hubspot-form-embed"></div>
      <script charset="utf-8" type="text/javascript" src="//js.hsforms.net/forms/embed/v2.js"></script>
      <button id="email-modal-close" title="dismiss"><img src="../static/img/close.svg" height="24" width="24"></button>
    </div>
  </div>
</body>
</html>

<!DOCTYPE html>
<!--####################################################################
	THIS IS A GENERATED FILE — ANY CHANGES MADE WILL BE OVERWRITTEN

	INSTEAD CHANGE:
	source: src/react-native/17-offline-support/offline-support.md
	@page learn-react-native/offline-support
######################################################################## -->
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="google-site-verification" content="UMCgjrWAjJW_tHmYo6AerdZvVdmh8QHdY9Ywb59tpHw" />
  <meta name="description" content="Learn device-first strategies for storing data and syncing it to a server. 
">
  
  <!-- Google Tag Manager -->
  <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-P9MQVJS');</script>
  <!-- End Google Tag Manager -->

  <title>Bitovi Academy - Adding Offline Support</title>
  
  <link rel="stylesheet" type="text/css" href="../static/bundles/bit-docs-site/static.css">
  
</head>

<body>
  <!-- Google Tag Manager (noscript) -->
  <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-P9MQVJS"
  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  <!-- End Google Tag Manager (noscript) -->
  
  <div class="header">
    <div class="logo">
      <a href="https://www.bitovi.com/">Bitovi</a>
    </div>
    <ul>
      <li><a href="https://www.bitovi.com/services">Services</a></li>
      <li><a href="https://www.bitovi.com/client-work">Client Work</a></li>
      <li><a href="https://www.bitovi.com/about">Our Team</a></li>
      <li><a href="https://www.bitovi.com/open-source">Open Source</a></li>
      <li><a href="https://www.bitovi.com/blog">Blog</a></li>
      <li><a href=".." class="active">Academy</a></li>
     </ul>
     <a class="contact-popup hs-button brand button-smallest" href="https://www.bitovi.com/contact">Contact Us</a>
  </div>

  <div class="content">
	
		<div class="sidebar-left">
  
    
	<ul>
		
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-advanced-javascript.html"
							title="This course covers all the hard but important stuff you should know when learning JavaScript.">
							Advanced JavaScript
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-dom-jquery.html"
							title="Learn jQuery and the DOM APIs by building your own version of jQuery and using it to make a basic tabs widget. We strongly suggest finishing learn-advanced-javascript prior to starting this course.">
							DOM and jQuery
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-to-debug-javascript.html"
							title="This course covers the basics of JavaScript debugging.">
							Debug JavaScript
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-typescript.html"
							title="This course covers the basic essentials of TypeScript. At the end, you should be ready to develop projects in TypeScript.">
							Learn TypeScript
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						parent
           						expanded">
						<a class="page"
							href="../learn-react-native.html"
							title="Learn React Native by building the feature-rich Place My Order application in this beginner React Native guide. This hands-on course will introduce you to fundamental React Native concepts! By the end of this course, you will have a strong understanding of JSX, function components, styling, state management, Hooks, data fetching, routing, and testing.">
							Learn React Native
						</a>
						
							
	<ul>
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="intro-to-react-native.html"
							title="Discover why React Native is a great choice for modern mobile application development.">
							Introduction to React Native
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="setting-up-your-environment.html"
							title="Learn how to set up your environment for React Native development.">
							Setting Up Your Environment
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="creating-a-new-app.html"
							title="Generate a new React Native application using the CLI.">
							Creating a New Application
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="intro-to-jsx.html"
							title="Learn how to use JSX to define your UI in React Native.">
							Introduction to JSX
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="intro-to-testing.html"
							title="Learn about testing solutions in React Native.">
							Introduction to Testing
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="building-custom-components.html"
							title="Learn about components, the core building blocks of every React application.">
							Building Custom Components
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="debugging-devtools.html"
							title="Learn how to set up and use both DevTools and Debugger.">
							Debugging and DevTools
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="styling.html"
							title="Learn how to use the style prop and the StyleSheet API in React Native.">
							Styling in React Native
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="react-context.html"
							title="Learn how to share a common theme by creating a React Context.">
							Using React Context
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="managing-state.html"
							title="Work with React’s useState Hook to manage a component’s state.">
							Managing State with useState
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="navigation.html"
							title="Learn how to use navigation to move between screens in a React Native app.">
							Navigation in React Native
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="navigation-params.html"
							title="Maintain the React state with React Native Navigation Parameters">
							Storing State in Navigation Parameters
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="making-http-requests.html"
							title="Learn about how to make fetch requests and render requested data in React Native components.">
							Making HTTP Requests
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="user-inputs.html"
							title="Use switch controls and inputs to collect information.">
							Handling User Inputs
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="using-asyncstorage.html"
							title="Store data locally on device with Async Storage and run data migrations with new versions of your application.">
							Using Async Storage
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="security-and-auth.html"
							title="Learn about security, authentication, and authorization by implementing Google Sign-In.">
							Security and Authentication
						</a>
						
					</li>
				
			
		
			
				
					<li class="current
           						parent
           						expanded">
						<a class="page"
							href="offline-support.html"
							title="Learn device-first strategies for storing data and syncing it to a server.">
							Adding Offline Support
						</a>
						
							

						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="google-maps.html"
							title="Learn how to integrate Google Maps into your React Native application.">
							Integrating Maps
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="performance-optimization.html"
							title="Improve the application’s launch time by implementing lazy loading.">
							Performance and Optimization
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="building.html"
							title="Learn how to build Android App Bundle (AAB) files.">
							Building React Native Apps
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="publishing-and-updating.html"
							title="Preparation for the steps to Publish and Update a production application on Stores.">
							Publishing and Updating
						</a>
						
					</li>
				
			
		
	</ul>


						
					</li>
				
			
		
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-web-components.html"
							title="">
							Learn Web Components
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-agile-program-management-with-jira.html"
							title="Learn how to build, maintain, and report on accurate multi-team plans with Jira.">
							Agile Program Management With Jira
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-rxjs.html"
							title="Learn RxJS by creating a validating credit card form.">
							Learn RxJS
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../training.html"
							title="Learn how to prepare and give a training.">
							Giving a Training
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-technology-consulting.html"
							title="Learn how to move beyond writing code to be an excellent technology consultant!">
							Learn Technology Consulting
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-react.html"
							title="Learn React by building the feature-rich Place My Order application in this beginner React guide. This hands-on course will introduce you to fundamental React concepts! By the end of this course, you will have a strong understanding of JSX, function components, styling, state management, Hooks, data fetching, routing, and testing.">
							Learn React
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-ngrx.html"
							title="Learn how to manage state in an Angular application using NgRx.">
							Learn NgRx
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-graphql.html"
							title="Build a backend application for property rentals using Node JS, GraphQL and Apollo Server.         Learn about using ORMs like Mongoose and Prisma with a NoSQL Mongo database!
Write testcases testing created endpoints.">
							Learn Graphql
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-docker.html"
							title="Build and containerize a Node.js app then orchestrate multiple containers with docker-compose in this Docker guide.">
							Learn Docker
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-canjs.html"
							title="This tutorial walks through building TodoMVC with StealJS. It includes KeyNote presentations
covering CanJS core libraries.">
							Learn CanJS
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-angular.html"
							title="Learn how to build a moderately complex application with Angular.">
							Learn Angular
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../advanced-typescript.html"
							title="This is the second course in the TypeScript series. By the end, you will be comfortable with any types you come across and possess the knowledge to create your own advanced types. The only prerequisite is the first course in the TypeScript series found here.">
							Advanced TypeScript
						</a>
						
					</li>
				
			
		
	</ul>


  
  <p class="border">
      <a href="..#courses">View More Courses</a>
      <a class='bit-academy-fullscreen' title='fullscreen' href="javascript://">[ ]</a>
  </p>
</div>

	
	<article class="main">
    <div class="main-content">
  		
  			<section class="title">
	<h1>Adding Offline Support <code>page</code></h1>
</section>

  		

  		
  			
  				<section class="description">
    <p>Learn device-first strategies for storing data and syncing it to a server.</p>

</section>

  			
  		

  		
  			
  				
  			
  			
  				<section class="body">
    <h2>Overview</h2>
<p>In this section, you will:</p>
<ul>
<li>Listen for changes to the network connection state.</li>
<li>Make an API call when the user signs in.</li>
<li>Design offline-syncing behavior.</li>
<li>Sync data between the device and server.</li>
</ul>
<h2>Objective 1: Show the current connection status</h2>
<p>Most mobile applications use a network connection for critical functionality.
It’s important to communicate to the user when their device is offline and some functionality in the application may be disabled because of their current connection status.</p>
<p>The way you communicate this info will depend on your application.
In ours, we’re going to add some text to the Settings view that shows the current connection status.</p>
<p><img alt="Screenshot of the application settings page with the connection status." src="../static/img/react-native/17-offline-support/01-solution.png" style="max-height: 640px; border: 4px solid black; border-radius: 25px;"/></p>
<h3>Listening for the network connection state</h3>
<p>The <code>@react-native-community/netinfo</code> is an incredible useful package for detecting the network status of the device.</p>
<p>This package allows you to:</p>
<ul>
<li>Detect whether the device is connected to the internet.</li>
<li>Determine the type of network connection (WiFi, cellular, etc.).</li>
<li>React to changes in the network status, allowing the app to adapt accordingly.</li>
</ul>
<h3>Getting the current connection state</h3>
<p>The <code>useNetInfo</code> Hook provided by the package simplifies the process of accessing network state information in functional components.
This Hook returns an object containing details about the network status.</p>
<pre><code class="language-tsx">import { useNetInfo } from &quot;@react-native-community/netinfo&quot;
import React from &quot;react&quot;
import { Text, View } from &quot;react-native&quot;

const NetworkStatusComponent = () =&gt; {
  const { isConnected } = useNetInfo()

  return (
    &lt;View&gt;
      &lt;Text&gt;Is connected: {isConnected ? &quot;Yes&quot; : &quot;No&quot;}&lt;/Text&gt;
    &lt;/View&gt;
  )
}

export default NetworkStatusComponent

</code></pre>
<div line-highlight='1, 6, 10, only'></div>
<h3>Setup 1</h3>
<p>✏️ Install the new dependency:</p>
<pre><code class="language-bash">npm install @react-native-community/netinfo@11
</code></pre>
<p>✏️ Create <strong>@types/@react-native-community/netinfo/jest/netinfo-mock.d.ts</strong> and update it to be:</p>
<pre><code class="language-ts">declare module &quot;@react-native-community/netinfo/jest/netinfo-mock&quot;

</code></pre>
<div line-highlight='1'></div>
<p>✏️ Update <strong>jest-setup.ts</strong> to be:</p>
<pre><code class="language-ts">import &quot;@testing-library/react-native/extend-expect&quot;

import &quot;react-native-gesture-handler/jestSetup&quot;
import &quot;@react-native-google-signin/google-signin/jest/build/setup&quot;

import mockRNCNetInfo from &quot;@react-native-community/netinfo/jest/netinfo-mock&quot;

jest.mock(&quot;@react-native-community/netinfo&quot;, () =&gt; mockRNCNetInfo)

jest.mock(&quot;@react-navigation/native&quot;, () =&gt; {
  const actualNav = jest.requireActual(&quot;@react-navigation/native&quot;)
  return {
    ...actualNav,
    useNavigation: () =&gt; ({
      navigate: jest.fn(),
      setOptions: jest.fn(),
    }),
  }
})

jest.mock(&quot;./src/services/storage/storage&quot;, () =&gt;
  require(&quot;./src/services/storage/storage.mock&quot;),
)

jest.mock(&quot;@react-native-async-storage/async-storage&quot;, () =&gt;
  require(&quot;@react-native-async-storage/async-storage/jest/async-storage-mock&quot;),
)

const consoleError = console.error
console.error = (message, ...args) =&gt; {
  if (
    typeof message === &quot;string&quot; &amp;&amp;
    message.match(
      /Warning: An update to .+ inside a test was not wrapped in act\(\.\.\.\)\./,
    )
  ) {
    return
  }

  return consoleError(message, ...args)
}

</code></pre>
 <div line-highlight="6,8,only"></div>
<p>✏️ Terminate the existing dev server and start it again:</p>
<pre><code class="language-bash">npm run start
</code></pre>
<p>✏️ Update <strong>src/screens/Settings/Settings.tsx</strong> to be:</p>
<pre><code class="language-tsx">import { useNetInfo } from &quot;@react-native-community/netinfo&quot;
import { GoogleSigninButton } from &quot;@react-native-google-signin/google-signin&quot;
import { StyleSheet, Switch, View } from &quot;react-native&quot;

import Loading from &quot;../../components/Loading&quot;
import Button from &quot;../../design/Button&quot;
import Card from &quot;../../design/Card&quot;
import Screen from &quot;../../design/Screen&quot;
import { useThemeMode } from &quot;../../design/theme&quot;
import Typography from &quot;../../design/Typography&quot;
import { useAuthentication, useUser } from &quot;../../services/auth&quot;

const Settings: React.FC = () =&gt; {
  const { error, isPending, signIn, signOut } = useAuthentication()
  const user = useUser()
  const { mode, setMode } = useThemeMode()
  // Exercise: Get the current connection state with the `useNetInfo()` Hook.

  return (
    &lt;Screen&gt;
      &lt;Card&gt;
        {isPending ? (
          &lt;Loading /&gt;
        ) : user ? (
          &lt;&gt;
            &lt;Typography variant=&quot;heading&quot;&gt;Welcome back&lt;/Typography&gt;
            &lt;Typography variant=&quot;body&quot;&gt;
              {user.name || &quot;Unknown name&quot;}
            &lt;/Typography&gt;
            &lt;Button onPress={signOut}&gt;Sign out&lt;/Button&gt;
            {error ? (
              &lt;Typography variant=&quot;body&quot;&gt;Error: {error.message}&lt;/Typography&gt;
            ) : null}
          &lt;/&gt;
        ) : (
          &lt;&gt;
            &lt;GoogleSigninButton onPress={signIn} style={{ width: &quot;100%&quot; }} /&gt;
            {error ? (
              &lt;Typography variant=&quot;body&quot;&gt;Error: {error.message}&lt;/Typography&gt;
            ) : null}
          &lt;/&gt;
        )}
      &lt;/Card&gt;
      &lt;Card&gt;
        &lt;View style={styles.row}&gt;
          &lt;Typography variant=&quot;heading&quot;&gt;Dark mode&lt;/Typography&gt;
          &lt;Switch
            onValueChange={(value) =&gt; setMode(value ? &quot;dark&quot; : &quot;light&quot;)}
            value={mode === &quot;dark&quot;}
          /&gt;
        &lt;/View&gt;
      &lt;/Card&gt;
      {/* Exercise: Display the connection state in the Settings view. */}
    &lt;/Screen&gt;
  )
}

const styles = StyleSheet.create({
  row: {
    flexDirection: &quot;row&quot;,
    alignItems: &quot;center&quot;,
    justifyContent: &quot;space-between&quot;,
  },
})

export default Settings

</code></pre>
 <div line-highlight="1,17,53,only"></div>
<h3>Verify 1</h3>
<p>✏️ Update <strong>src/screens/Settings/Settings.test.tsx</strong> to be:</p>
<pre><code class="language-tsx">import { NavigationContainer } from &quot;@react-navigation/native&quot;
import { fireEvent, render, screen } from &quot;@testing-library/react-native&quot;

import AuthProvider from &quot;../../services/auth/AuthProvider&quot;

import Settings from &quot;./Settings&quot;

const mockSetMode = jest.fn()

jest.mock(&quot;../../design/theme&quot;, () =&gt; ({
  ...jest.requireActual(&quot;../../design/theme&quot;),
  useThemeMode: () =&gt; ({
    mode: &quot;light&quot;,
    setMode: mockSetMode,
  }),
}))

describe(&quot;Screens/Settings&quot;, () =&gt; {
  it(&quot;renders&quot;, async () =&gt; {
    render(
      &lt;AuthProvider&gt;
        &lt;NavigationContainer&gt;
          &lt;Settings /&gt;
        &lt;/NavigationContainer&gt;
      &lt;/AuthProvider&gt;,
    )
    expect(screen.getByText(/Loading…/i)).not.toBeNull()
  })

  it(&quot;switches to dark mode&quot;, () =&gt; {
    render(
      &lt;AuthProvider&gt;
        &lt;NavigationContainer&gt;
          &lt;Settings /&gt;
        &lt;/NavigationContainer&gt;
      &lt;/AuthProvider&gt;,
    )

    const switchElement = screen.getByRole(&quot;switch&quot;)
    expect(switchElement.props.value).toBe(false)

    fireEvent(switchElement, &quot;onValueChange&quot;, true)
    expect(mockSetMode).toHaveBeenCalledWith(&quot;dark&quot;)
  })

  it(&quot;displays the correct connection status&quot;, () =&gt; {
    render(
      &lt;AuthProvider&gt;
        &lt;NavigationContainer&gt;
          &lt;Settings /&gt;
        &lt;/NavigationContainer&gt;
      &lt;/AuthProvider&gt;,
    )

    expect(screen.getByText(/Connection status: Online/i)).not.toBeNull()
  })
})

</code></pre>
 <div line-highlight="46-53,55-56,only"></div>
<h3>Exercise 1</h3>
<ul>
<li>Get the current connection state with the <code>useNetInfo()</code> Hook.</li>
<li>Display the connection state in the Settings view.</li>
</ul>
<h3>Solution 1</h3>
<p>If you’ve implemented the solution correctly, the tests will pass when you run <code>npm run test</code>!</p>
<p><details>
<summary>Click to see the solution</summary></p>
<p>✏️ Update <strong>src/screens/Settings/Settings.tsx</strong> to be:</p>
<pre><code class="language-tsx">import { useNetInfo } from &quot;@react-native-community/netinfo&quot;
import { GoogleSigninButton } from &quot;@react-native-google-signin/google-signin&quot;
import { StyleSheet, Switch, View } from &quot;react-native&quot;

import Loading from &quot;../../components/Loading&quot;
import Button from &quot;../../design/Button&quot;
import Card from &quot;../../design/Card&quot;
import Screen from &quot;../../design/Screen&quot;
import { useThemeMode } from &quot;../../design/theme&quot;
import Typography from &quot;../../design/Typography&quot;
import { useAuthentication, useUser } from &quot;../../services/auth&quot;

const Settings: React.FC = () =&gt; {
  const { error, isPending, signIn, signOut } = useAuthentication()
  const user = useUser()
  const { mode, setMode } = useThemeMode()
  const { isConnected } = useNetInfo()

  return (
    &lt;Screen&gt;
      &lt;Card&gt;
        {isPending ? (
          &lt;Loading /&gt;
        ) : user ? (
          &lt;&gt;
            &lt;Typography variant=&quot;heading&quot;&gt;Welcome back&lt;/Typography&gt;
            &lt;Typography variant=&quot;body&quot;&gt;
              {user.name || &quot;Unknown name&quot;}
            &lt;/Typography&gt;
            &lt;Button onPress={signOut}&gt;Sign out&lt;/Button&gt;
            {error ? (
              &lt;Typography variant=&quot;body&quot;&gt;Error: {error.message}&lt;/Typography&gt;
            ) : null}
          &lt;/&gt;
        ) : (
          &lt;&gt;
            &lt;GoogleSigninButton onPress={signIn} style={{ width: &quot;100%&quot; }} /&gt;
            {error ? (
              &lt;Typography variant=&quot;body&quot;&gt;Error: {error.message}&lt;/Typography&gt;
            ) : null}
          &lt;/&gt;
        )}
      &lt;/Card&gt;
      &lt;Card&gt;
        &lt;View style={styles.row}&gt;
          &lt;Typography variant=&quot;heading&quot;&gt;Dark mode&lt;/Typography&gt;
          &lt;Switch
            onValueChange={(value) =&gt; setMode(value ? &quot;dark&quot; : &quot;light&quot;)}
            value={mode === &quot;dark&quot;}
          /&gt;
        &lt;/View&gt;
      &lt;/Card&gt;
      &lt;Card&gt;
        &lt;Typography variant=&quot;title&quot;&gt;
          Connection status: {isConnected ? &quot;Online&quot; : &quot;Offline&quot;}
        &lt;/Typography&gt;
      &lt;/Card&gt;
    &lt;/Screen&gt;
  )
}

const styles = StyleSheet.create({
  row: {
    flexDirection: &quot;row&quot;,
    alignItems: &quot;center&quot;,
    justifyContent: &quot;space-between&quot;,
  },
})

export default Settings

</code></pre>
 <div line-highlight="17,53-57,only"></div>
<p></details></p>
<h2>Objective 2: Store restaurant favorites on device</h2>
<p>Now that you can detect when the device is online or offline, let’s build a feature that can work offline!</p>
<p>Let’s add the ability to “favorite” a restaurant.
In the <code>RestaurantDetails</code>, we’ll add an “Add to favorites” button when the user is signed in, and if they favorite a restaurant, we’ll change it to “Remove from favorites.”</p>
<p>For right now, we’ll write the code for adding and removing favorites in a way that will gracefully handle the user’s device being offline.
In the third objective, we’ll expand that to handle syncing when the device comes back online.</p>
<div style="display: flex; flex-direction: row; gap: 2rem">
  <img alt="Screenshot of the application's Restaurant Details screen displaying the add favorite button." src="../static/img/react-native/17-offline-support/02-solution-addFavorites.png" style="max-height: 640px; border: 4px solid black; border-radius: 25px;"/>
  <img alt="Screenshot of the application's Restaurant Details screen displaying the remove favorite button." src="../static/img/react-native/17-offline-support/02-solution-removeFavorites.png" style="max-height: 640px; border: 4px solid black; border-radius: 25px;"/>
</div>
<h3>Defining the “favorites” feature</h3>
<p>There’s a lot that goes into building even a one or two-button feature like the “add to favorites” and “remove from favorites” feature that we’re about to build.</p>
<p>Let’s think through what we want in the restaurant details view:</p>
<ul>
<li>When the user is not signed in or they haven’t added the restaurant as a favorite, there should be an “Add to favorites” button.</li>
<li>When the user has added the restaurant as a favorite, there should be a “Remove from favorites” button.</li>
<li>When the “Add” button is clicked and the user is not signed in, they should be sent through the sign-in flow.</li>
<li>When the “Add” or “Remove” buttons are clicked and the user is signed in, that change should immediately be saved in our Async Storage and sent to the API.</li>
<li>If there’s a problem with the API call (the server is down, the device is offline, etc.), then the change should still be saved to Async Storage.</li>
</ul>
<p>Features like this are great to build into Hooks because it makes the logic more easily testable and reusable.
Let’s look at the Hook code we are going to copy in the Setup step for this exercise.</p>
<h3>Creating a <code>useFavorite()</code> Hook</h3>
<p>Our <code>useFavorite()</code> Hook will accept two arguments:</p>
<pre><code class="language-ts">import { useEffect, useState } from &quot;react&quot;

import { getData, storeData } from &quot;../../storage&quot;
import { apiRequest } from &quot;../api&quot;

import { Favorite, FavoriteResponse, StoredFavorites } from &quot;./interfaces&quot;

export const useFavorite = (
  userId?: string,
  restaurantId?: string,
): {
  error: Error | undefined
  isFavorite: boolean
  isPending: boolean
  toggleFavorite: () =&gt; void
} =&gt; {
  const [error, setError] = useState&lt;Error | undefined&gt;()
  const [isPending, setIsPending] = useState&lt;boolean&gt;(false)
  const [favoriteRestaurants, setFavoriteRestaurants] = useState&lt;
    StoredFavorites | undefined
  &gt;()

  useEffect(() =&gt; {
    // Get the favorite restaurant data from storage.
    const getStoredData = async () =&gt; {
      const storedData = await getData&lt;StoredFavorites&gt;(&quot;favorite-restaurants&quot;)
      setFavoriteRestaurants(storedData)
    }
    getStoredData()
  }, [])

  // Finding whether a restaurant is a favorite.
  const favoriteRestaurant = favoriteRestaurants?.favorites.find(
    (favorite) =&gt; favorite.restaurantId === restaurantId,
  )

  const toggleFavorite = async () =&gt; {
    // updatedFavorite has the toggled “favorite” status.
    const updatedFavorite = favoriteRestaurant
      ? {
          ...favoriteRestaurant,
          favorite: !favoriteRestaurant.favorite, // Toggle it.
        }
      : ({
          favorite: true, // Default to it being a new favorite.
          restaurantId: restaurantId,
          userId: userId,
        } as Favorite)

    // Update the datetime on the favorite
    updatedFavorite.datetimeUpdated = Date.now()

    // updatedFavorites will hold all the updated data before storage is updated.
    const updatedFavorites =
      favoriteRestaurants &amp;&amp; favoriteRestaurants.favorites
        ? {
            ...favoriteRestaurants,
          }
        : {
            favorites: [] as Favorite[],
            lastSynced: 0,
          }

    // Update the full favorite restaurants array.
    const favoriteIndex = favoriteRestaurants?.favorites.findIndex(
      (favorite) =&gt; favorite.restaurantId === restaurantId,
    )
    if (favoriteIndex !== undefined &amp;&amp; favoriteIndex &gt;= 0) {
      // Already a favorite, so update the array in place.
      updatedFavorites.favorites[favoriteIndex] = updatedFavorite
    } else {
      // Brand new favorite, so add it to the array.
      updatedFavorites.favorites.push(updatedFavorite)
    }

    try {
      setError(undefined)
      setIsPending(true)

      const { data: updateFavoritesResponse, error } =
        await apiRequest&lt;FavoriteResponse&gt;({
          method: &quot;POST&quot;,
          path: &quot;/favorites&quot;,
          body: updatedFavorite,
        })

      if (updateFavoritesResponse &amp;&amp; updateFavoritesResponse.data) {
        // Assign the _id property created from the API call to the new favorite.
        updatedFavorite._id = updateFavoritesResponse.data._id
      }

      // Update the stored data.
      await storeData&lt;StoredFavorites&gt;(&quot;favorite-restaurants&quot;, updatedFavorites)

      setError(error)
      setFavoriteRestaurants(updatedFavorites)
      setIsPending(false)
    } catch (error) {
      if (error instanceof Error) {
        setError(error)
      } else {
        setError(new Error(&quot;Unknown error while updating favorites.&quot;))
      }
      setIsPending(false)
    }
  }

  return {
    error,
    isFavorite: (favoriteRestaurant &amp;&amp; favoriteRestaurant.favorite) || false,
    isPending,
    toggleFavorite,
  }
}

</code></pre>
<div line-highlight='8-11, only'></div>
<p>You’ll remember that the Rules of Hooks state that Hooks must always be called at the top level of a component, so this Hook makes these properties optional because, for example, you may not be signed in (and thus won’t have a <code>userId</code>).</p>
<h3>Determining if a restaurant is a favorite</h3>
<p>The Hook will return a <code>true</code> or <code>false</code> value for <code>isFavorite</code>, depending on whether the restaurant is a favorite:</p>
<pre><code class="language-ts">import { useEffect, useState } from &quot;react&quot;

import { getData, storeData } from &quot;../../storage&quot;
import { apiRequest } from &quot;../api&quot;

import { Favorite, FavoriteResponse, StoredFavorites } from &quot;./interfaces&quot;

export const useFavorite = (
  userId?: string,
  restaurantId?: string,
): {
  error: Error | undefined
  isFavorite: boolean
  isPending: boolean
  toggleFavorite: () =&gt; void
} =&gt; {
  const [error, setError] = useState&lt;Error | undefined&gt;()
  const [isPending, setIsPending] = useState&lt;boolean&gt;(false)
  const [favoriteRestaurants, setFavoriteRestaurants] = useState&lt;
    StoredFavorites | undefined
  &gt;()

  useEffect(() =&gt; {
    // Get the favorite restaurant data from storage.
    const getStoredData = async () =&gt; {
      const storedData = await getData&lt;StoredFavorites&gt;(&quot;favorite-restaurants&quot;)
      setFavoriteRestaurants(storedData)
    }
    getStoredData()
  }, [])

  // Finding whether a restaurant is a favorite.
  const favoriteRestaurant = favoriteRestaurants?.favorites.find(
    (favorite) =&gt; favorite.restaurantId === restaurantId,
  )

  const toggleFavorite = async () =&gt; {
    // updatedFavorite has the toggled “favorite” status.
    const updatedFavorite = favoriteRestaurant
      ? {
          ...favoriteRestaurant,
          favorite: !favoriteRestaurant.favorite, // Toggle it.
        }
      : ({
          favorite: true, // Default to it being a new favorite.
          restaurantId: restaurantId,
          userId: userId,
        } as Favorite)

    // Update the datetime on the favorite
    updatedFavorite.datetimeUpdated = Date.now()

    // updatedFavorites will hold all the updated data before storage is updated.
    const updatedFavorites =
      favoriteRestaurants &amp;&amp; favoriteRestaurants.favorites
        ? {
            ...favoriteRestaurants,
          }
        : {
            favorites: [] as Favorite[],
            lastSynced: 0,
          }

    // Update the full favorite restaurants array.
    const favoriteIndex = favoriteRestaurants?.favorites.findIndex(
      (favorite) =&gt; favorite.restaurantId === restaurantId,
    )
    if (favoriteIndex !== undefined &amp;&amp; favoriteIndex &gt;= 0) {
      // Already a favorite, so update the array in place.
      updatedFavorites.favorites[favoriteIndex] = updatedFavorite
    } else {
      // Brand new favorite, so add it to the array.
      updatedFavorites.favorites.push(updatedFavorite)
    }

    try {
      setError(undefined)
      setIsPending(true)

      const { data: updateFavoritesResponse, error } =
        await apiRequest&lt;FavoriteResponse&gt;({
          method: &quot;POST&quot;,
          path: &quot;/favorites&quot;,
          body: updatedFavorite,
        })

      if (updateFavoritesResponse &amp;&amp; updateFavoritesResponse.data) {
        // Assign the _id property created from the API call to the new favorite.
        updatedFavorite._id = updateFavoritesResponse.data._id
      }

      // Update the stored data.
      await storeData&lt;StoredFavorites&gt;(&quot;favorite-restaurants&quot;, updatedFavorites)

      setError(error)
      setFavoriteRestaurants(updatedFavorites)
      setIsPending(false)
    } catch (error) {
      if (error instanceof Error) {
        setError(error)
      } else {
        setError(new Error(&quot;Unknown error while updating favorites.&quot;))
      }
      setIsPending(false)
    }
  }

  return {
    error,
    isFavorite: (favoriteRestaurant &amp;&amp; favoriteRestaurant.favorite) || false,
    isPending,
    toggleFavorite,
  }
}

</code></pre>
<div line-highlight='13, 32-35, 110, only'></div>
<h3>Getting favorites from storage</h3>
<p>The Hook gets all the favorite restaurants from Async Storage:</p>
<pre><code class="language-ts">import { useEffect, useState } from &quot;react&quot;

import { getData, storeData } from &quot;../../storage&quot;
import { apiRequest } from &quot;../api&quot;

import { Favorite, FavoriteResponse, StoredFavorites } from &quot;./interfaces&quot;

export const useFavorite = (
  userId?: string,
  restaurantId?: string,
): {
  error: Error | undefined
  isFavorite: boolean
  isPending: boolean
  toggleFavorite: () =&gt; void
} =&gt; {
  const [error, setError] = useState&lt;Error | undefined&gt;()
  const [isPending, setIsPending] = useState&lt;boolean&gt;(false)
  const [favoriteRestaurants, setFavoriteRestaurants] = useState&lt;
    StoredFavorites | undefined
  &gt;()

  useEffect(() =&gt; {
    // Get the favorite restaurant data from storage.
    const getStoredData = async () =&gt; {
      const storedData = await getData&lt;StoredFavorites&gt;(&quot;favorite-restaurants&quot;)
      setFavoriteRestaurants(storedData)
    }
    getStoredData()
  }, [])

  // Finding whether a restaurant is a favorite.
  const favoriteRestaurant = favoriteRestaurants?.favorites.find(
    (favorite) =&gt; favorite.restaurantId === restaurantId,
  )

  const toggleFavorite = async () =&gt; {
    // updatedFavorite has the toggled “favorite” status.
    const updatedFavorite = favoriteRestaurant
      ? {
          ...favoriteRestaurant,
          favorite: !favoriteRestaurant.favorite, // Toggle it.
        }
      : ({
          favorite: true, // Default to it being a new favorite.
          restaurantId: restaurantId,
          userId: userId,
        } as Favorite)

    // Update the datetime on the favorite
    updatedFavorite.datetimeUpdated = Date.now()

    // updatedFavorites will hold all the updated data before storage is updated.
    const updatedFavorites =
      favoriteRestaurants &amp;&amp; favoriteRestaurants.favorites
        ? {
            ...favoriteRestaurants,
          }
        : {
            favorites: [] as Favorite[],
            lastSynced: 0,
          }

    // Update the full favorite restaurants array.
    const favoriteIndex = favoriteRestaurants?.favorites.findIndex(
      (favorite) =&gt; favorite.restaurantId === restaurantId,
    )
    if (favoriteIndex !== undefined &amp;&amp; favoriteIndex &gt;= 0) {
      // Already a favorite, so update the array in place.
      updatedFavorites.favorites[favoriteIndex] = updatedFavorite
    } else {
      // Brand new favorite, so add it to the array.
      updatedFavorites.favorites.push(updatedFavorite)
    }

    try {
      setError(undefined)
      setIsPending(true)

      const { data: updateFavoritesResponse, error } =
        await apiRequest&lt;FavoriteResponse&gt;({
          method: &quot;POST&quot;,
          path: &quot;/favorites&quot;,
          body: updatedFavorite,
        })

      if (updateFavoritesResponse &amp;&amp; updateFavoritesResponse.data) {
        // Assign the _id property created from the API call to the new favorite.
        updatedFavorite._id = updateFavoritesResponse.data._id
      }

      // Update the stored data.
      await storeData&lt;StoredFavorites&gt;(&quot;favorite-restaurants&quot;, updatedFavorites)

      setError(error)
      setFavoriteRestaurants(updatedFavorites)
      setIsPending(false)
    } catch (error) {
      if (error instanceof Error) {
        setError(error)
      } else {
        setError(new Error(&quot;Unknown error while updating favorites.&quot;))
      }
      setIsPending(false)
    }
  }

  return {
    error,
    isFavorite: (favoriteRestaurant &amp;&amp; favoriteRestaurant.favorite) || false,
    isPending,
    toggleFavorite,
  }
}

</code></pre>
<div line-highlight='23-30, only'></div>
<h3>Toggling a restaurant’s favorite status</h3>
<p>The Hook returns a <code>toggleFavorite</code> function that can be called to toggle whether the restaurant is a favorite or not:</p>
<pre><code class="language-ts">import { useEffect, useState } from &quot;react&quot;

import { getData, storeData } from &quot;../../storage&quot;
import { apiRequest } from &quot;../api&quot;

import { Favorite, FavoriteResponse, StoredFavorites } from &quot;./interfaces&quot;

export const useFavorite = (
  userId?: string,
  restaurantId?: string,
): {
  error: Error | undefined
  isFavorite: boolean
  isPending: boolean
  toggleFavorite: () =&gt; void
} =&gt; {
  const [error, setError] = useState&lt;Error | undefined&gt;()
  const [isPending, setIsPending] = useState&lt;boolean&gt;(false)
  const [favoriteRestaurants, setFavoriteRestaurants] = useState&lt;
    StoredFavorites | undefined
  &gt;()

  useEffect(() =&gt; {
    // Get the favorite restaurant data from storage.
    const getStoredData = async () =&gt; {
      const storedData = await getData&lt;StoredFavorites&gt;(&quot;favorite-restaurants&quot;)
      setFavoriteRestaurants(storedData)
    }
    getStoredData()
  }, [])

  // Finding whether a restaurant is a favorite.
  const favoriteRestaurant = favoriteRestaurants?.favorites.find(
    (favorite) =&gt; favorite.restaurantId === restaurantId,
  )

  const toggleFavorite = async () =&gt; {
    // updatedFavorite has the toggled “favorite” status.
    const updatedFavorite = favoriteRestaurant
      ? {
          ...favoriteRestaurant,
          favorite: !favoriteRestaurant.favorite, // Toggle it.
        }
      : ({
          favorite: true, // Default to it being a new favorite.
          restaurantId: restaurantId,
          userId: userId,
        } as Favorite)

    // Update the datetime on the favorite
    updatedFavorite.datetimeUpdated = Date.now()

    // updatedFavorites will hold all the updated data before storage is updated.
    const updatedFavorites =
      favoriteRestaurants &amp;&amp; favoriteRestaurants.favorites
        ? {
            ...favoriteRestaurants,
          }
        : {
            favorites: [] as Favorite[],
            lastSynced: 0,
          }

    // Update the full favorite restaurants array.
    const favoriteIndex = favoriteRestaurants?.favorites.findIndex(
      (favorite) =&gt; favorite.restaurantId === restaurantId,
    )
    if (favoriteIndex !== undefined &amp;&amp; favoriteIndex &gt;= 0) {
      // Already a favorite, so update the array in place.
      updatedFavorites.favorites[favoriteIndex] = updatedFavorite
    } else {
      // Brand new favorite, so add it to the array.
      updatedFavorites.favorites.push(updatedFavorite)
    }

    try {
      setError(undefined)
      setIsPending(true)

      const { data: updateFavoritesResponse, error } =
        await apiRequest&lt;FavoriteResponse&gt;({
          method: &quot;POST&quot;,
          path: &quot;/favorites&quot;,
          body: updatedFavorite,
        })

      if (updateFavoritesResponse &amp;&amp; updateFavoritesResponse.data) {
        // Assign the _id property created from the API call to the new favorite.
        updatedFavorite._id = updateFavoritesResponse.data._id
      }

      // Update the stored data.
      await storeData&lt;StoredFavorites&gt;(&quot;favorite-restaurants&quot;, updatedFavorites)

      setError(error)
      setFavoriteRestaurants(updatedFavorites)
      setIsPending(false)
    } catch (error) {
      if (error instanceof Error) {
        setError(error)
      } else {
        setError(new Error(&quot;Unknown error while updating favorites.&quot;))
      }
      setIsPending(false)
    }
  }

  return {
    error,
    isFavorite: (favoriteRestaurant &amp;&amp; favoriteRestaurant.favorite) || false,
    isPending,
    toggleFavorite,
  }
}

</code></pre>
<div line-highlight='15, 37, 42, 45, 112, only'></div>
<h3>Updating the API with the changed favorite status</h3>
<p>The Hook calls the API to update the favorite status for the restaurant:</p>
<pre><code class="language-ts">import { useEffect, useState } from &quot;react&quot;

import { getData, storeData } from &quot;../../storage&quot;
import { apiRequest } from &quot;../api&quot;

import { Favorite, FavoriteResponse, StoredFavorites } from &quot;./interfaces&quot;

export const useFavorite = (
  userId?: string,
  restaurantId?: string,
): {
  error: Error | undefined
  isFavorite: boolean
  isPending: boolean
  toggleFavorite: () =&gt; void
} =&gt; {
  const [error, setError] = useState&lt;Error | undefined&gt;()
  const [isPending, setIsPending] = useState&lt;boolean&gt;(false)
  const [favoriteRestaurants, setFavoriteRestaurants] = useState&lt;
    StoredFavorites | undefined
  &gt;()

  useEffect(() =&gt; {
    // Get the favorite restaurant data from storage.
    const getStoredData = async () =&gt; {
      const storedData = await getData&lt;StoredFavorites&gt;(&quot;favorite-restaurants&quot;)
      setFavoriteRestaurants(storedData)
    }
    getStoredData()
  }, [])

  // Finding whether a restaurant is a favorite.
  const favoriteRestaurant = favoriteRestaurants?.favorites.find(
    (favorite) =&gt; favorite.restaurantId === restaurantId,
  )

  const toggleFavorite = async () =&gt; {
    // updatedFavorite has the toggled “favorite” status.
    const updatedFavorite = favoriteRestaurant
      ? {
          ...favoriteRestaurant,
          favorite: !favoriteRestaurant.favorite, // Toggle it.
        }
      : ({
          favorite: true, // Default to it being a new favorite.
          restaurantId: restaurantId,
          userId: userId,
        } as Favorite)

    // Update the datetime on the favorite
    updatedFavorite.datetimeUpdated = Date.now()

    // updatedFavorites will hold all the updated data before storage is updated.
    const updatedFavorites =
      favoriteRestaurants &amp;&amp; favoriteRestaurants.favorites
        ? {
            ...favoriteRestaurants,
          }
        : {
            favorites: [] as Favorite[],
            lastSynced: 0,
          }

    // Update the full favorite restaurants array.
    const favoriteIndex = favoriteRestaurants?.favorites.findIndex(
      (favorite) =&gt; favorite.restaurantId === restaurantId,
    )
    if (favoriteIndex !== undefined &amp;&amp; favoriteIndex &gt;= 0) {
      // Already a favorite, so update the array in place.
      updatedFavorites.favorites[favoriteIndex] = updatedFavorite
    } else {
      // Brand new favorite, so add it to the array.
      updatedFavorites.favorites.push(updatedFavorite)
    }

    try {
      setError(undefined)
      setIsPending(true)

      const { data: updateFavoritesResponse, error } =
        await apiRequest&lt;FavoriteResponse&gt;({
          method: &quot;POST&quot;,
          path: &quot;/favorites&quot;,
          body: updatedFavorite,
        })

      if (updateFavoritesResponse &amp;&amp; updateFavoritesResponse.data) {
        // Assign the _id property created from the API call to the new favorite.
        updatedFavorite._id = updateFavoritesResponse.data._id
      }

      // Update the stored data.
      await storeData&lt;StoredFavorites&gt;(&quot;favorite-restaurants&quot;, updatedFavorites)

      setError(error)
      setFavoriteRestaurants(updatedFavorites)
      setIsPending(false)
    } catch (error) {
      if (error instanceof Error) {
        setError(error)
      } else {
        setError(new Error(&quot;Unknown error while updating favorites.&quot;))
      }
      setIsPending(false)
    }
  }

  return {
    error,
    isFavorite: (favoriteRestaurant &amp;&amp; favoriteRestaurant.favorite) || false,
    isPending,
    toggleFavorite,
  }
}

</code></pre>
<div line-highlight='80-85, only'></div>
<p>The API may return an <code>error</code>, and that’s ok!
The Hook can check if the API response was good and store the <code>_id</code> if it was.</p>
<p>If there was an issue with the API call (e.g. the server was down, the device was offline, etc.) then there won’t be an <code>_id</code> in our Async Storage and we’ll know that we need to submit that favorite to the API.</p>
<h3>Setup 2</h3>
<p>✏️ Create <strong>src/services/pmo/favorite/interfaces.ts</strong> and update it to be:</p>
<pre><code class="language-ts">export interface Favorite {
  userId: string
  restaurantId: string
  favorite: boolean
  datetimeUpdated: number
  _id?: string
}

export interface FavoritesResponse {
  data: Favorite[] | undefined
  error: Error | undefined
  isPending: boolean
}

export interface FavoriteResponse {
  data: Favorite | undefined
  error: Error | undefined
  isPending: boolean
}

export interface StoredFavorites {
  lastSynced: number
  favorites: Favorite[]
}

</code></pre>
<div line-highlight='1, 9, 15, 21, only'></div>
<p>✏️ Create <strong>src/services/pmo/favorite/hooks.ts</strong> and update it to be:</p>
<pre><code class="language-ts">import { useEffect, useState } from &quot;react&quot;

import { getData, storeData } from &quot;../../storage&quot;
import { apiRequest } from &quot;../api&quot;

import { Favorite, FavoriteResponse, StoredFavorites } from &quot;./interfaces&quot;

export const useFavorite = (
  userId?: string,
  restaurantId?: string,
): {
  error: Error | undefined
  isFavorite: boolean
  isPending: boolean
  toggleFavorite: () =&gt; void
} =&gt; {
  const [error, setError] = useState&lt;Error | undefined&gt;()
  const [isPending, setIsPending] = useState&lt;boolean&gt;(false)
  const [favoriteRestaurants, setFavoriteRestaurants] = useState&lt;
    StoredFavorites | undefined
  &gt;()

  useEffect(() =&gt; {
    // Get the favorite restaurant data from storage.
    const getStoredData = async () =&gt; {
      const storedData = await getData&lt;StoredFavorites&gt;(&quot;favorite-restaurants&quot;)
      setFavoriteRestaurants(storedData)
    }
    getStoredData()
  }, [])

  // Finding whether a restaurant is a favorite.
  const favoriteRestaurant = favoriteRestaurants?.favorites.find(
    (favorite) =&gt; favorite.restaurantId === restaurantId,
  )

  const toggleFavorite = async () =&gt; {
    // updatedFavorite has the toggled “favorite” status.
    const updatedFavorite = favoriteRestaurant
      ? {
          ...favoriteRestaurant,
          favorite: !favoriteRestaurant.favorite, // Toggle it.
        }
      : ({
          favorite: true, // Default to it being a new favorite.
          restaurantId: restaurantId,
          userId: userId,
        } as Favorite)

    // Update the datetime on the favorite
    updatedFavorite.datetimeUpdated = Date.now()

    // updatedFavorites will hold all the updated data before storage is updated.
    const updatedFavorites =
      favoriteRestaurants &amp;&amp; favoriteRestaurants.favorites
        ? {
            ...favoriteRestaurants,
          }
        : {
            favorites: [] as Favorite[],
            lastSynced: 0,
          }

    // Update the full favorite restaurants array.
    const favoriteIndex = favoriteRestaurants?.favorites.findIndex(
      (favorite) =&gt; favorite.restaurantId === restaurantId,
    )
    if (favoriteIndex !== undefined &amp;&amp; favoriteIndex &gt;= 0) {
      // Already a favorite, so update the array in place.
      updatedFavorites.favorites[favoriteIndex] = updatedFavorite
    } else {
      // Brand new favorite, so add it to the array.
      updatedFavorites.favorites.push(updatedFavorite)
    }

    try {
      setError(undefined)
      setIsPending(true)

      const { data: updateFavoritesResponse, error } =
        await apiRequest&lt;FavoriteResponse&gt;({
          method: &quot;POST&quot;,
          path: &quot;/favorites&quot;,
          body: updatedFavorite,
        })

      if (updateFavoritesResponse &amp;&amp; updateFavoritesResponse.data) {
        // Assign the _id property created from the API call to the new favorite.
        updatedFavorite._id = updateFavoritesResponse.data._id
      }

      // Update the stored data.
      await storeData&lt;StoredFavorites&gt;(&quot;favorite-restaurants&quot;, updatedFavorites)

      setError(error)
      setFavoriteRestaurants(updatedFavorites)
      setIsPending(false)
    } catch (error) {
      if (error instanceof Error) {
        setError(error)
      } else {
        setError(new Error(&quot;Unknown error while updating favorites.&quot;))
      }
      setIsPending(false)
    }
  }

  return {
    error,
    isFavorite: (favoriteRestaurant &amp;&amp; favoriteRestaurant.favorite) || false,
    isPending,
    toggleFavorite,
  }
}

</code></pre>
<div line-highlight='8-16, 108-113, only'></div>
<p>✏️ Create <strong>src/services/pmo/favorite/hooks.test.ts</strong> and update it to be:</p>
<pre><code class="language-ts">import { renderHook, waitFor } from &quot;@testing-library/react-native&quot;

import * as storage from &quot;../../storage/storage&quot;
import * as api from &quot;../api/api&quot;

import { useFavorite } from &quot;./hooks&quot;

describe(&quot;Services/PMO/Favorite&quot;, () =&gt; {
  // Mock the apiRequest function
  let apiRequest: jest.SpyInstance&lt;ReturnType&lt;typeof api.apiRequest&gt;&gt;
  let mockStorage: jest.SpyInstance&lt;ReturnType&lt;typeof storage.getData&gt;&gt;
  beforeEach(() =&gt; {
    jest.resetAllMocks()
    apiRequest = jest.spyOn(api, &quot;apiRequest&quot;)
    mockStorage = jest.spyOn(storage, &quot;getData&quot;)
  })

  describe(&quot;useFavorite&quot;, () =&gt; {
    const mockFavorites = [
      {
        userId: &quot;user-id&quot;,
        restaurantId: &quot;WKQjvzup7QWSFXvH&quot;,
        favorite: false,
        datetimeUpdated: &quot;2024-04-03T14:12:16.314Z&quot;,
        _id: &quot;UslYVUxnBuBwqn0s&quot;,
      },
      {
        userId: &quot;user-id&quot;,
        restaurantId: &quot;7iiKc0akJPYzaMyw&quot;,
        favorite: true,
        datetimeUpdated: &quot;2024-04-02T20:16:18.746Z&quot;,
        _id: &quot;dmTvyAYw3o0xjAIk&quot;,
      },
    ]

    beforeEach(() =&gt; {
      jest.clearAllMocks()
    })

    it(&quot;should initialize with the correct default values&quot;, async () =&gt; {
      apiRequest.mockResolvedValue({
        data: { data: mockFavorites },
        error: undefined,
      })
      mockStorage.mockResolvedValue({
        lastSynced: Date.now(),
        favorites: mockFavorites,
      })

      const { result } = renderHook(() =&gt;
        useFavorite(&quot;user-id&quot;, &quot;7iiKc0akJPYzaMyw&quot;),
      )

      await waitFor(() =&gt; {
        expect(result.current.isFavorite).toBe(true)
      })

      expect(result.current.error).toBeUndefined()
      expect(result.current.isPending).toBe(false)
    })

    it(&quot;should set isFavorite to false if the restaurant is not a favorite&quot;, async () =&gt; {
      apiRequest.mockResolvedValue({
        data: { data: mockFavorites },
        error: undefined,
      })
      mockStorage.mockResolvedValue({
        lastSynced: Date.now(),
        favorites: mockFavorites,
      })

      const { result } = renderHook(() =&gt;
        useFavorite(&quot;user-id&quot;, &quot;WKQjvzup7QWSFXvH&quot;),
      )

      await waitFor(() =&gt; {
        expect(result.current.isFavorite).toBe(false)
      })
    })
  })
})

</code></pre>
<div line-highlight='40, 62, only'></div>
<p>✏️ Create <strong>src/services/pmo/favorite/index.ts</strong> and update it to be:</p>
<pre><code class="language-ts">export * from &quot;./hooks&quot;

</code></pre>
<p>✏️ Update <strong>src/screens/RestaurantDetails/RestaurantDetails.tsx</strong> to be:</p>
<pre><code class="language-tsx">import { useNavigation } from &quot;@react-navigation/native&quot;
import { StackScreenProps } from &quot;@react-navigation/stack&quot;
import { useEffect } from &quot;react&quot;

import { RestaurantsStackParamList } from &quot;../../App&quot;
import Loading from &quot;../../components/Loading&quot;
import RestaurantHeader from &quot;../../components/RestaurantHeader&quot;
import Box from &quot;../../design/Box&quot;
import Button from &quot;../../design/Button&quot;
import Screen from &quot;../../design/Screen&quot;
import Typography from &quot;../../design/Typography&quot;
import {
  useAuthenticated,
  useUser,
  useAuthentication,
} from &quot;../../services/auth&quot;
import { useFavorite } from &quot;../../services/pmo/favorite/hooks&quot;
import { useRestaurant } from &quot;../../services/pmo/restaurant&quot;

export interface RestaurantDetailsProps
  extends StackScreenProps&lt;RestaurantsStackParamList, &quot;RestaurantDetails&quot;&gt; {}

const RestaurantDetails: React.FC&lt;RestaurantDetailsProps&gt; = ({ route }) =&gt; {
  const { slug } = route.params
  const navigation = useNavigation()
  const { data: restaurant, error, isPending } = useRestaurant({ slug })

  // Exercise: Add a button that uses the `toggleFavorite` helper.

  useEffect(() =&gt; {
    if (restaurant) {
      navigation.setOptions({ title: `${restaurant.name}` })
    }
  }, [restaurant, navigation])

  if (error) {
    return (
      &lt;Screen&gt;
        &lt;Box padding=&quot;m&quot;&gt;
          &lt;Typography variant=&quot;heading&quot;&gt;
            Error loading restaurant details:{&quot; &quot;}
          &lt;/Typography&gt;
          &lt;Typography variant=&quot;body&quot;&gt;{error.message}&lt;/Typography&gt;
        &lt;/Box&gt;
      &lt;/Screen&gt;
    )
  }

  if (isPending) {
    return &lt;Loading /&gt;
  }

  return (
    &lt;Screen&gt;
      &lt;RestaurantHeader restaurant={restaurant} /&gt;
      {/*
          Exercise:
          - If the user is logged out: Render a button that says “Sign in to favorite this restaurant” and call the `signIn` method.
          - If the user is logged in: Render a button that says “Add to favorites” or “Remove from favorites”, depending on whether the restaurant is a favorite.
          - If a request is pending: Change the button text to “Saving…”.
          - If there’s an error: Render the error message.
        */}

      &lt;Button
        onPress={() =&gt; {
          navigation.navigate(&quot;RestaurantOrder&quot;, { slug: slug })
        }}
      &gt;
        Place an order
      &lt;/Button&gt;
    &lt;/Screen&gt;
  )
}

export default RestaurantDetails

</code></pre>
 <div line-highlight="12-17,28,56-62,only"></div>
<h3>Verify 2</h3>
<p>✏️ Update <strong>src/screens/RestaurantDetails/RestaurantDetails.test.tsx</strong> to be:</p>
<pre><code class="language-tsx">import { NavigationContainer } from &quot;@react-navigation/native&quot;
import { render, screen } from &quot;@testing-library/react-native&quot;

import AuthProvider from &quot;../../services/auth/AuthProvider&quot;
import * as restaurantHooks from &quot;../../services/pmo/restaurant/hooks&quot;

import RestaurantDetails from &quot;./RestaurantDetails&quot;

const route = {
  key: &quot;RestaurantDetails&quot;,
  name: &quot;RestaurantDetails&quot;,
  params: {
    state: {
      name: &quot;name&quot;,
      short: &quot;short&quot;,
    },
    city: {
      name: &quot;name&quot;,
      state: &quot;state&quot;,
    },
    slug: &quot;test&quot;,
  },
} as const

jest.mock(&quot;@react-navigation/native&quot;, () =&gt; {
  const actualNav = jest.requireActual(&quot;@react-navigation/native&quot;)
  return {
    ...actualNav,
    useNavigation: () =&gt; ({
      navigate: jest.fn(),
      setOptions: jest.fn(),
    }),
  }
})

describe(&quot;Screens/RestaurantDetails&quot;, () =&gt; {
  // Mock the hooks and components used in RestaurantDetails

  let useRestaurant: jest.SpyInstance&lt;
    ReturnType&lt;typeof restaurantHooks.useRestaurant&gt;
  &gt;
  beforeEach(() =&gt; {
    jest.resetAllMocks()
    useRestaurant = jest.spyOn(restaurantHooks, &quot;useRestaurant&quot;)
  })

  const mockRestaurantData = {
    data: {
      _id: &quot;1&quot;,
      name: &quot;Test Restaurant&quot;,
      slug: &quot;test-restaurant&quot;,
      images: {
        banner: &quot;banner.jpg&quot;,
        owner: &quot;owner.jpg&quot;,
        thumbnail: &quot;thumbnail.jpg&quot;,
      },
      menu: {
        dinner: [{ name: &quot;yum&quot;, price: 1 }],
        lunch: [{ name: &quot;snack&quot;, price: 2 }],
      },
      coordinate: { latitude: 0, longitude: 0 },
    },
    isPending: false,
    error: undefined,
  }

  it(&quot;renders&quot;, () =&gt; {
    useRestaurant.mockReturnValue(mockRestaurantData)

    render(
      &lt;NavigationContainer&gt;
        &lt;AuthProvider&gt;
          {/* @ts-ignore */}
          &lt;RestaurantDetails route={route} /&gt;
        &lt;/AuthProvider&gt;
      &lt;/NavigationContainer&gt;,
    )

    expect(screen.getByText(&quot;Test Restaurant&quot;)).toBeOnTheScreen()
  })

  it(&quot;renders before data loads&quot;, () =&gt; {
    useRestaurant.mockReturnValue({ ...mockRestaurantData, data: undefined })
    render(
      &lt;NavigationContainer&gt;
        &lt;AuthProvider&gt;
          {/* @ts-ignore */}
          &lt;RestaurantDetails route={route} /&gt;
        &lt;/AuthProvider&gt;
      &lt;/NavigationContainer&gt;,
    )

    expect(screen.getByText(&quot;&quot;)).toBeOnTheScreen()
  })

  it(&quot;renders loading state&quot;, () =&gt; {
    useRestaurant.mockReturnValue({
      data: undefined,
      isPending: true,
      error: undefined,
    })

    render(
      &lt;NavigationContainer&gt;
        &lt;AuthProvider&gt;
          {/* @ts-ignore */}
          &lt;RestaurantDetails route={route} /&gt;
        &lt;/AuthProvider&gt;
      &lt;/NavigationContainer&gt;,
    )

    expect(screen.getByText(/Loading/i)).toBeOnTheScreen()
  })

  it(&quot;renders error state&quot;, () =&gt; {
    useRestaurant.mockReturnValue({
      data: undefined,
      isPending: false,
      error: { name: &quot;Error&quot;, message: &quot;Mock error&quot; },
    })

    render(
      &lt;NavigationContainer&gt;
        &lt;AuthProvider&gt;
          {/* @ts-ignore */}
          &lt;RestaurantDetails route={route} /&gt;
        &lt;/AuthProvider&gt;
      &lt;/NavigationContainer&gt;,
    )

    expect(
      screen.getByText(/Error loading restaurant details:/i, {
        exact: false,
      }),
    ).toBeOnTheScreen()
    expect(screen.getByText(/Mock error/i)).toBeOnTheScreen()
  })
})

</code></pre>
 <div line-highlight="4,72-75,86-89,93,105-108,124-127,only"></div>
<h3>Exercise 2</h3>
<p>In <code>RestaurantDetails</code>, add a button that uses the <code>toggleFavorite</code> helper:</p>
<ul>
<li>If the user is logged out: Render a button that says “Sign in to favorite this restaurant” and call the <code>signIn</code> method.</li>
<li>If the user is logged in: Render a button that says “Add to favorites” or “Remove from favorites”, depending on whether the restaurant is a favorite.</li>
<li>If a request is pending: Change the button text to “Saving…”.</li>
<li>If there’s an error: Render the error message.</li>
</ul>
<h3>Solution 2</h3>
<p>If you’ve implemented the solution correctly, you will be able to sign in and out of your Google account within the application!</p>
<p>You can test the error message by tapping “Sign in” and dismissing the modal.</p>
<p><details>
<summary>Click to see the solution</summary></p>
<p>✏️ Update <strong>src/screens/RestaurantDetails/RestaurantDetails.tsx</strong> to be:</p>
<pre><code class="language-tsx">import { useNavigation } from &quot;@react-navigation/native&quot;
import { StackScreenProps } from &quot;@react-navigation/stack&quot;
import { useEffect } from &quot;react&quot;

import { RestaurantsStackParamList } from &quot;../../App&quot;
import Loading from &quot;../../components/Loading&quot;
import RestaurantHeader from &quot;../../components/RestaurantHeader&quot;
import Box from &quot;../../design/Box&quot;
import Button from &quot;../../design/Button&quot;
import Screen from &quot;../../design/Screen&quot;
import Typography from &quot;../../design/Typography&quot;
import {
  useAuthenticated,
  useUser,
  useAuthentication,
} from &quot;../../services/auth&quot;
import { useFavorite } from &quot;../../services/pmo/favorite/hooks&quot;
import { useRestaurant } from &quot;../../services/pmo/restaurant&quot;

export interface RestaurantDetailsProps
  extends StackScreenProps&lt;RestaurantsStackParamList, &quot;RestaurantDetails&quot;&gt; {}

const RestaurantDetails: React.FC&lt;RestaurantDetailsProps&gt; = ({ route }) =&gt; {
  const { slug } = route.params
  const navigation = useNavigation()
  const { data: restaurant, error, isPending } = useRestaurant({ slug })
  const isAuthenticated = useAuthenticated()
  const user = useUser()
  const { signIn } = useAuthentication()
  const {
    error: favoriteError,
    isFavorite,
    isPending: favoriteIsPending,
    toggleFavorite,
  } = useFavorite(user?.id, restaurant?._id)

  useEffect(() =&gt; {
    if (restaurant) {
      navigation.setOptions({ title: `${restaurant.name}` })
    }
  }, [restaurant, navigation])

  if (error) {
    return (
      &lt;Screen&gt;
        &lt;Box padding=&quot;m&quot;&gt;
          &lt;Typography variant=&quot;heading&quot;&gt;
            Error loading restaurant details:{&quot; &quot;}
          &lt;/Typography&gt;
          &lt;Typography variant=&quot;body&quot;&gt;{error.message}&lt;/Typography&gt;
        &lt;/Box&gt;
      &lt;/Screen&gt;
    )
  }

  if (isPending) {
    return &lt;Loading /&gt;
  }

  return (
    &lt;Screen&gt;
      &lt;RestaurantHeader restaurant={restaurant} /&gt;
      &lt;Button
        onPress={() =&gt; {
          if (isAuthenticated) {
            toggleFavorite()
          } else {
            signIn()
          }
        }}
      &gt;
        {isAuthenticated
          ? favoriteIsPending
            ? &quot;Saving…&quot;
            : isFavorite
            ? &quot;Remove from favorites&quot;
            : &quot;Add to favorites&quot;
          : &quot;Sign in to favorite this restaurant&quot;}
      &lt;/Button&gt;
      {favoriteError ? (
        &lt;Box padding=&quot;s&quot;&gt;
          &lt;Typography variant=&quot;body&quot;&gt;{favoriteError.message}&lt;/Typography&gt;
        &lt;/Box&gt;
      ) : null}

      &lt;Button
        onPress={() =&gt; {
          navigation.navigate(&quot;RestaurantOrder&quot;, { slug: slug })
        }}
      &gt;
        Place an order
      &lt;/Button&gt;
    &lt;/Screen&gt;
  )
}

export default RestaurantDetails

</code></pre>
 <div line-highlight="27-35,65-69,72-78,80-84,86-87,89-90,92,only"></div>
<p></details></p>
<h2>Objective 3: Sync offline data when connectivity changes</h2>
<p>Our app can handle when the API calls fail and it’ll still store the favorites on device in Async Storage.
When the user’s device is offline, we can improve the app a lot by syncing the favorites to the API when the device comes back online.</p>
<h3>Designing the sync behavior</h3>
<p>Here’s an overview of how we want our sync to work.</p>
<p>If a favorite is modified:</p>
<ul>
<li>By another device while our current device is offline, our device should fetch those changes when it comes back online.</li>
<li>On our current device while it’s offline, that change should be synced back to the API as soon as the device comes online.</li>
<li>In both places (in the API and on the device), the data with the last modified date should “win.”</li>
</ul>
<h3>Fetching the favorites modified on the server</h3>
<p>The Hook’s <code>syncWithServer</code> will first fetch the favorites from the server:</p>
<pre><code class="language-ts">import { getData, storeData } from &quot;../../storage&quot;
import { apiRequest } from &quot;../api&quot;

import {
  Favorite,
  FavoriteResponse,
  FavoritesResponse,
  StoredFavorites,
} from &quot;./interfaces&quot;

export const syncWithServer = async (userId: string): Promise&lt;void&gt; =&gt; {
  // Fetch the list of favorites from the server.
  const { data: apiResponse } = await apiRequest&lt;FavoritesResponse&gt;({
    method: &quot;GET&quot;,
    path: &quot;/favorites&quot;,
    params: {
      userId: userId,
    },
  })

  // Get the list of favorites in storage.
  const favoriteRestaurants = await getData&lt;StoredFavorites&gt;(
    &quot;favorite-restaurants&quot;,
  )

  // Create an Object with the restaurantId as the key and full Favorite as the value.
  const favoriteRestaurantMap: { [key: string]: Favorite } = {}
  if (favoriteRestaurants &amp;&amp; favoriteRestaurants.favorites) {
    favoriteRestaurants.favorites.forEach((storedFavorite) =&gt; {
      favoriteRestaurantMap[storedFavorite.restaurantId] = storedFavorite
    })
  }

  if (apiResponse &amp;&amp; apiResponse.data) {
    // Iterate through the list of favorites returned by the server:
    const favoritesUpdatedOnServer = apiResponse.data.filter((apiFavorite) =&gt; {
      const storedFavorite = favoriteRestaurantMap[apiFavorite.restaurantId]
      // If the server datetimeUpdated is later than the datetimeUpdated in storage, or if the favorite is not in storage:
      const serverDatetimeIsLaterThanStorage = storedFavorite
        ? apiFavorite.datetimeUpdated &gt; storedFavorite.datetimeUpdated
        : true
      return serverDatetimeIsLaterThanStorage
    })

    const idsOfFavoritesUpdatedOnServer = favoritesUpdatedOnServer.map(
      (apiFavorite) =&gt; {
        if (favoriteRestaurantMap[apiFavorite.restaurantId]) {
          // Update the object that came from storage.
          favoriteRestaurantMap[apiFavorite.restaurantId]._id = apiFavorite._id
          favoriteRestaurantMap[apiFavorite.restaurantId].datetimeUpdated =
            apiFavorite.datetimeUpdated
          favoriteRestaurantMap[apiFavorite.restaurantId].favorite =
            apiFavorite.favorite
        } else {
          // Create the favorite in the map; this will be added to storage later.
          favoriteRestaurantMap[apiFavorite.restaurantId] = apiFavorite
        }

        // Keep this in an array/set to reference below…
        return apiFavorite._id
      },
    )

    // Query storage for favorites updated since the lastSynced datetime:
    const favoritesUpdatedWhileOffline =
      favoriteRestaurants?.favorites.filter((storedFavorite) =&gt; {
        const favoriteUpdatedSinceLastSync =
          storedFavorite.datetimeUpdated &gt; favoriteRestaurants?.lastSynced
        return favoriteUpdatedSinceLastSync
      }) || []

    // If the favorite isn’t in the array/set created above
    const favoritesToUpdateOnServer = favoritesUpdatedWhileOffline.filter(
      (storedFavorite) =&gt; {
        const storedFavoriteIsMoreRecentThanServer =
          idsOfFavoritesUpdatedOnServer.includes(storedFavorite._id) === false
        return storedFavoriteIsMoreRecentThanServer
      },
    )

    // Call the API to update the favorite
    favoritesToUpdateOnServer.map(async (storedFavorite) =&gt; {
      const { data: updateFavoritesResponse } =
        await apiRequest&lt;FavoriteResponse&gt;({
          method: &quot;POST&quot;,
          path: &quot;/favorites&quot;,
          body: storedFavorite,
        })

      // Update the object that will be stored:
      if (updateFavoritesResponse &amp;&amp; updateFavoritesResponse.data) {
        favoriteRestaurantMap[storedFavorite.restaurantId] =
          updateFavoritesResponse.data
      }
    })

    // Update the lastSynced datetime in storage
    const updatedFavoriteRestaurants = {
      favorites: [] as Favorite[],
      lastSynced: Date.now(),
    }
    for (const restaurantId in favoriteRestaurantMap) {
      const favoriteRestaurant = favoriteRestaurantMap[restaurantId]
      updatedFavoriteRestaurants.favorites.push(favoriteRestaurant)
    }

    // Update the stored data.
    await storeData&lt;StoredFavorites&gt;(
      &quot;favorite-restaurants&quot;,
      updatedFavoriteRestaurants,
    )
  }
}

</code></pre>
<div line-highlight='12-19, only'></div>
<h3>Updating favorites modified on the device</h3>
<p>Next, the Hook will send any favorites that were modified while the device was offline to the API:</p>
<pre><code class="language-ts">import { getData, storeData } from &quot;../../storage&quot;
import { apiRequest } from &quot;../api&quot;

import {
  Favorite,
  FavoriteResponse,
  FavoritesResponse,
  StoredFavorites,
} from &quot;./interfaces&quot;

export const syncWithServer = async (userId: string): Promise&lt;void&gt; =&gt; {
  // Fetch the list of favorites from the server.
  const { data: apiResponse } = await apiRequest&lt;FavoritesResponse&gt;({
    method: &quot;GET&quot;,
    path: &quot;/favorites&quot;,
    params: {
      userId: userId,
    },
  })

  // Get the list of favorites in storage.
  const favoriteRestaurants = await getData&lt;StoredFavorites&gt;(
    &quot;favorite-restaurants&quot;,
  )

  // Create an Object with the restaurantId as the key and full Favorite as the value.
  const favoriteRestaurantMap: { [key: string]: Favorite } = {}
  if (favoriteRestaurants &amp;&amp; favoriteRestaurants.favorites) {
    favoriteRestaurants.favorites.forEach((storedFavorite) =&gt; {
      favoriteRestaurantMap[storedFavorite.restaurantId] = storedFavorite
    })
  }

  if (apiResponse &amp;&amp; apiResponse.data) {
    // Iterate through the list of favorites returned by the server:
    const favoritesUpdatedOnServer = apiResponse.data.filter((apiFavorite) =&gt; {
      const storedFavorite = favoriteRestaurantMap[apiFavorite.restaurantId]
      // If the server datetimeUpdated is later than the datetimeUpdated in storage, or if the favorite is not in storage:
      const serverDatetimeIsLaterThanStorage = storedFavorite
        ? apiFavorite.datetimeUpdated &gt; storedFavorite.datetimeUpdated
        : true
      return serverDatetimeIsLaterThanStorage
    })

    const idsOfFavoritesUpdatedOnServer = favoritesUpdatedOnServer.map(
      (apiFavorite) =&gt; {
        if (favoriteRestaurantMap[apiFavorite.restaurantId]) {
          // Update the object that came from storage.
          favoriteRestaurantMap[apiFavorite.restaurantId]._id = apiFavorite._id
          favoriteRestaurantMap[apiFavorite.restaurantId].datetimeUpdated =
            apiFavorite.datetimeUpdated
          favoriteRestaurantMap[apiFavorite.restaurantId].favorite =
            apiFavorite.favorite
        } else {
          // Create the favorite in the map; this will be added to storage later.
          favoriteRestaurantMap[apiFavorite.restaurantId] = apiFavorite
        }

        // Keep this in an array/set to reference below…
        return apiFavorite._id
      },
    )

    // Query storage for favorites updated since the lastSynced datetime:
    const favoritesUpdatedWhileOffline =
      favoriteRestaurants?.favorites.filter((storedFavorite) =&gt; {
        const favoriteUpdatedSinceLastSync =
          storedFavorite.datetimeUpdated &gt; favoriteRestaurants?.lastSynced
        return favoriteUpdatedSinceLastSync
      }) || []

    // If the favorite isn’t in the array/set created above
    const favoritesToUpdateOnServer = favoritesUpdatedWhileOffline.filter(
      (storedFavorite) =&gt; {
        const storedFavoriteIsMoreRecentThanServer =
          idsOfFavoritesUpdatedOnServer.includes(storedFavorite._id) === false
        return storedFavoriteIsMoreRecentThanServer
      },
    )

    // Call the API to update the favorite
    favoritesToUpdateOnServer.map(async (storedFavorite) =&gt; {
      const { data: updateFavoritesResponse } =
        await apiRequest&lt;FavoriteResponse&gt;({
          method: &quot;POST&quot;,
          path: &quot;/favorites&quot;,
          body: storedFavorite,
        })

      // Update the object that will be stored:
      if (updateFavoritesResponse &amp;&amp; updateFavoritesResponse.data) {
        favoriteRestaurantMap[storedFavorite.restaurantId] =
          updateFavoritesResponse.data
      }
    })

    // Update the lastSynced datetime in storage
    const updatedFavoriteRestaurants = {
      favorites: [] as Favorite[],
      lastSynced: Date.now(),
    }
    for (const restaurantId in favoriteRestaurantMap) {
      const favoriteRestaurant = favoriteRestaurantMap[restaurantId]
      updatedFavoriteRestaurants.favorites.push(favoriteRestaurant)
    }

    // Update the stored data.
    await storeData&lt;StoredFavorites&gt;(
      &quot;favorite-restaurants&quot;,
      updatedFavoriteRestaurants,
    )
  }
}

</code></pre>
<div line-highlight='81-95, only'></div>
<h3>Updating storage with the changes</h3>
<p>Last, the Hook will update Async Storage with all the changes that have accumulated through the sync process:</p>
<pre><code class="language-ts">import { getData, storeData } from &quot;../../storage&quot;
import { apiRequest } from &quot;../api&quot;

import {
  Favorite,
  FavoriteResponse,
  FavoritesResponse,
  StoredFavorites,
} from &quot;./interfaces&quot;

export const syncWithServer = async (userId: string): Promise&lt;void&gt; =&gt; {
  // Fetch the list of favorites from the server.
  const { data: apiResponse } = await apiRequest&lt;FavoritesResponse&gt;({
    method: &quot;GET&quot;,
    path: &quot;/favorites&quot;,
    params: {
      userId: userId,
    },
  })

  // Get the list of favorites in storage.
  const favoriteRestaurants = await getData&lt;StoredFavorites&gt;(
    &quot;favorite-restaurants&quot;,
  )

  // Create an Object with the restaurantId as the key and full Favorite as the value.
  const favoriteRestaurantMap: { [key: string]: Favorite } = {}
  if (favoriteRestaurants &amp;&amp; favoriteRestaurants.favorites) {
    favoriteRestaurants.favorites.forEach((storedFavorite) =&gt; {
      favoriteRestaurantMap[storedFavorite.restaurantId] = storedFavorite
    })
  }

  if (apiResponse &amp;&amp; apiResponse.data) {
    // Iterate through the list of favorites returned by the server:
    const favoritesUpdatedOnServer = apiResponse.data.filter((apiFavorite) =&gt; {
      const storedFavorite = favoriteRestaurantMap[apiFavorite.restaurantId]
      // If the server datetimeUpdated is later than the datetimeUpdated in storage, or if the favorite is not in storage:
      const serverDatetimeIsLaterThanStorage = storedFavorite
        ? apiFavorite.datetimeUpdated &gt; storedFavorite.datetimeUpdated
        : true
      return serverDatetimeIsLaterThanStorage
    })

    const idsOfFavoritesUpdatedOnServer = favoritesUpdatedOnServer.map(
      (apiFavorite) =&gt; {
        if (favoriteRestaurantMap[apiFavorite.restaurantId]) {
          // Update the object that came from storage.
          favoriteRestaurantMap[apiFavorite.restaurantId]._id = apiFavorite._id
          favoriteRestaurantMap[apiFavorite.restaurantId].datetimeUpdated =
            apiFavorite.datetimeUpdated
          favoriteRestaurantMap[apiFavorite.restaurantId].favorite =
            apiFavorite.favorite
        } else {
          // Create the favorite in the map; this will be added to storage later.
          favoriteRestaurantMap[apiFavorite.restaurantId] = apiFavorite
        }

        // Keep this in an array/set to reference below…
        return apiFavorite._id
      },
    )

    // Query storage for favorites updated since the lastSynced datetime:
    const favoritesUpdatedWhileOffline =
      favoriteRestaurants?.favorites.filter((storedFavorite) =&gt; {
        const favoriteUpdatedSinceLastSync =
          storedFavorite.datetimeUpdated &gt; favoriteRestaurants?.lastSynced
        return favoriteUpdatedSinceLastSync
      }) || []

    // If the favorite isn’t in the array/set created above
    const favoritesToUpdateOnServer = favoritesUpdatedWhileOffline.filter(
      (storedFavorite) =&gt; {
        const storedFavoriteIsMoreRecentThanServer =
          idsOfFavoritesUpdatedOnServer.includes(storedFavorite._id) === false
        return storedFavoriteIsMoreRecentThanServer
      },
    )

    // Call the API to update the favorite
    favoritesToUpdateOnServer.map(async (storedFavorite) =&gt; {
      const { data: updateFavoritesResponse } =
        await apiRequest&lt;FavoriteResponse&gt;({
          method: &quot;POST&quot;,
          path: &quot;/favorites&quot;,
          body: storedFavorite,
        })

      // Update the object that will be stored:
      if (updateFavoritesResponse &amp;&amp; updateFavoritesResponse.data) {
        favoriteRestaurantMap[storedFavorite.restaurantId] =
          updateFavoritesResponse.data
      }
    })

    // Update the lastSynced datetime in storage
    const updatedFavoriteRestaurants = {
      favorites: [] as Favorite[],
      lastSynced: Date.now(),
    }
    for (const restaurantId in favoriteRestaurantMap) {
      const favoriteRestaurant = favoriteRestaurantMap[restaurantId]
      updatedFavoriteRestaurants.favorites.push(favoriteRestaurant)
    }

    // Update the stored data.
    await storeData&lt;StoredFavorites&gt;(
      &quot;favorite-restaurants&quot;,
      updatedFavoriteRestaurants,
    )
  }
}

</code></pre>
<div line-highlight='97-111, only'></div>
<h3>Setup 3</h3>
<p>✏️ Update <strong>src/App.tsx</strong> to be:</p>
<pre><code class="language-tsx">import { createBottomTabNavigator } from &quot;@react-navigation/bottom-tabs&quot;
import { NavigationContainer } from &quot;@react-navigation/native&quot;
import { createStackNavigator } from &quot;@react-navigation/stack&quot;
import { Pressable } from &quot;react-native&quot;
import { SafeAreaView } from &quot;react-native-safe-area-context&quot;
import Icon from &quot;react-native-vector-icons/Ionicons&quot;

import Box from &quot;./design/Box&quot;
import ThemeProvider, { useTheme } from &quot;./design/theme/ThemeProvider&quot;
import Typography from &quot;./design/Typography&quot;
import CityList from &quot;./screens/CityList&quot;
import RestaurantDetails from &quot;./screens/RestaurantDetails&quot;
import RestaurantList from &quot;./screens/RestaurantList&quot;
import RestaurantOrder from &quot;./screens/RestaurantOrder&quot;
import Settings from &quot;./screens/Settings&quot;
import StateList from &quot;./screens/StateList&quot;
import AuthProvider from &quot;./services/auth/AuthProvider&quot;
import DataMigration from &quot;./services/DataMigration&quot;
import FavoritesSync from &quot;./services/pmo/favorite&quot;

declare global {
  // eslint-disable-next-line @typescript-eslint/no-namespace
  namespace ReactNavigation {
    // eslint-disable-next-line @typescript-eslint/no-empty-interface
    interface RootParamList extends RestaurantsStackParamList {}
  }
}

export type RestaurantsStackParamList = {
  StateList: undefined
  CityList: {
    state: {
      name: string
      short: string
    }
  }
  RestaurantList: {
    state: {
      name: string
      short: string
    }
    city: {
      name: string
      state: string
    }
  }
  RestaurantDetails: {
    slug: string
  }
  RestaurantOrder: {
    slug: string
  }
}

const RestaurantsStack = createStackNavigator&lt;RestaurantsStackParamList&gt;()
const RestaurantsNavigator: React.FC = () =&gt; {
  return (
    &lt;RestaurantsStack.Navigator
      initialRouteName=&quot;StateList&quot;
      screenOptions={{
        header: ({ route, navigation }) =&gt; {
          if (!navigation.canGoBack()) return null

          return (
            &lt;Pressable onPress={navigation.goBack}&gt;
              &lt;Box
                padding=&quot;m&quot;
                style={{ flexDirection: &quot;row&quot;, gap: 8, alignItems: &quot;center&quot; }}
              &gt;
                &lt;Icon name=&quot;arrow-back&quot; size={20} /&gt;
                &lt;Typography variant=&quot;heading&quot;&gt;
                  {/* @ts-ignore */}
                  {[route.params?.city?.name, route.params?.state?.name]
                    .filter(Boolean)
                    .join(&quot;, &quot;)}
                &lt;/Typography&gt;
              &lt;/Box&gt;
            &lt;/Pressable&gt;
          )
        },
      }}
    &gt;
      &lt;RestaurantsStack.Screen name=&quot;StateList&quot; component={StateList} /&gt;
      &lt;RestaurantsStack.Screen name=&quot;CityList&quot; component={CityList} /&gt;
      &lt;RestaurantsStack.Screen
        name=&quot;RestaurantList&quot;
        component={RestaurantList}
      /&gt;
      &lt;RestaurantsStack.Screen
        name=&quot;RestaurantDetails&quot;
        component={RestaurantDetails}
      /&gt;
      &lt;RestaurantsStack.Screen
        name=&quot;RestaurantOrder&quot;
        component={RestaurantOrder}
      /&gt;
    &lt;/RestaurantsStack.Navigator&gt;
  )
}

const AppTabs = createBottomTabNavigator()
const AppNavigator: React.FC = () =&gt; {
  const theme = useTheme()

  return (
    &lt;AppTabs.Navigator
      initialRouteName=&quot;RestaurantsStack&quot;
      screenOptions={({ route }) =&gt; ({
        headerStyle: {
          backgroundColor: theme.palette.screen.main,
        },
        headerTitleStyle: {
          color: theme.palette.screen.contrast,
          ...theme.typography.title,
        },
        tabBarStyle: {
          backgroundColor: theme.palette.screen.main,
        },
        tabBarActiveTintColor: theme.palette.primary.strong,
        tabBarInactiveTintColor: theme.palette.screen.contrast,
        tabBarIcon: ({ focused, color }) =&gt; {
          let icon = &quot;settings&quot;
          if (route.name === &quot;Settings&quot;) {
            icon = focused ? &quot;settings&quot; : &quot;settings-outline&quot;
          } else if (route.name === &quot;Restaurants&quot;) {
            icon = focused ? &quot;restaurant&quot; : &quot;restaurant-outline&quot;
          }

          return &lt;Icon name={icon} size={20} color={color} /&gt;
        },
      })}
    &gt;
      &lt;AppTabs.Screen
        name=&quot;Restaurants&quot;
        component={RestaurantsNavigator}
        options={{ title: &quot;Place My Order&quot; }}
      /&gt;
      &lt;AppTabs.Screen
        name=&quot;Settings&quot;
        component={Settings}
        options={{ title: &quot;Settings&quot; }}
      /&gt;
    &lt;/AppTabs.Navigator&gt;
  )
}

// Exercise: Add the `FavoritesSync` component to the `App` JSX.
const App: React.FC = () =&gt; {
  return (
    &lt;SafeAreaView style={{ flex: 1 }}&gt;
      &lt;ThemeProvider&gt;
        &lt;AuthProvider&gt;
          &lt;DataMigration&gt;
            &lt;NavigationContainer&gt;
              &lt;AppNavigator /&gt;
            &lt;/NavigationContainer&gt;
          &lt;/DataMigration&gt;
        &lt;/AuthProvider&gt;
      &lt;/ThemeProvider&gt;
    &lt;/SafeAreaView&gt;
  )
}

export default App

</code></pre>
 <div line-highlight="19,147,only"></div>
<p>✏️ Create <strong>src/services/pmo/favorite/favorite.tsx</strong> and update it to be:</p>
<pre><code class="language-tsx">import { useNetInfo } from &quot;@react-native-community/netinfo&quot;
import { useEffect } from &quot;react&quot;

import { useUser } from &quot;../../auth&quot;

import { syncWithServer } from &quot;./sync&quot;

const FavoritesSync: React.FC = () =&gt; {
  // Exercise: When the user is signed in and has a network connection, sync with the server.

  return null
}

export default FavoritesSync

</code></pre>
<div line-highlight='9, only'></div>
<p>✏️ Create <strong>src/services/pmo/favorite/sync.ts</strong> and update it to be:</p>
<pre><code class="language-ts">import { getData, storeData } from &quot;../../storage&quot;
import { apiRequest } from &quot;../api&quot;

import {
  Favorite,
  FavoriteResponse,
  FavoritesResponse,
  StoredFavorites,
} from &quot;./interfaces&quot;

export const syncWithServer = async (userId: string): Promise&lt;void&gt; =&gt; {
  // Fetch the list of favorites from the server.
  const { data: apiResponse } = await apiRequest&lt;FavoritesResponse&gt;({
    method: &quot;GET&quot;,
    path: &quot;/favorites&quot;,
    params: {
      userId: userId,
    },
  })

  // Get the list of favorites in storage.
  const favoriteRestaurants = await getData&lt;StoredFavorites&gt;(
    &quot;favorite-restaurants&quot;,
  )

  // Create an Object with the restaurantId as the key and full Favorite as the value.
  const favoriteRestaurantMap: { [key: string]: Favorite } = {}
  if (favoriteRestaurants &amp;&amp; favoriteRestaurants.favorites) {
    favoriteRestaurants.favorites.forEach((storedFavorite) =&gt; {
      favoriteRestaurantMap[storedFavorite.restaurantId] = storedFavorite
    })
  }

  if (apiResponse &amp;&amp; apiResponse.data) {
    // Iterate through the list of favorites returned by the server:
    const favoritesUpdatedOnServer = apiResponse.data.filter((apiFavorite) =&gt; {
      const storedFavorite = favoriteRestaurantMap[apiFavorite.restaurantId]
      // If the server datetimeUpdated is later than the datetimeUpdated in storage, or if the favorite is not in storage:
      const serverDatetimeIsLaterThanStorage = storedFavorite
        ? apiFavorite.datetimeUpdated &gt; storedFavorite.datetimeUpdated
        : true
      return serverDatetimeIsLaterThanStorage
    })

    const idsOfFavoritesUpdatedOnServer = favoritesUpdatedOnServer.map(
      (apiFavorite) =&gt; {
        if (favoriteRestaurantMap[apiFavorite.restaurantId]) {
          // Update the object that came from storage.
          favoriteRestaurantMap[apiFavorite.restaurantId]._id = apiFavorite._id
          favoriteRestaurantMap[apiFavorite.restaurantId].datetimeUpdated =
            apiFavorite.datetimeUpdated
          favoriteRestaurantMap[apiFavorite.restaurantId].favorite =
            apiFavorite.favorite
        } else {
          // Create the favorite in the map; this will be added to storage later.
          favoriteRestaurantMap[apiFavorite.restaurantId] = apiFavorite
        }

        // Keep this in an array/set to reference below…
        return apiFavorite._id
      },
    )

    // Query storage for favorites updated since the lastSynced datetime:
    const favoritesUpdatedWhileOffline =
      favoriteRestaurants?.favorites.filter((storedFavorite) =&gt; {
        const favoriteUpdatedSinceLastSync =
          storedFavorite.datetimeUpdated &gt; favoriteRestaurants?.lastSynced
        return favoriteUpdatedSinceLastSync
      }) || []

    // If the favorite isn’t in the array/set created above
    const favoritesToUpdateOnServer = favoritesUpdatedWhileOffline.filter(
      (storedFavorite) =&gt; {
        const storedFavoriteIsMoreRecentThanServer =
          idsOfFavoritesUpdatedOnServer.includes(storedFavorite._id) === false
        return storedFavoriteIsMoreRecentThanServer
      },
    )

    // Call the API to update the favorite
    favoritesToUpdateOnServer.map(async (storedFavorite) =&gt; {
      const { data: updateFavoritesResponse } =
        await apiRequest&lt;FavoriteResponse&gt;({
          method: &quot;POST&quot;,
          path: &quot;/favorites&quot;,
          body: storedFavorite,
        })

      // Update the object that will be stored:
      if (updateFavoritesResponse &amp;&amp; updateFavoritesResponse.data) {
        favoriteRestaurantMap[storedFavorite.restaurantId] =
          updateFavoritesResponse.data
      }
    })

    // Update the lastSynced datetime in storage
    const updatedFavoriteRestaurants = {
      favorites: [] as Favorite[],
      lastSynced: Date.now(),
    }
    for (const restaurantId in favoriteRestaurantMap) {
      const favoriteRestaurant = favoriteRestaurantMap[restaurantId]
      updatedFavoriteRestaurants.favorites.push(favoriteRestaurant)
    }

    // Update the stored data.
    await storeData&lt;StoredFavorites&gt;(
      &quot;favorite-restaurants&quot;,
      updatedFavoriteRestaurants,
    )
  }
}

</code></pre>
<div line-highlight='11, only'></div>
<p>✏️ Update <strong>src/services/pmo/favorite/index.ts</strong> to be:</p>
<pre><code class="language-ts">export { default } from &quot;./favorite&quot;
export * from &quot;./hooks&quot;
export * from &quot;./sync&quot;

</code></pre>
 <div line-highlight="1,3,only"></div>
<h3>Verify 3</h3>
<p>Use the <code>console</code> or debugger to check the <code>syncWithServer</code> function is called when signing in and out.</p>
<h3>Exercise 3</h3>
<ul>
<li>Create a <code>FavoritesSync</code> component that does the following:
<ul>
<li>When the user is signed in and has a network connection, sync with the server.</li>
</ul></li>
<li>Add the <code>FavoritesSync</code> component to the <code>App</code> JSX.</li>
</ul>
<p><strong>Hint:</strong> Use all of the imports provided in the <code>favorite.tsx</code> file.</p>
<h3>Solution 3</h3>
<p><details>
<summary>Click to see the solution</summary></p>
<p>✏️ Update <strong>src/services/pmo/favorite/favorite.tsx</strong> to be:</p>
<pre><code class="language-tsx">import { useNetInfo } from &quot;@react-native-community/netinfo&quot;
import { useEffect } from &quot;react&quot;

import { useUser } from &quot;../../auth&quot;

import { syncWithServer } from &quot;./sync&quot;

const FavoritesSync: React.FC = () =&gt; {
  const { isConnected } = useNetInfo()
  const user = useUser()

  useEffect(() =&gt; {
    async function syncData() {
      if (isConnected &amp;&amp; user) {
        await syncWithServer(user.id)
      }
    }
    syncData()
  }, [isConnected, user])

  return null
}

export default FavoritesSync

</code></pre>
 <div line-highlight="9-10,12-19,only"></div>
<p>✏️ Update <strong>src/App.tsx</strong> to be:</p>
<pre><code class="language-tsx">import { createBottomTabNavigator } from &quot;@react-navigation/bottom-tabs&quot;
import { NavigationContainer } from &quot;@react-navigation/native&quot;
import { createStackNavigator } from &quot;@react-navigation/stack&quot;
import { Pressable } from &quot;react-native&quot;
import { SafeAreaView } from &quot;react-native-safe-area-context&quot;
import Icon from &quot;react-native-vector-icons/Ionicons&quot;

import Box from &quot;./design/Box&quot;
import ThemeProvider, { useTheme } from &quot;./design/theme/ThemeProvider&quot;
import Typography from &quot;./design/Typography&quot;
import CityList from &quot;./screens/CityList&quot;
import RestaurantDetails from &quot;./screens/RestaurantDetails&quot;
import RestaurantList from &quot;./screens/RestaurantList&quot;
import RestaurantOrder from &quot;./screens/RestaurantOrder&quot;
import Settings from &quot;./screens/Settings&quot;
import StateList from &quot;./screens/StateList&quot;
import AuthProvider from &quot;./services/auth/AuthProvider&quot;
import DataMigration from &quot;./services/DataMigration&quot;
import FavoritesSync from &quot;./services/pmo/favorite&quot;

declare global {
  // eslint-disable-next-line @typescript-eslint/no-namespace
  namespace ReactNavigation {
    // eslint-disable-next-line @typescript-eslint/no-empty-interface
    interface RootParamList extends RestaurantsStackParamList {}
  }
}

export type RestaurantsStackParamList = {
  StateList: undefined
  CityList: {
    state: {
      name: string
      short: string
    }
  }
  RestaurantList: {
    state: {
      name: string
      short: string
    }
    city: {
      name: string
      state: string
    }
  }
  RestaurantDetails: {
    slug: string
  }
  RestaurantOrder: {
    slug: string
  }
}

const RestaurantsStack = createStackNavigator&lt;RestaurantsStackParamList&gt;()
const RestaurantsNavigator: React.FC = () =&gt; {
  return (
    &lt;RestaurantsStack.Navigator
      initialRouteName=&quot;StateList&quot;
      screenOptions={{
        header: ({ route, navigation }) =&gt; {
          if (!navigation.canGoBack()) return null

          return (
            &lt;Pressable onPress={navigation.goBack}&gt;
              &lt;Box
                padding=&quot;m&quot;
                style={{ flexDirection: &quot;row&quot;, gap: 8, alignItems: &quot;center&quot; }}
              &gt;
                &lt;Icon name=&quot;arrow-back&quot; size={20} /&gt;
                &lt;Typography variant=&quot;heading&quot;&gt;
                  {/* @ts-ignore */}
                  {[route.params?.city?.name, route.params?.state?.name]
                    .filter(Boolean)
                    .join(&quot;, &quot;)}
                &lt;/Typography&gt;
              &lt;/Box&gt;
            &lt;/Pressable&gt;
          )
        },
      }}
    &gt;
      &lt;RestaurantsStack.Screen name=&quot;StateList&quot; component={StateList} /&gt;
      &lt;RestaurantsStack.Screen name=&quot;CityList&quot; component={CityList} /&gt;
      &lt;RestaurantsStack.Screen
        name=&quot;RestaurantList&quot;
        component={RestaurantList}
      /&gt;
      &lt;RestaurantsStack.Screen
        name=&quot;RestaurantDetails&quot;
        component={RestaurantDetails}
      /&gt;
      &lt;RestaurantsStack.Screen
        name=&quot;RestaurantOrder&quot;
        component={RestaurantOrder}
      /&gt;
    &lt;/RestaurantsStack.Navigator&gt;
  )
}

const AppTabs = createBottomTabNavigator()
const AppNavigator: React.FC = () =&gt; {
  const theme = useTheme()

  return (
    &lt;AppTabs.Navigator
      initialRouteName=&quot;RestaurantsStack&quot;
      screenOptions={({ route }) =&gt; ({
        headerStyle: {
          backgroundColor: theme.palette.screen.main,
        },
        headerTitleStyle: {
          color: theme.palette.screen.contrast,
          ...theme.typography.title,
        },
        tabBarStyle: {
          backgroundColor: theme.palette.screen.main,
        },
        tabBarActiveTintColor: theme.palette.primary.strong,
        tabBarInactiveTintColor: theme.palette.screen.contrast,
        tabBarIcon: ({ focused, color }) =&gt; {
          let icon = &quot;settings&quot;
          if (route.name === &quot;Settings&quot;) {
            icon = focused ? &quot;settings&quot; : &quot;settings-outline&quot;
          } else if (route.name === &quot;Restaurants&quot;) {
            icon = focused ? &quot;restaurant&quot; : &quot;restaurant-outline&quot;
          }

          return &lt;Icon name={icon} size={20} color={color} /&gt;
        },
      })}
    &gt;
      &lt;AppTabs.Screen
        name=&quot;Restaurants&quot;
        component={RestaurantsNavigator}
        options={{ title: &quot;Place My Order&quot; }}
      /&gt;
      &lt;AppTabs.Screen
        name=&quot;Settings&quot;
        component={Settings}
        options={{ title: &quot;Settings&quot; }}
      /&gt;
    &lt;/AppTabs.Navigator&gt;
  )
}

const App: React.FC = () =&gt; {
  return (
    &lt;SafeAreaView style={{ flex: 1 }}&gt;
      &lt;ThemeProvider&gt;
        &lt;AuthProvider&gt;
          &lt;DataMigration&gt;
            &lt;NavigationContainer&gt;
              &lt;AppNavigator /&gt;
            &lt;/NavigationContainer&gt;
            &lt;FavoritesSync /&gt;
          &lt;/DataMigration&gt;
        &lt;/AuthProvider&gt;
      &lt;/ThemeProvider&gt;
    &lt;/SafeAreaView&gt;
  )
}

export default App

</code></pre>
 <div line-highlight="156,only"></div>
<p></details></p>
<h2>Next steps</h2>
<p>Next, we will learn about <a href="google-maps.html" title="Learn how to integrate Google Maps into your React Native application.">Integrating Maps</a> to our application.</p>

</section>

  			
  			<bit-prev-next class="footer" list-selector=".sidebar-left ul li.parent.expanded ul"></bit-prev-next>
  		
    </div>

    
      <div class="sidebar-right">
        <div class="content-nav on-this-page-container">
          <h6>On this page...</h6>
          <div class="list-items" id="scroll-toc">
            <bit-toc heading-container-selector="article.main" scroll-selector="#scroll-toc"></bit-toc>
          </div>
        </div>
        <div class="pullout discord">
          <h6>Get help</h6>
          <p>If you need <a href="https://discord.gg/J7ejFsZnJ4">help</a> with an exercise, please reach out to us on
             <a href="https://discord.gg/J7ejFsZnJ4">Discord</a></p>
        </div>
        <div class="pullout bug">
          <p>If you find a bug, please
             <a href="https://github.com/bitovi/academy/issues/new">create an issue</a> or email
             <a href="mailto:contact@bitovi.com?Subject=Training%20Suggestion" target="_blank">contact@bitovi.com</a></p>
        </div>
      </div>
    

	</article>
</div>



  <footer></footer>

  <div id="scripts">
    <script type="text/javascript">
      var docObject = {"src":{"path":"src/react-native/17-offline-support/offline-support.md"},"description":"Learn device-first strategies for storing data and syncing it to a server. \n","name":"learn-react-native/offline-support","title":"Adding Offline Support","type":"page","parent":"learn-react-native","order":17,"outline":{"depth":3},"comment":" ","pathToRoot":"../.."};
    </script>

    
      <script>
        steal = {
          instantiated: {
            "bundles/bit-docs-site/static.css!$css" : null
          }
        }
      </script>
      <script type='text/javascript'
          data-main="bit-docs-site/static"
          src="../static/steal.production.js"></script>
    

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-2302003-12"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-2302003-12');
    </script>

  </div>
  <div id="email-modal" role="dialog" aria-modal="true" aria-labelledby="dialog_label" style="display: none;">
    <div aria-hidden="true" class="email-modal-backdrop"></div>
    <div role="region" class="email-modal-content">
      <h2 id="dialog_label">Join the Bitovi Newsletter</h2>
      <p>
        Do you want to receive updates about new Bitovi Academy courses, Bitovi open source projects, and dev community news? If so, please provide your email. We won’t spam you or give it away for any reason!<br />
        <i style="font-size: 0.8rem;">By providing your email you agree to receive communications from Bitovi</i>
      </p>
      <div id="academy-hubspot-form-embed"></div>
      <script charset="utf-8" type="text/javascript" src="//js.hsforms.net/forms/embed/v2.js"></script>
      <button id="email-modal-close" title="dismiss"><img src="../static/img/close.svg" height="24" width="24"></button>
    </div>
  </div>
</body>
</html>

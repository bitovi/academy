@page learn-react/testing Testing in React
@parent learn-react 12
@outline 3

@description Write unit tests to verify components are functioning es expected.

@body

## Overview

How do you know your code is working correctly? How will you know it’s still working correctly in
the future after you make changes to it? Unit testing helps by verifying that given certain inputs
our code generates expected outputs. So far we’ve copied existing tests to prove that we’ve
completed the exercise correctly, now let’s dive in and learn about how React testing is done.

## Objective 1: Render a component and verify the DOM structure

The most basic test is to render a component and validate the DOM that is generated. That’s what
we’ll do in this first section.

### Introducing React testing-library

Most React unit testing is done with the [React Testing
Library](https://testing-library.com/docs/react-testing-library/intro/). The goal of this library is
to test the DOM components that are generated by React rather than the React code directly. As
stated in [their guiding principles](https://testing-library.com/docs/guiding-principles):

> 1. If it relates to rendering components, then it should deal with DOM nodes rather than component
>    instances...
> 2. It should be generally useful for testing the application components in the way the user would
>    use it.

What do we mean by "unit tests?" In the context of this lesson a unit test will involve working with
a single component: passing it props and rendering it; and validating the generated DOM.

### Rendering and verifying a component in a test

Let’s take a look at some code that we added in [Handling User Inputs and
Forms](./controlled-vs-uncontrolled.html).

@sourceref ../../../exercises/react-vite/11-controlled-vs-uncontrolled/03-problem/src/components/FormTextField/FormTextField.test.tsx
@highlight 10-15, only

Each test consists of arguments to the Vite provided test function, `it`. The first argument is a
short description of what the test is examining. The convention is that the description string takes
"it" as a prefix and proceeds from there, e.g. "(it) renders with correct label and type."

The second argument is a callback function that runs the test. In the example above the first line
of the callback invokes `render` and passes it a single argument, JSX for the `FormTextField`
component including props. After `render` completes the `screen` (a test DOM) will contain the
elements created by our React code.

```tsx
render(<FormTextField label="Test Label" type="text" value="" onChange={mockOnChange} />);
```

Now it’s time to see if the DOM matches what we expected to create. The React Testing Library
provides the `screen` object that allows us to select elements from the DOM. In the current scenario
we’ll use `getByLabelText` which returns the `<input>` associated by `id` with a single `<label>`
that has the text "Test Label". You may have intuited that `getByLabelText` accepts a string, but it
also accepts a regex, in this case one that matches any part of the label text and ignores case.

```tsx
expect(screen.getByLabelText(/Test Label:/i)).toBeInTheDocument();
```

Once `screen.getByLabelText` returns, its result can be passed to Vite’s `expect` function to see if
the result matches what we intended. We use `toBeInTheDocument` (`expect` was augmented with this
method by importing `@testing-library/jest-dom`) to verify that the element exists in the DOM. This
satisfies the first part of the test description, "renders with correct label."

If a call to `expect` does not provide the expected result an error will be thrown ending the test.

The second expect will verify the second half of the description, "and type."  `expect` is passed
the `<input>` element that was rendered and it is examined to see if the value of its `type`
attribute is set to "text."

Note that this test could also have been written to assign the result of `getByLabelText` to a
`const` then passed that const to both of the `expect` invocations.

### Setup 1

TODO

✏️ Create **src/components/FormSelect/FormSelect.tsx** and update it to be:

@sourceref ../../../exercises/react-vite/12-testing/01-solution/src/components/FormSelect/FormSelect.tsx

✏️ Create **src/components/FormSelect/index.ts** and update it to be:

@sourceref ../../../exercises/react-vite/12-testing/01-solution/src/components/FormSelect/index.ts

✏️ Update **src/pages/RestaurantList/RestaurantList.tsx** to be:

@diff ../../../exercises/react-vite/11-controlled-vs-uncontrolled/03-solution/src/pages/RestaurantList/RestaurantList.tsx ../../../exercises/react-vite/12-testing/01-solution/src/pages/RestaurantList/RestaurantList.tsx only

### Verify 1

TODO

✏️ Create **src/components/FormSelect/FormSelect.test.tsx** and update it to be:

@sourceref ../../../exercises/react-vite/12-testing/01-problem/src/components/FormSelect/FormSelect.test.tsx

### Exercise 1

TODO

### Solution 1

<details>
<summary>Click to see the solution</summary>

✏️ Update **src/components/FormSelect/FormSelect.test.tsx** to be:

@diff ../../../exercises/react-vite/12-testing/01-problem/src/components/FormSelect/FormSelect.test.tsx ../../../exercises/react-vite/12-testing/01-solution/src/components/FormSelect/FormSelect.test.tsx only

</details>

## Objective 2: Simulate a user-generated event

Most components have ways to respond to events raised by user interaction, like clicking a button,
how can we test code that responds to these interactions? We use another library provided by React
Testing Library named [user-event](https://testing-library.com/docs/user-event/intro).

`user-event` allows you to interact with your component similarly to a user some of its methods may
raise more than one event to do so, for example emitting a focus event then a click event. It also
has some helpful features such as not firing a click event on an element that’s hidden.

### Key Concepts

- The user-event library simulates user interactions - not events
- Tests must be marked as `async` to work with user-event

### Concept 1

<span style="color:red">We may want to update test code to do the following: "[We recommend invoking
`userEvent.setup()` before the component is
rendered.](https://testing-library.com/docs/user-event/intro#writing-tests-with-userevent)"</span>

Consider the following example:

```tsx
import userEvent from "@testing-library/user-event";

it("toggles pickup options when clicked", async () => {
  const user = userEvent.setup();
  render(<PickupOptions />);

  expect(screen.queryByText("In-store Options")).not.toBeInTheDocument();

  await user.click(screen.getByText("Store"));
  expect(screen.getByText("In-store Options")).toBeInTheDocument();
});
```

One difference between this example and the previous one is that the callback function is now
preceded by `async` because some of of the test code will `await` an action. Failing to set a test
callback function as `async` or use `await` with user-event methods is a common reason why tests do
not function properly or provide the results developers expect.

Before the component is rendered the `userEvent` module has its `setup` function invoked to get a
`user` that can interact with the component. The `user` has a variety of functions to simulate
common user actions such as clicking or typing.

After calling `render` we verify that the component has initially rendered the proper DOM structure.
Since the element is not expected the `queryByText` method is appropriate to use here, this method
will return null if the element doesn’t exist. We use `expect` with the `not` property to confirm
that the DOM does not contain the element. In most cases prefer using the testing library's API
methods rather than, for example, asserting on whether or not the result of `queryByText` is null.

Now that we know the proper initial DOM was rendered let’s use `user.click()` to click on an
element. We pass the element to be clicked to the `click` function as its argument. Once the call to
click resolves the DOM can be queried again to see the effect. Assuming the component code made the
right changes the call to `getByText("In-store Options")` should return the element so it exists in
the document.

### Setup 2

TODO

### Verify 2

TODO

### Exercise 2

TODO

## Next steps

TODO

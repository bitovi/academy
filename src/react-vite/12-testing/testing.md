@page learn-react-vite/testing Testing in React
@parent learn-react-vite 12
@outline 3

@description Write unit tests to verify components are functioning es expected.

@body

## Overview

How do you know your code is working correctly? How will you know it's still working correctly in
the future after you make changes to it? Unit testing helps by verifying that given certain inputs
our code generates expected outputs. So far we've copied existing tests to prove that we've
completed the exercise correctly, now let's dive in and learn about how React testing is done.

## Objective 1: Render a component and verify the DOM structure

The most basic test is to render a component and validate the DOM that is generated. That's what
we'll do in this first section.

### Key Concepts

- TODO

#### Introducing React testing-library

Most React unit testing is done with the [React Testing
Library](https://testing-library.com/docs/react-testing-library/intro/). The goal of this library is
to test the DOM components that are generated by React rather than the React code directly. As
stated in [their guiding principles](https://testing-library.com/docs/guiding-principles):

> 1. If it relates to rendering components, then it should deal with DOM nodes rather than component
>    instances...
> 2. It should be generally useful for testing the application components in the way the user would
>    use it.

What do we mean by "unit tests?" In the context of this lesson a unit test will involve working with
a single component: passing it props and rendering it; and validating the generated DOM.

#### Rendering and verifying a component in a test

Let's take a look at some code that we added in [Handling User Inputs and
Forms](./controlled-vs-uncontrolled.html).

@sourceref ../../../exercises/react-vite/11-controlled-vs-uncontrolled/03-problem/src/components/FormTextField/FormTextField.test.tsx
@highlight 10-15, only

Each test consists of arguments to the Vite provided test function, `it`. The first argument is a
short description of what the test is examining. The convention is that the description string takes
"it" as a prefix and proceeds from there, e.g. "(it) renders with correct label and type."

The second argument is a callback function that runs the test. In the example above the first line
of the callback invokes `render` and passes it a single argument, JSX for the `FormTextField`
component including props. After `render` completes the `screen` (a test DOM) will contain the
elements created by our React code.

```tsx
render(<FormTextField label="Test Label" type="text" value="" onChange={mockOnChange} />);
```

Now it's time to see if the DOM matches what we expected to create. The React Testing Library
provides the `screen` object that allows us to select elements from the DOM. In the current scenario
we'll use `getByLabelText` which returns the `<input>` associated by `id` with a single `<label>`
that has the text "Test Label". You may have intuited that `getByLabelText` accepts a string, but it
also accepts a regex, in this case one that matches any part of the label text and ignores case.

```tsx
expect(screen.getByLabelText(/Test Label:/i)).toBeInTheDocument();
```

Once `screen.getByLabelText` returns, its result can be passed to Vite's `expect` function to see if
the result matches what we intended. We use `toBeInTheDocument` (`expect` was augmented with this
method by importing `@testing-library/jest-dom`) to verify that the element exists in the DOM. This
satisfies the first part of the test description, "renders with correct label."

If a call to `expect` does not provide the expected result an error will be thrown ending the test.

The second expect will verify the second half of the description, "and type."  `expect` is passed
the `<input>` element that was rendered and it is examined to see if the value of its `type`
attribute is set to "text."

Note that this test could also have been written to assign the result of `getByLabelText` to a
`const` then passed that const to both of the `expect` invocations.

### Setup

TODO

✏️ Create **src/components/FormSelect/FormSelect.tsx** and update it to be:

@sourceref ../../../exercises/react-vite/12-testing/01-solution/src/components/FormSelect/FormSelect.tsx

✏️ Create **src/components/FormSelect/index.ts** and update it to be:

@sourceref ../../../exercises/react-vite/12-testing/01-solution/src/components/FormSelect/index.ts

✏️ Update **src/pages/RestaurantList/RestaurantList.tsx** to be:

@diff ../../../exercises/react-vite/11-controlled-vs-uncontrolled/03-solution/src/pages/RestaurantList/RestaurantList.tsx ../../../exercises/react-vite/12-testing/01-solution/src/pages/RestaurantList/RestaurantList.tsx only

### Verify

TODO

✏️ Create **src/components/FormSelect/FormSelect.test.tsx** and update it to be:

@sourceref ../../../exercises/react-vite/12-testing/01-problem/src/components/FormSelect/FormSelect.test.tsx

### Exercise

TODO

### Solution

<details>
<summary>Click to see the solution</summary>

✏️ Update **src/components/FormSelect/FormSelect.test.tsx** to be:

@diff ../../../exercises/react-vite/12-testing/01-problem/src/components/FormSelect/FormSelect.test.tsx ../../../exercises/react-vite/12-testing/01-solution/src/components/FormSelect/FormSelect.test.tsx only

</details>

## Objective 2: Simulate a user generated event

### Key Concepts

- TODO

#### Concept 1

### Setup

TODO

### Verify

TODO

### Exercise

TODO

<!DOCTYPE html>
<!--####################################################################
	THIS IS A GENERATED FILE — ANY CHANGES MADE WILL BE OVERWRITTEN

	INSTEAD CHANGE:
	source: src/advanced-typescript/04-mapped-types/mapped-types.md
	@page advanced-typescript/mapped-types
######################################################################## -->
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="google-site-verification" content="UMCgjrWAjJW_tHmYo6AerdZvVdmh8QHdY9Ywb59tpHw" />
  <meta name="description" content="Learn how to create new types with mapped types! 
">

  <!-- Google Tag Manager -->
  <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-P9MQVJS');</script>
  <!-- End Google Tag Manager -->

  <title>Bitovi Academy - Mapped Types</title>
  
  <link rel="stylesheet" type="text/css" href="../static/bundles/bit-docs-site/static.css">
  
</head>

<body>
  <!-- Google Tag Manager (noscript) -->
  <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-P9MQVJS"
  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  <!-- End Google Tag Manager (noscript) -->
  
  <div class="header">
    <div class="logo">
      <a href="https://www.bitovi.com/">Bitovi</a>
    </div>
    <ul>
      <li><a href="https://www.bitovi.com/services">Services</a></li>
      <li><a href="https://www.bitovi.com/client-work">Client Work</a></li>
      <li><a href="https://www.bitovi.com/about">Our Team</a></li>
      <li><a href="https://www.bitovi.com/open-source">Open Source</a></li>
      <li><a href="https://www.bitovi.com/blog">Blog</a></li>
      <li><a href=".." class="active">Academy</a></li>
     </ul>
     <a class="contact-popup hs-button brand button-smallest" href="https://www.bitovi.com/contact">Contact Us</a>
  </div>

  <div class="content">
	
		<div class="sidebar-left">
  
    
	<ul>
		
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-advanced-javascript.html"
							title="This course covers all the hard but important stuff you should know when learning JavaScript.">
							Advanced JavaScript
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-dom-jquery.html"
							title="Learn jQuery and the DOM APIs by building your own version of jQuery and using it to make a basic tabs widget. We strongly suggest finishing learn-advanced-javascript prior to starting this course.">
							DOM and jQuery
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-to-debug-javascript.html"
							title="This course covers the basics of JavaScript debugging.">
							Debug JavaScript
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-typescript.html"
							title="This course covers the basic essentials of TypeScript. At the end, you should be ready to develop projects in TypeScript.">
							Learn TypeScript
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-react.html"
							title="Learn React by building a feature-rich Tic-Tac-Toe game in this beginner React guide. This hands-on course will introduce both fundamental and more advanced React concepts! By the end of this course, you will have mastered functional components, hooks, and component optimization.">
							Learn React
						</a>
						
					</li>
				
			
		
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-web-components.html"
							title="">
							Learn Web Components
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-rxjs.html"
							title="Learn RxJS by creating a validating credit card form.">
							Learn RxJS
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-docker.html"
							title="Build and containerize a NodeJS app then orchestrate multiple containers with docker-compose in this Docker guide.">
							Learn Docker
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../training.html"
							title="Learn how to prepare and give a training.">
							Giving a Training
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-technology-consulting.html"
							title="Learn how to move beyond writing code to be an excellent technology consultant!">
							Learn Technology Consulting
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-canjs.html"
							title="This tutorial walks through building TodoMVC with StealJS. It includes KeyNote presentations
covering CanJS core libraries.">
							Learn CanJS
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-angular.html"
							title="Learn how to build a moderately complex application with Angular.">
							Learn Angular
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						parent
           						expanded">
						<a class="page"
							href="../advanced-typescript.html"
							title="This is the second course in the TypeScript series. By the end, you will be comfortable with any types you come across and possess the knowledge to create your own advanced types. The only prerequisite is the first course in the TypeScript series found here.">
							Advanced TypeScript
						</a>
						
							
	<ul>
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="typing-systems.html"
							title="">
							Typing Systems
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="generics-with-constraints.html"
							title="Learn how to constrain generics to be able to reuse even more logic!">
							Generics With Constraints
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="index-accessed-types.html"
							title="Learn how to look up types of properties with index accessed types!">
							Index Accessed Types
						</a>
						
					</li>
				
			
		
			
				
					<li class="current
           						parent
           						expanded">
						<a class="page"
							href="mapped-types.html"
							title="Learn how to create new types with mapped types!">
							Mapped Types
						</a>
						
							

						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="conditional-types.html"
							title="Learn how to create new types to simplify functions and enforce type safety with conditional types!">
							Conditional Types
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="template-literal-types.html"
							title="Learn what template literal types are and how to empower them with unions, generics, conditional types, and infer!">
							Template Literal Types
						</a>
						
					</li>
				
			
		
	</ul>


						
					</li>
				
			
		
	</ul>


  
  <p class="border">
      <a href="..#courses">View More Courses</a>
      <a class='bit-academy-fullscreen' title='fullscreen' href="javascript://">[ ]</a>
  </p>
</div>

	
	<article class="main">
    <div class="main-content">
  		
  			<section class="title">
	<h1>Mapped Types <code>page</code></h1>
</section>

  		

  		
  			
  				<section class="description">
    <p>Learn how to create new types with mapped types!</p>

</section>

  			
  		

  		
  			
  				
  			
  			
  				<section class="body">
    <h2>Overview</h2>
<p>Due to syntax similarity, let's do a quick recap on using index signatures to define object types. Then we will dive into what mapped types are and how to define them, followed by practical applciations of mapped types. Finally, we will work through exercises building out some commonly used mapped types.</p>
<h2>Index Signatures</h2>
<p>Index signatures are a way to define object types when you know the general shape of any object but nothing more specific than the key type and the value type. Let's imagine we have an object that looks something like this:</p>
<pre><code class="language-js">const bag = {
  maxPotion: 2,
  maxRevive: 23,
  luckEgg: 5,
  thunderStone: 1,
  /// etc.
};
</code></pre>
<p>The general shape of this object is a key of type <code>string</code> and a value of type <code>number</code>. We could define a type with an index signature to match this general definition.</p>
<pre><code class="language-ts">type Bag = {
  [itemName: string]: number;
};
</code></pre>
<p>An index signature consists of two parts:</p>
<ol>
<li>The indexer – <code>[itemName: string]</code></li>
</ol>
<ul>
<li>Defines the type the keys are allowed to be</li>
</ul>
<ol start="2">
<li>The property’s value type – <code>number</code></li>
</ol>
<ul>
<li>Defines the type of the property</li>
</ul>
<p>One thing to be aware of with defining types using index signature is the value may or may <strong>not</strong> be there, but typescript makes it seem as though it's always present.</p>
<pre><code class="language-ts">const bag: Bag = {
  maxPotion: 2,
};

bag.maxPotion; // Ts says it's a number
bag.maxRevive; // Ts says it's a number... but it's not there...
</code></pre>
<p>With interfaces and other type definitions, you can add a <code>?</code> to delineate the property is optional. This is not the case with types defined using index signatures. To achieve the optional type-safety with index signature type you can create a <strong>union</strong> with the value type and <code>undefined</code>.</p>
<pre><code class="language-ts">type BagWithUndefinedUnion = {
  [itemName: string]: number | undefined;
};

const bag: BagWithUndefinedUnion = {
  maxPotion: 2,
};

bag.maxPotion; // Ts says it's a number | undefined
bag.maxRevive; // Ts says it's a number | undefined
</code></pre>
<h3>Requiring Certain Properties</h3>
<p>Types defined using index signatures are great since they provide a lot of flexibility in what can be associated with the type but what if we wanted to require something to be there? In these situations, you can add those properties after the general key definition.</p>
<pre><code class="language-ts">type BagWithRequiredValue = {
  [itemName: string]: number;
  pokeBall: number;
};

// ERROR: Property 'pokeBall' is missing in type '{ maxPotion: number; }' but required in type 'BagWithRequiredValue'.ts(2741)
const bagWithoutPokeball: BagWithRequiredValue = {
  maxPotion: 2,
};

// All good!
const bagWithPokeball: BagWithRequiredValue = {
  pokeBall: 1,
};
</code></pre>
<p>When defining required properties, the required properties cannot violate the index signature types. In the example above <code>pokeball: number</code> conforms to <code>[itemName: string]: number</code>; however, if we change pokeball to be of type <code>string</code> TypeScript doesn’t allow it, since it's a <code>string</code> indexing another <code>string</code>.</p>
<pre><code class="language-ts">type BagWithRequiredValue = {
  [itemName: string]: number;

  // ERROR: Property 'pokeBall' of type 'string' is not assignable to 'string' index type 'number'.
  pokeBall: string;
};
</code></pre>
<p>The error above can be remedied by expanding the type for the value with a union.</p>
<pre><code class="language-ts">type BagWithRequiredValue = {
  [itemName: string]: number | string;
  pokeBall: string; // All good!
};
</code></pre>
<h3>Multiple Indexers</h3>
<p>It is possible to have more than one indexer and have different value types for indices. To understand these mechanics, we first have to talk about what can and can’t be the type inside an indexer. TypeScript does not allow us to index with anything; it only lets us index with three types <code>string</code>, <code>number</code>, and <code>symbol</code>.</p>
<blockquote>
<p><strong>Tip:</strong> For objects to be keyed with a union or something besides these three try the <code>Record</code> utlity type!</p>
</blockquote>
<div style='text-align:center'>
    <img src="./static/img/advanced-typescript/string-number-symbol.png" />
</div>
<p>These three types have a strange relationship</p>
<ul>
<li><code>number</code> is a proper subset of <code>string</code></li>
<li><code>symbol</code> is a proper subset of <code>string</code></li>
<li><code>number</code> and symbol are mutually exclusive</li>
</ul>
<p>In order for TypeScript to provide type safety, it has to be able to differentiate between the keys passed in. If the indexer's values have the same types, it doesn’t matter.</p>
<pre><code class="language-ts">type IndexerDifferentSameValue = {
  [itemString: string]: number;
  [itemNumber: number]: number;
};
</code></pre>
<p>In order to have more than one indexer with different types, the indexer’s types must be mutually exclusive (no overlap). This means the only way we can have more than one indexer with different value types is for one indexer to be of type <code>number</code> and the other to be of type <code>symbol</code>.</p>
<pre><code class="language-ts">type NonMutuallyExclusiveIndexers = {
  [itemString: string]: number;
  [itemNumber: number]: string; // ERROR: 'number' index type 'string' is not assignable to 'string' index type 'number'.
};

type MutuallyExclusive = {
  [keyNumber: number]: number;
  [keySymbol: symbol]: string;
};
</code></pre>
<p>The idea of mutual exclusion extends to individual properties, in the type above we have a shape for all <code>number</code> and all <code>symbol</code> and if we tried to throw in all string we’d get errors. But, if we only define certain strings (like we did with required properties), TypeScript would be able to make the delineation and provide type safety.</p>
<pre><code class="language-ts">type AllThree = {
  [keyNumber: number]: number;
  [keySymbol: symbol]: string;
  additionalProperty: boolean;
  empty: {};
};
</code></pre>
<h3>JavaScript Makes an Appearance</h3>
<p>TypeScript is a superset of JavaScript and has to conform to its rules. This can cause some unexpected behavior when indexing with a <code>number</code>. An example of this is arrays. In JavaScript arrays are just objects indexed with <code>number</code>s; however, in JavaScript, all object keys are coerced to <code>string</code>s.</p>
<pre><code class="language-js">const firstThreePokemon = [&quot;Bulbasaur&quot;, &quot;Ivysaur&quot;, &quot;Venusaur&quot;];

// Both are allowed
const bulbasaurWithNumber = firstThreePokemon[0];
const bulbasaurWithString = firstThreePokemon[&quot;0&quot;];
</code></pre>
<p>This quirk extends to index signature types in TypeScript.</p>
<pre><code class="language-ts">type PokemonNameList = {
  [index: number]: string;
};

// All three are valid and work the same
const firstThreePokemon: PokemonNameList = [&quot;Bulbasaur&quot;, &quot;Ivysaur&quot;, &quot;Venusaur&quot;];

const firstThreePokemonObjectNumberKeys: PokemonNameList = {
  0: &quot;Bulbasaur&quot;,
  1: &quot;Ivysaur&quot;,
  2: &quot;Venusaur&quot;,
};

const firstThreePokemonObjectStringKeys: PokemonNameList = {
  &quot;0&quot;: &quot;Bulbasaur&quot;,
  &quot;1&quot;: &quot;Ivysaur&quot;,
  &quot;2&quot;: &quot;Venusaur&quot;,
};

// Both are allowed
const bulbasaurWithNumber = firstThreePokemon[0];
const bulbasaurWithString = firstThreePokemon[&quot;0&quot;];
</code></pre>
<h3>Readonly Property Modifier</h3>
<p>While the optional syntax (<code>?</code>) isn't supported on index signature types, the index signature syntax does allow for the <code>readonly</code> modifier. The <code>readonly</code> modifier marks a property as immutable on an object meaning it cannot be re-assigned once set. If we wanted to make our <code>PokemonNameList</code> type above unchangeable we could do it by putting the <code>readonly</code> modifier at the beginning of the declaration.</p>
<pre><code class="language-ts">type ReadonlyPokemonNameList = {
  readonly [index: number]: string;
};

const firstThreePokemon: ReadonlyPokemonNameList = [
  &quot;Bulbasaur&quot;,
  &quot;Ivysaur&quot;,
  &quot;Venusaur&quot;,
];

// ERROR: Index signature in type 'ReadonlyPokemonNameList' only permits reading.
firstThreePokemon[0] = &quot;Pikachu&quot;;
</code></pre>
<p>This extends to any required property added to the type as well.</p>
<blockquote>
<p><strong>Note:</strong> required properties have access to all the syntaxes you are familiar with when defining object types with type and interface.</p>
</blockquote>
<p>Sticking with our <code>PokemonNameList</code> example type, although it looks like an array and even uses the array syntax, it doesn’t have some of the more fundamental properties of an array, like <code>.length</code>.</p>
<pre><code class="language-ts">// ERROR: Property 'length' does not exist on type 'ReadonlyPokemonNameList'
firstThreePokemon.length;
</code></pre>
<p>Often times in development we need to know the length of a list, but it is not something we want to allow developers to overwrite. To accomplish this we can tweak our definition to include a <code>readonly</code> required length property.</p>
<pre><code class="language-ts">type ReadonlyPokemonNameList = {
  readonly [index: number]: string;
  readonly length: number;
};

const firstThreePokemon: ReadonlyPokemonNameList = [
  &quot;Bulbasaur&quot;,
  &quot;Ivysaur&quot;,
  &quot;Venusaur&quot;,
];

const firstThreePokemonObject: ReadonlyPokemonNameList = {
  0: &quot;Bulbasaur&quot;,
  1: &quot;Ivysaur&quot;,
  2: &quot;Venusaur&quot;,
  length: 3,
};

console.log(firstThreePokemon.length); // 3
</code></pre>
<blockquote>
<p><strong>Note:</strong> In JavaScript the <code>firstThreePokemon</code> variable does have a <code>.length</code> property since it is an <code>Array</code>. TypeScript however, is not aware that it is an array, instead it thinks it is a <code>ReadOnlyPokemonList</code> which is why generally speaking you should avoid defining your arrays using an index signature. Instead you should use <code>Array&lt;T&gt;</code> or the shorthand <code>[]</code>.</p>
</blockquote>
<h2>Mapped Types</h2>
<p>Mapped types are another way to generate types in TypeScript. Mapped types are a way to iterate through each key of an object type to create new types for those keys. Mapped types are generic types that extend upon the index signature syntax. The best way to understand it is to see it in action. Let's take a look at a utility type that uses mapped types – <code>Partial&lt;T&gt;</code>.</p>
<pre><code class="language-ts">type Pokemon = {
  name: string;
  moves: string[];
};

/**
 * type PartialPokemon {
 *  name?: string;
 *  moves?: string[]
 * }
 */
type ParitalPokemon = Parital&lt;Pokemon&gt;;
</code></pre>
<p><code>Partial&lt;T&gt;</code> is a common utility type that maps over a type and makes all the properties in the type optional. Below is the definition of <code>Partial&lt;T&gt;</code>.</p>
<pre><code class="language-ts">/**
 * Make all properties in T optional
 */
type Partial&lt;T&gt; = {
  [P in keyof T]?: T[P];
};
</code></pre>
<p>If the phrase <code>P in keyof T</code> seems to bear some resemblance to a JavaScript <code>for-in</code> loop, that’s good! We’re essentially doing the same thing but with types. What <code>Partial</code> does is iterate through each of the properties, make them optional, and assign them whatever types they had before. Getting rid of some of the additional TypeScript in the mapping and looking at a concrete example helps illustrate this.</p>
<p>If we look at <code>PartialPokemon</code> and get rid of the generics we could re-write this as such.</p>
<pre><code class="language-ts">type PartialPokemon = {
  [P in keyof Pokemon]?: Pokemon[P];
};
</code></pre>
<p>Since we know what <code>keyof Pokemon</code> evaluates too, let's substitute that out.</p>
<pre><code class="language-ts">type PartialPokemon = {
  [P in &quot;name&quot; | &quot;moves&quot;]?: Pokemon[P];
};
</code></pre>
<p><code>P</code> serves as a variable for mapping and can be named anything, let's name it something more semantically relevant.</p>
<pre><code class="language-ts">type PartialPokemon = {
  [KeyName in &quot;name&quot; | &quot;moves&quot;]?: Pokemon[KeyName];
};
</code></pre>
<p>If we iterate through the key names we get something that looks like this.</p>
<pre><code class="language-ts">type ParitalPokemon = {
  name?: Pokemon[&quot;name&quot;];
  moves?: Pokemon[&quot;moves&quot;];
};
</code></pre>
<p>Evaluating the index accessed types then leaves us with our final type.</p>
<pre><code class="language-ts">type ParitalPokemon = {
  name?: string;
  moves?: string[];
};
</code></pre>
<h3>Property Modifiers</h3>
<p>We saw it a little bit when looking at <code>Partial</code> but mapped types give us the opportunity to change two things about the properties of the type we are creating – whether or not it's optional and whether or not it's immutable. Like types defined with an index signature, the properties of a mapped type can be made immutable by applying the <code>readonly</code> modifier. Using the <code>readonly</code> modifier in a mapped type is exactly how the <code>Readonly</code> utility type in Typescript works.</p>
<pre><code class="language-ts">/**
 * Make all properties in T readonly
 */
type Readonly&lt;T&gt; = {
  readonly [P in keyof T]: T[P];
};
</code></pre>
<p>Additionally, we can remove a <code>readonly</code> modifier in a mapped type. To accomplish this we need a small tweak in our mapped syntax. Instead of <code>readonly</code>, we add <code>-readonly</code>, essentially subtracting off the <code>readonly</code> modifier.</p>
<pre><code class="language-ts">type Changeable&lt;T&gt; = {
  -readonly [P in keyof T]: T[P];
};
</code></pre>
<p>In <code>Partial</code> we saw how we can create an optional property by adding the <code>?</code>. We can remove optionality the same way we remove the <code>readonly</code> modifier – with a <code>-?</code>. This is best illustrated by the <code>Required</code> utility type.</p>
<pre><code class="language-ts">/**
 * Make all properties in T required
 */
type Required&lt;T&gt; = {
  [P in keyof T]-?: T[P];
};
</code></pre>
<blockquote>
<p><strong>Note:</strong> you can also add <code>+readonly</code> and <code>+?</code> to your types. They are default though so they are often omitted for brevity.</p>
</blockquote>
<h3>Remapped Keys</h3>
<p>TypeScript allows us to map over more than just the keys of the object. We can do this using a syntax very similar to type assertion (<code>as</code>). To illustrate this look at the following types.</p>
<pre><code class="language-ts">type PokeballItem = {
  item: &quot;pokeballs&quot;;
  type: &quot;great&quot; | &quot;normal&quot; | &quot;ultra&quot; | &quot;master&quot;;
  amount: number;
};

type BerryItem = {
  item: &quot;berries&quot;;
  type: &quot;oran&quot; | &quot;sitrus&quot; | &quot;pecha&quot;;
  amount: number;
};

type TMItem = {
  item: &quot;tms&quot;;
  name: string;
  amount: number;
};

type Items = PokeballItem | BerryItem | TMItem;
</code></pre>
<p>We’d like to make a bag type with properties on it matching the name of the item property on each of the <code>Items</code> and having that be a function to return the amount (so <code>bag.berries</code> is a function with this shape <code>() =&gt; number</code>). To do this we must do two things -- constrain the generic and remap via <code>as</code>.</p>
<pre><code class="language-ts">type MakeBag&lt;T extends { item: string; amount: number }&gt; = {
  [Item in keyof T as T[&quot;item&quot;]]: () =&gt; T[&quot;amount&quot;];
};

/**
 * {
 *  berries: () =&gt; number;
 *  tms: () =&gt; number;
 *  pokeballs: () =&gt; number;
 * }
 */
type Bag = MakeBag&lt;Items&gt;;
</code></pre>
<h3>Let's Make our own!</h3>
<p>So far we’ve seen some mapped types that TypeScript provides for us in its utility types, so let's walk through making our own. In this case, let’s look at creating a <code>Pokemon</code> class whose constructor takes the types of the Pokemon. So far in the examples leading up to this, the type property of a Pokemon has been defined as a union <code>&quot;Normal&quot; | &quot;Fire&quot; | ...</code>, but Pokemon can have more than one type, in fact, they can have up to two, like, in the case of Charizard – Fire and Flying. To create our class we want a single pokemon type (either a <code>PokemonType</code> or a <code>[PokemonType]</code>) or tuple that provides these options.</p>
<pre><code class="language-ts">const pikachu = new Pokemon(&quot;Electric&quot;);
const charizard = new Pokemon([&quot;Fire&quot;, &quot;Flying&quot;]);
const gyarados = new Pokemon([&quot;Flying&quot;, &quot;Water&quot;]);
</code></pre>
<p>We may at first think something like this might work.</p>
<pre><code class="language-ts">type PokemonType =
  | &quot;Normal&quot;
  | &quot;Fire&quot;
  | &quot;Water&quot;
  | &quot;Grass&quot;
  | &quot;Electric&quot;
  | &quot;Ice&quot;
  | &quot;Fighting&quot;
  | &quot;Poison&quot;
  | &quot;Ground&quot;
  | &quot;Flying&quot;
  | &quot;Psychic&quot;
  | &quot;Bug&quot;
  | &quot;Rock&quot;
  | &quot;Ghost&quot;
  | &quot;Dark&quot;
  | &quot;Dragon&quot;
  | &quot;Steel&quot;
  | &quot;Fairy&quot;;

type PokemonTypes = [PokemonType] | [PokemonType, PokemonType];

class Pokemon&lt;T extends PokemonType&gt; {
  constructor(public types: T | PokemonTypes[T]) {}
}
</code></pre>
<p>However, this has a flaw: it allows us to have duplicate types such as <code>[&quot;Fire&quot;, &quot;Fire&quot;]</code>. In this case, we need a type that has the original pokemon type and the list of the rest of the pokemon types. To create this we can use a mapped type that uses <code>Exclude</code> within its iteration.</p>
<pre><code class="language-ts">type PokemonTypes = {
  [T in PokemonType]: [T] | [T, Exclude&lt;PokemonType, T&gt;];
};
</code></pre>
<p>What this gives us is a type that has either a single pokemon type or a tuple with a single pokemon type and the rest of the pokemon types with the original pokemon type excluded.</p>
<pre><code class="language-ts">type PokemonTypes = {
  Normal: [&quot;Normal&quot;] | [&quot;Normal&quot;, &quot;Fire&quot; | &quot;Water&quot; | &quot;Grass&quot; | &quot;Electric&quot; | &quot;Ice&quot;  | &quot;Fighting&quot; | &quot;Poison&quot; | &quot;Ground&quot; | &quot;Flying&quot; | &quot;Psychic&quot; | &quot;Bug&quot; | &quot;Rock&quot; | &quot;Ghost&quot; | &quot;Dark&quot; | &quot;Dragon&quot; | &quot;Steel&quot; | &quot;Fairy&quot;]
  Fire: [&quot;Fire&quot;] | [&quot;Fire&quot;, &quot;Normal&quot; | &quot;Water&quot; | &quot;Grass&quot; | &quot;Electric&quot; | &quot;Ice&quot;  | &quot;Fighting&quot; | &quot;Poison&quot; | &quot;Ground&quot; | &quot;Flying&quot; | &quot;Psychic&quot; | &quot;Bug&quot; | &quot;Rock&quot; | &quot;Ghost&quot; | &quot;Dark&quot; | &quot;Dragon&quot; | &quot;Steel&quot; | &quot;Fairy&quot;]]
  /// rest of pokemon types
}

</code></pre>
<p>Now we can use them in our class. Like we said above, we want to be able to pass any of the following.</p>
<pre><code class="language-ts">const pikachu = new Pokemon(&quot;Electric&quot;);
const charizard = new Pokemon([&quot;Fire&quot;, &quot;Flying&quot;]);
const gyarados = new Pokemon([&quot;Flying&quot;, &quot;Water&quot;]);
</code></pre>
<p>To do this we can use a generic constrained to our <code>PokemonType</code> and an index accessed type to create our class definition.</p>
<pre><code class="language-ts">class Pokemon&lt;T extends PokemonType&gt; {
  constructor(public types: T | PokemonTypes[T]) {}
}

const pikachu = new Pokemon(&quot;Electric&quot;);
const charizard = new Pokemon([&quot;Fire&quot;, &quot;Flying&quot;]);
const gyarados = new Pokemon([&quot;Flying&quot;, &quot;Water&quot;]);
</code></pre>
<p>As we’ve seen mapped types can do much of the heavy lifting when it comes to creating types from types. They power many utility types leveraged in applications. Moving forward, we will only see them more frequently, especially as we move into our next section – conditional types.</p>
<h2>Exercises</h2>
<h3>Exercise 1</h3>
<p>Below is a generic type called <code>To&lt;T,K&gt;</code> that is currently set to <code>any</code>. Update the type to change all of the properties on <code>T</code> <strong>to</strong> whatever is passed into <code>K</code>. Take the following <code>ToNumber</code> type for example, it serves as an alias for <code>To</code> where <code>K</code> is <code>number</code>.</p>
<pre><code class="language-ts">type ToNumber&lt;T&gt; = To&lt;T, number&gt;;
type Numberfied = ToNumber&lt;{ level: string; age: string }&gt;; // {level: number; age: number}
</code></pre>
<p><a href="https://codesandbox.io/s/sgfq7m?file=/04-mapped-types-ex-01.ts" target="_blank">Open in CodeSandbox</a></p>
<pre><code class="language-ts">/**
 * Exercise 1
 * Below is a generic type called `To&lt;T,K&gt;` that is currently set to `any`. Update the type to change all of the properties
 * on `T` **to** whatever is passed into `K`. Take the following `ToNumber` type for example, it serves as an alias for `To` where
 * `K` is `number`.
 *
 * ```ts
 * type ToNumber&lt;T&gt; = To&lt;T, number&gt;;
 * type Numberfied = ToNumber&lt;{level: string; age: string;}&gt; // {level: number; age: number}
 * ```
 */
type To&lt;T, K&gt; = any; // TODO: don't use any

const initialState = {
  name: &quot;&quot;,
  emailAddress: &quot;&quot;,
  age: 0,
};

type State = typeof initialState;
type StateValidation = To&lt;State, boolean&gt;;

const stateValidationSafe: StateValidation = {
  name: false,
  emailAddress: true,
  age: false,
};

// This should fail if the type is correct
const FAILURE_stateValidationTypeError: StateValidation = {
  name: 99, // Type 'number' is not assignable to type 'boolean'.ts(2322)
  emailAddress: &quot;bob&quot;, // Type 'string' is not assignable to type 'boolean'.ts(2322)
  age: NaN, // Type 'number' is not assignable to type 'boolean'.ts(2322)
};

</code></pre>
<p><details>
<summary>Click to see the solution</summary></p>
<pre><code class="language-ts">export type To&lt;T, K&gt; = {
  [Key in keyof T]: K;
};

</code></pre>
<div line-highlight='1-3'></div>
<p></details></p>
<h3>Exercise 2</h3>
<p>Exercise 2:</p>
<p>Let's recreate the <code>Pick</code> utility type. <code>_Pick</code> should take two generics, some object <code>T</code> and a string literal union that is
some subset of keys from <code>T</code> as <code>K</code>.</p>
<pre><code class="language-ts">type _Pick&lt;T, K&gt; = any; // TODO

type Picked = _Pick&lt;{ name: string; age: number }, &quot;age&quot;&gt;; // {age: number}
</code></pre>
<p><details>
<summary> Hint for Exercise 2 (click to reveal)</summary>
You may need to update the definition of <code>K</code> to get this type to work properly
</details></p>
<p><a href="https://codesandbox.io/s/pxg3i3?file=/04-mapped-types-ex-02.ts" target="_blank">Open in CodeSandbox</a></p>
<pre><code class="language-ts">/**
 * Exercise 2:
 *
 * Let's recreate the `Pick` utility type. `_Pick` should take two generics, some object `T` and a string literal union that is
 * some subset of keys from `T` as `K`.
 *
 * ```ts
 * type _Pick&lt;T, K&gt; = any; // TODO
 *
 * type Picked = _Pick&lt;{ name: string; age: number }, &quot;age&quot;&gt;; // {age: number}
 * ```
 *
 * &gt; Hint:
 * &gt; You may need to update the definition of `K` to get this type to work properly
 */
type _Pick&lt;T, K&gt; = any;

</code></pre>
<p><details>
<summary>Click to see the solution</summary></p>
<pre><code class="language-ts">/**
 * From T, pick a set of properties whose keys are in the union K
 */
export type _Pick&lt;T, K extends keyof T&gt; = {
  [P in K]: T[P];
};

</code></pre>
<div line-highlight='4-6'></div>
<p></details></p>

</section>

  			
  			<bit-prev-next class="footer" list-selector=".sidebar-left ul li.parent.expanded ul"></bit-prev-next>
  		
    </div>

    
      <div class="sidebar-right">
        <div class="content-nav on-this-page-container">
          <h6>On this page...</h6>
          <div class="list-items" id="scroll-toc">
            <bit-toc heading-container-selector="article.main" scroll-selector="#scroll-toc"></bit-toc>
          </div>
        </div>
        <div class="pullout slack">
          <h6>Get help</h6>
          <p>If you need <a href="https://www.bitovi.com/community/slack">help</a> with an exercise, please reach out to us on
             <a href="https://www.bitovi.com/community/slack">Slack</a></p>
        </div>
        <div class="pullout bug">
          <p>If you find a bug, please
             <a href="https://github.com/bitovi/academy/issues/new">create an issue</a> or email
             <a href="mailto:contact@bitovi.com?Subject=Training%20Suggestion" target="_blank">contact@bitovi.com</a></p>
        </div>
      </div>
    

	</article>
</div>



  <footer></footer>

  <div id="scripts">
    <script type="text/javascript">
      var docObject = {"src":{"path":"src/advanced-typescript/04-mapped-types/mapped-types.md"},"description":"Learn how to create new types with mapped types! \n","name":"advanced-typescript/mapped-types","title":"Mapped Types","type":"page","parent":"advanced-typescript","order":4,"comment":" ","pathToRoot":"../.."};
    </script>

    
      <script>
        steal = {
          instantiated: {
            "bundles/bit-docs-site/static.css!$css" : null
          }
        }
      </script>
      <script type='text/javascript'
          data-main="bit-docs-site/static"
          src="../static/steal.production.js"></script>
    

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-2302003-12"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-2302003-12');
    </script>

  </div>
  <div id="email-modal" style="display: none;">
    <div aria-hidden="true" class="email-modal-backdrop"></div>
    <div role="region" class="email-modal-content">
      <h2>Join the Bitovi Newsletter</h2>
      <p>
        To start the course, please provide an email.<br />
        <i style="font-size: 0.8rem;">By providing your email you agree to receive communications from Bitovi</i>
      </p>
      <div id="academy-hubspot-form-embed"></div>
      <script charset="utf-8" type="text/javascript" src="//js.hsforms.net/forms/embed/v2.js"></script>
    </div>
  </div>
</body>
</html>

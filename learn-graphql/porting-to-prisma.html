<!DOCTYPE html>
<!--####################################################################
	THIS IS A GENERATED FILE — ANY CHANGES MADE WILL BE OVERWRITTEN

	INSTEAD CHANGE:
	source: src/graphql/3-porting-to-prisma/porting-to-prisma.md
	@page learn-graphql/porting-to-prisma
######################################################################## -->
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="google-site-verification" content="UMCgjrWAjJW_tHmYo6AerdZvVdmh8QHdY9Ywb59tpHw" />
  <meta name="description" content="In this guide we will be working off of a starting point [project](https://github.com/bitovi/node-graphql-tutorial-2023/tree/mongodb) and will be removing the need for Mongoose and instead we will be using Prisma to perform our queries and mutations! 
">
  
  <!-- Google Tag Manager -->
  <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-P9MQVJS');</script>
  <!-- End Google Tag Manager -->

  <title>Bitovi Academy - Converting Mongoose to Prisma</title>
  
  <link rel="stylesheet" type="text/css" href="../static/bundles/bit-docs-site/static.css">
  
</head>

<body>
  <!-- Google Tag Manager (noscript) -->
  <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-P9MQVJS"
  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  <!-- End Google Tag Manager (noscript) -->
  
  <div class="header">
    <div class="logo">
      <a href="https://www.bitovi.com/">Bitovi</a>
    </div>
    <ul>
      <li><a href="https://www.bitovi.com/services">Services</a></li>
      <li><a href="https://www.bitovi.com/client-work">Client Work</a></li>
      <li><a href="https://www.bitovi.com/about">Our Team</a></li>
      <li><a href="https://www.bitovi.com/open-source">Open Source</a></li>
      <li><a href="https://www.bitovi.com/blog">Blog</a></li>
      <li><a href=".." class="active">Academy</a></li>
     </ul>
     <a class="contact-popup hs-button brand button-smallest" href="https://www.bitovi.com/contact">Contact Us</a>
  </div>

  <div class="content">
	
		<div class="sidebar-left">
  
    
	<ul>
		
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-advanced-javascript.html"
							title="This course covers all the hard but important stuff you should know when learning JavaScript.">
							Advanced JavaScript
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-dom-jquery.html"
							title="Learn jQuery and the DOM APIs by building your own version of jQuery and using it to make a basic tabs widget. We strongly suggest finishing learn-advanced-javascript prior to starting this course.">
							DOM and jQuery
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-to-debug-javascript.html"
							title="This course covers the basics of JavaScript debugging.">
							Debug JavaScript
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-typescript.html"
							title="This course covers the basic essentials of TypeScript. At the end, you should be ready to develop projects in TypeScript.">
							Learn TypeScript
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-react-vite.html"
							title="Learn React by building the feature-rich Place My Order application in this beginner React guide. This hands-on course will introduce you to fundamental React concepts! By the end of this course, you will have a strong understanding of JSX, functional components, styling, state management, Hooks, data fetching, routing, and testing.">
							Learn React
						</a>
						
					</li>
				
			
		
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-web-components.html"
							title="">
							Learn Web Components
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-agile-program-management-with-jira.html"
							title="Learn how to build, maintain, and report on accurate multi-team plans with Jira.">
							Agile Program Management With Jira
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-rxjs.html"
							title="Learn RxJS by creating a validating credit card form.">
							Learn RxJS
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../training.html"
							title="Learn how to prepare and give a training.">
							Giving a Training
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-technology-consulting.html"
							title="Learn how to move beyond writing code to be an excellent technology consultant!">
							Learn Technology Consulting
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-react.html"
							title="Learn React by building a feature-rich Tic-Tac-Toe game in this beginner React guide. This hands-on course will introduce both fundamental and more advanced React concepts! By the end of this course, you will have mastered functional components, hooks, and component optimization.">
							Learn React
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-ngrx.html"
							title="Learn how to manage state in an Angular application using NgRx.">
							Learn NgRx
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						parent
           						expanded">
						<a class="page"
							href="../learn-graphql.html"
							title="Build a backend application for property rentals using Node JS, GraphQL and Apollo Server.         Learn about using ORMs like Mongoose and Prisma with a NoSQL Mongo database!
Write testcases testing created endpoints.">
							Learn Graphql
						</a>
						
							
	<ul>
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="setting-up-apollo.html"
							title="This GraphQL tutorial will take you through creating different entities, how to create a server using Apollo Server 4, and some of the plugins available to use. We will go through queries, mutations, dealing with the resolver chain (A.K.A entity resolution). We’ll talk a bit about growing our graph including update mutations and introduce some error handling. Then we’ll go over directives that are available for the maintenance of your graph, and then end with adding some cache control for some fields within an entity.">
							Setting Up a GraphQL Server with Apollo
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="adding-mongodb.html"
							title="In this guide we will be working off of a starting point project and will be removing the need for static data, while adding a connection to a live database!
We’ll also go over some basic methods to perform CRUD operations, and how we will pull related entities from our database (what is known as joins in SQL) using the populate function in Mongoose. We’ll also create a small seed file in order to fill our database with some baseline information.">
							Connecting Apollo Server with MongoDB
						</a>
						
					</li>
				
			
		
			
				
					<li class="current
           						parent
           						expanded">
						<a class="page"
							href="porting-to-prisma.html"
							title="In this guide we will be working off of a starting point project and will be removing the need for Mongoose and instead we will be using Prisma to perform our queries and mutations!">
							Converting Mongoose to Prisma
						</a>
						
							

						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="adding-testing.html"
							title="At the start of this tutorial you should have a repository similar to this. So far we created our endpoints for our three entities, we had added Mongoose, and ported our endpoints to use Prisma instead. At each point we had to manually test the endpoints in Apollo Sandbox, and while that is a useful tool, in a real project we would be working with a testing framework in order to make sure that our endpoints still work. Today we’ll be adding testcases to our project and leveraging executeOperation to emulate requests to our Apollo Server, giving us the capability to test code ranging from our resolvers, to our dataSources. The concept here would be an integration test since it will be testing our GraphQL resolvers and dataSources. Without further ado, let’s start!">
							Testing Node.js and GraphQL with Jest
						</a>
						
					</li>
				
			
		
	</ul>


						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-docker.html"
							title="Build and containerize a Node.js app then orchestrate multiple containers with docker-compose in this Docker guide.">
							Learn Docker
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-canjs.html"
							title="This tutorial walks through building TodoMVC with StealJS. It includes KeyNote presentations
covering CanJS core libraries.">
							Learn CanJS
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../learn-angular.html"
							title="Learn how to build a moderately complex application with Angular.">
							Learn Angular
						</a>
						
					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../advanced-typescript.html"
							title="This is the second course in the TypeScript series. By the end, you will be comfortable with any types you come across and possess the knowledge to create your own advanced types. The only prerequisite is the first course in the TypeScript series found here.">
							Advanced TypeScript
						</a>
						
					</li>
				
			
		
	</ul>


  
  <p class="border">
      <a href="..#courses">View More Courses</a>
      <a class='bit-academy-fullscreen' title='fullscreen' href="javascript://">[ ]</a>
  </p>
</div>

	
	<article class="main">
    <div class="main-content">
  		
  			<section class="title">
	<h1>Converting Mongoose to Prisma <code>page</code></h1>
</section>

  		

  		
  			
  				<section class="description">
    <p>In this guide we will be working off of a starting point <a href="https://github.com/bitovi/node-graphql-tutorial-2023/tree/mongodb">project</a> and will be removing the need for Mongoose and instead we will be using Prisma to perform our queries and mutations!</p>

</section>

  			
  		

  		
  			
  				
  			
  			
  				<section class="body">
    <h2>What is an ORM?</h2>
<p>To begin we will be addressing what is an ORM: it stands for Object Relational Mapping. This is essentially a technique used in creating a bridge between object-oriented programs like Node JS and relational databases like SQL. Instead of having to build your own custom ORM tool from scratch, you can make use of an ORM (even Mongoose is an ORM).</p>
<h2>What is Prisma?</h2>
<p>Prisma is a new type of ORM where you can define your model in the declarative Prisma schema which serves as the single source of truth for your database schema and the models in your programming language. Using the Prisma Client you get type-safe methods, and some nice autocompletion when interacting with a collection or table. Prisma also comes with <strong>Prisma Migrate</strong>, which is a declarative data modeling and migration tool which generates a migration file, updates the database schema, and generates the new Prisma client for use during development.</p>
<h3>Install the Prisma CLI</h3>
<p>There are a few things that we’ll need to do in order to port our Mongoose queries over to Prisma. After our last tutorial we should have a collection defined that contains entities created in the database (by running our <strong>seed.js</strong>).</p>
<p>Let’s start by installing what packages we need:</p>
<pre><code class="language-shell">npm i prisma -D
npx prisma init --datasource-provider mongodb
npm i @prisma/client
</code></pre>
<h3>Introspect the Database</h3>
<p>We are going to run the following command in order to update our <code>schema.prisma</code> file with the collections already created in MongoDB. One thing to note is that your <code>schema.prisma</code> file should have this value present (this will be your connection string):</p>
<pre><code class="language-js">datasource db {
  provider = &quot;mongodb&quot;
  url      = env(&quot;DATABASE_URL&quot;)
}
</code></pre>
<p>Make sure that your <code>.env</code> file contains a value called <strong>DATABASE_URL</strong>. This connection string has a slight difference in that it will contain the collection name of the database so it knows where to pull from, see an example below and note the <strong>collectionName</strong> portion:</p>
<p><code>mongodb+srv://&lt;databaseName&gt;:&lt;password&gt;.mongodb.net/&lt;collectionName&gt;?retryWrites=true&amp;w=majority</code></p>
<h3>Next we will run the following commands</h3>
<pre><code class="language-shell">npx prisma db pull
npx prisma generate
</code></pre>
<p>This will now update your <code>schema.prisma</code> file to reflect what was defined in MongoDB based on the information we put into our database. Unfortunately MongoDB doesn’t support relations between different collections. So we have to re-create the references between documents using the <code>ObjectId</code> field type from one document to another.</p>
<h3>PropertyOwner → Properties relation mapping (1-many)</h3>
<p>In our previous definitions, every property has a propertyOwner, and a propertyOwner can have many properties. So now we need to setup that relationship in our <strong>schema.prisma</strong> file:</p>
<pre><code class="language-js">model PropertyOwners {
  id         String       @id @default(auto()) @map(&quot;_id&quot;) @db.ObjectId
  v          Int          @map(&quot;__v&quot;)
  address    String
  name       String
  photo      String
  properties Properties[]
  rating     Float

  @map(&quot;propertyowners&quot;)
}
</code></pre>
<p>This part of the relationship is fairly simple: we change the type of <code>properties</code> to be of type <code>Properties[]</code>.</p>
<p><strong>Note:</strong> We can use the <strong>@map</strong> keyword in order to rename the model. We can also use the <strong>@map</strong> keyword to rename a field to another name. Prisma has the following naming conventions: PascalCase for model names and camelCase for field names.</p>
<p>Next we have to change the model <strong>Properties</strong> to have the other portion of the relationship:</p>
<pre><code class="language-js">model Properties {
  id              String         @id @default(auto()) @map(&quot;_id&quot;) @db.ObjectId
  v               Int            @map(&quot;__v&quot;)
  available       Boolean
  city            String
  description     String
  name            String
  photos          String[]
  propertyOwner   PropertyOwners @relation(fields: [propertyOwnerId], references: [id])
  propertyOwnerId String         @db.ObjectId
  rating          Float
  renters         Renters[]

  @map(&quot;properties&quot;)
}
</code></pre>
<p>In order to define the relationship, we have to define two fields: <code>propertyOwner</code> and <code>propertyOwnerId</code>. The first one seems easy enough <code>propertyOwnerId</code> is a <code>String</code> type and we need to use the <code>@db.ObjectId</code> keyword to represent that it is an id for MongoDB. Next we change the propertyOwner field to be of type <code>PropertyOwners</code> and we need to define a <code>@relation</code>. Here we are mentioning that the fields that this references is the <code>propertyOwnerId</code> field and that is representing an <code>id</code> of another model (in this case <strong>PropertyOwner</strong>). We setup the first part of the properties → renters (1 → many) relationship as well, in this case the renters field represents <code>Renters[]</code>.</p>
<h2>Renter Many → Many Self-Relationship</h2>
<p>In the Renters model we need to define the other part of the relationship for properties, and the roommate relationship as well:</p>
<pre><code class="language-js">model Renters {
  id               String      @id @default(auto()) @map(&quot;_id&quot;) @db.ObjectId
  v                Int         @map(&quot;__v&quot;)
  city             String
  name             String
  rating           Float
  roommates        Renters[]   @relation(&quot;RoommateRenters&quot;)
  roommateRenter   Renters?    @relation(&quot;RoommateRenters&quot;, fields: [roommateId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  roommateId       String?     @db.ObjectId
  rentedPropertyId String?     @map(&quot;rentedProperty&quot;) @db.ObjectId
  rentedProperty   Properties? @relation(fields: [rentedPropertyId], references: [id])

  @map(&quot;renters&quot;)
}
</code></pre>
<p>To complete the Renter → Property relationship we do something similar for the Property → PropertyOwner relationship: we create <code>rentedPropertyId</code> with the <code>String</code> field being optional marked by the type ending with <code>?</code>. We then set it as a <code>@db.ObjectId</code> and use a <code>@relation</code> on the <code>rentedProperty</code> field referencing the optional id we created.</p>
<p>Next is something that is a bit more complicated, we need to create three fields for the relationship between Renters and their roommates:</p>
<pre><code class="language-js">roommates        Renters[]   @relation(&quot;RoommateRenters&quot;)
roommateRenter   Renters?    @relation(&quot;RoommateRenters&quot;, fields: [roommateId], references: [id], onDelete: NoAction, onUpdate: NoAction)
roommateId       String?     @db.ObjectId
</code></pre>
<p>The <code>roommates</code> field which is the <code>Renters[]</code> type contains the <code>@relation(&quot;RoommateRenters&quot;)</code> which gives a name to the relation <code>RoommateRenters</code>. Next we define that each <code>roommateRenter</code> in this relationship called <code>RoommateRenters</code> is an optional field where it references an id we are calling <code>roommateId</code>. Then finally we create the id <code>roommateId</code> of an optional type <code>String</code>, and we use the <code>@db.ObjectId</code> to show it is a MongoDB id. We finish the <code>@relation</code> by adding <code>onDelete: NoAction, onUpdate: NoAction</code>. This is because the self-relation can cause an infinite loop if we update that field.</p>
<h2>Putting Prisma Client into the project</h2>
<p>With that, we defined all the relationships we need, the next step is to add our Prisma Client into our project. In our <code>src</code> folder we’ll create a <code>prisma.js</code> file and add the following lines:</p>
<pre><code class="language-js">const { PrismaClient } = require('@prisma/client');

const prisma = new PrismaClient();

module.exports = prisma;
</code></pre>
<p>Then now if our <code>index.js</code> server file we can pass it through the GraphQL context so that are resolvers only use a single instance of our Prisma Client:</p>
<pre><code class="language-js">const prisma = require('./src/prisma');
...

app.use(
    ...
    expressMiddleware(server, {
        context: async ({ req }) =&gt; ({
            token: req.headers.token,
            // passing our prisma connection for re-use
            prisma
        }),
    })
);
</code></pre>
<h2>Create the new seed file</h2>
<p>Though the syntax might be a bit different, the concept will still be similar to what we had to do for Mongoose. Prisma uses a <code>connect</code> option that will set up the relation between two models, and in the return portion we use the <code>include</code> option that will work similar to the way <code>populate</code> did in Mongoose. First step is to change some of the initial seed data:</p>
<pre><code class="language-js">const Prisma = require('./src/prisma');

const renters = [
    {
        name: 'renter 1',
        city: 'Toronto',
        rating: 4.0,
        v: 0
    },
    {
        name: 'renter 2',
        city: 'Toronto',
        rating: 3.5,
        v: 0
    }
];

const propertyOwners = [
    {
        name: 'owner 1',
        address: 'Toronto',
        rating: 4.0,
        photo: 'something',
        v: 0
    },
    {
        name: 'owner 2',
        address: 'Toronto',
        rating: 4.0,
        photo: 'something',
        v: 0
    }
];

const properties = [
    {
        name: 'Deluxe suite 1',
        city: 'Toronto',
        rating: 5.0,
        available: true,
        description: 'amazing place 1',
        photos: [],
        v: 0
    },
    {
        name: 'Deluxe suite 2',
        city: 'Toronto',
        rating: 5.0,
        available: true,
        description: 'amazing place 2',
        photos: [],
        v: 0
    }
];
</code></pre>
<p>We’ll be needing the <code>v</code> field because it is a value present in the MongoDB store and tracks versioning. Next is we will  begin to create the relationships between Renters that are roommates:</p>
<pre><code class="language-js">// create two renters, one of which is roommates with the second nested renter
const firstRenter = await Prisma.renters.create({
    data: {
        ...renters[0],
        roommates: {
            create: renters[1]
        }
    }
});
// connect renter 2 to be a roommate of renter 1
const secondRenter = await Prisma.renters.update({
    where: {
        id: firstRenter.roommates[0].id
    },
    data: {
        roommates: {
            connect: [{ id: firstRenter.id }]
        }
    }
});
</code></pre>
<p>We will be using a nested <code>create</code> which allows us to create both roommates together, and putting the id of the newly created renter in the <code>roommates</code> field. Next we can update the second renter created and use the <code>connect</code> option, which can take a <strong>list</strong> of objects containing an <strong>id</strong> value of the model we are going to connect. There are other methods like <code>connectOrCreate</code> but in this case we know its data we are initializing rather than connecting to data we’re not sure if it exists. Next we create the PropertyOwners:</p>
<pre><code class="language-js">// Create propertyOwners with connected properties
// then connect renters to properties
await Prisma.propertyOwners.create({
    data: {
        ...propertyOwners[0],
        properties: {
            create:  {
                ...properties[0],
                renters: {
                    connect: [{ id: firstRenter.id }]
                }
            }
        }
    }
});

await Prisma.propertyOwners.create({
    data: {
        ...propertyOwners[1],
        properties: {
            create: {
                ...properties[1],
                renters: {
                    connect: [{ id: secondRenter.id }]
                }
            }
        }
    }
});
</code></pre>
<p>What is nice here is that we can immediately create the properties we wanted to originally link to PropertyOwners in the <code>create</code> option and simultaneously <code>connect</code> on the <code>renters</code> field and link all the models together. In fact it looks like our <strong>seed.js</strong> file is now a bit more clean than before!</p>
<h2>Updating our Renter resolvers and dataSources</h2>
<p>For each of our models, we will need to update the methods to include the <code>prisma</code> instance that is now passed through the context for our dataSources to use, first up we’ll update Renters:</p>
<pre><code class="language-js">Query: {
    getRenterById: async (_parent, args, { prisma }) =&gt; {
        return getRenterById(args.renterId, prisma);
    },
    renters: async (_parent, _args, { prisma }) =&gt; {
        return getAllRenters(prisma);
    }
},
Mutation: {
    createRenter: async (_parent, args, { prisma }) =&gt; {
        return createRenter(args.createRenterInput, prisma);
    }
}
</code></pre>
<p><strong>Note:</strong> The Prisma instance will be passed through the <code>info</code> variable and we’ll destructure what we need for now from it.</p>
<p>Next, we need to head to the <code>renters/dataSource.js</code>:</p>
<pre><code class="language-js">async function getRenterById(renterId, Prisma) {
    return Prisma.renters.findUnique({
        where: {
            id: renterId
        },
        include: {
            roommates: true
        }
    });
}

async function createRenter(renter, Prisma) {
    return Prisma.renters.create({
        data: {
            city: renter.city,
            name: renter.name,
            rating: 0.0,
            roommates: {
                connect: renter.roommates.map((renterId) =&gt; ({ id: renterId }))
            },
            v: 0
        },
        include: {
            roommates: true
        }
    });
}

async function getAllRenters(Prisma) {
    return Prisma.renters.findMany({
        include: {
            roommates: true
        }
    });
}
</code></pre>
<p>Other than the method name changes, the most notable portion is that we have the <code>include</code> option for the <code>roommates</code> field, this ensures that when we return from this method we have a populated <code>roommates</code> object. You’ll see that we include <code>v: 0</code> in our data payload for creates, this is the same as the <code>seed.js</code> file where for mongoDB documents we need that versioning.</p>
<p><strong>Note:</strong> As for the Prisma naming convention, you may not end up wanting to use <code>Prisma</code> but instead use <code>prismaClient</code> or lowercase <code>prisma</code> instead. This depends on your style and feel free to adjust accordingly.</p>
<h2>Updating our Property resolvers and dataSources</h2>
<pre><code class="language-js">Query: {
    getPropertyById: async (_parent, args, { prisma }) =&gt; {
        return getPropertyById(args.propertyId, prisma);
    },
    properties: async (_parent, _args, { prisma }) =&gt; getAllProperties(prisma)
},
Mutation: {
    createProperty: async (_parent, args, { prisma }) =&gt; {
        return createProperty(args.createPropertyInput, prisma);
    },
    updateProperty: async (_parent, args, { prisma }) =&gt; {
        return updateProperty(args.updatePropertyInput.id, args.updatePropertyInput, prisma);
    }
}
</code></pre>
<p>However things for the property will become more complicated for the update method we created before:</p>
<pre><code class="language-js">async function getPropertyById(propertyId, Prisma) {
    return Prisma.properties.findUnique({
        where: {
            id: propertyId
        },
        include: {
            renters: true,
            propertyOwner: true
        }
    });
}

async function createProperty(property, Prisma) {
    return Prisma.properties.create({
            data: {
                available: property.available,
                city: property.city,
                description: property.description,
                name: property.name,
                photos: property.photos || [],
                propertyOwnerId: property.propertyOwnerId,
                rating: 0.0,
                renters: {
                    connect: property.renters.map((renterId) =&gt; ({ id: renterId }))
                },
                v: 0
            },
            include: {
                propertyOwner: true,
                renters: true
            }
        });
}

async function updateProperty(propertyId, updatedProperty, Prisma) {
    const nonConnectPropertyFields = omit(updatedProperty, ['id', 'renters', 'propertyOwner']);

    const renters = updatedProperty.renters &amp;&amp; {
        connect: updatedProperty?.renters.map((renterId) =&gt; ({ id: renterId }))
    };
    const propertyOwner = updatedProperty.propertyOwner &amp;&amp; {
        connect: { id: updatedProperty.propertyOwner }
    };

    try {
        const savedProperty = await Prisma.properties.update({
            where: {
                id: propertyId
            },
            data: {
                ...nonConnectPropertyFields,
                ...(renters),
                ...(propertyOwner)
            },
            include: {
                renters: true,
                propertyOwner: true
            }
        });
        return {
            __typename: 'Property',
            ...savedProperty
        };

    } catch (err) {
        if (err?.meta?.cause === 'Record to update not found.') {
            return PropertyNotFoundError(propertyId);
        }
        return err;
    }
}

async function getAllProperties(Prisma) {
    return Prisma.properties.findMany({
        include: {
            renters: true,
            propertyOwner: true
        }
    });
}
</code></pre>
<p>For creating connections, we will need a way to remove the fields we want to re-purpose or re-make using the connect syntax, in this case we will want to remove the fields we don’t want to include from our input object (this is because we still want to destructure the rest of the input fields to make the data object cleaner). In this case we will omit <code>id, renters, propertyOwners</code>. To do that we will install <code>lodash.omit</code>, and then we will form the new objects containing the ids of the renters and the propertyOwners. For the return we still have to ensure we include <code>__typename: 'Property'</code> in the object.</p>
<h2>Error handling in Prisma</h2>
<p>In this case you will see that we handle our errors by specifically looking for error messages within the err object, this is because sometimes Prisma may not return specific errors that we can consume into our Error types we create. In this case we have to check the contents of the error object, and map that to out <strong>PropertyNotFoundError</strong>. Adding more edge cases and types of errors may include adding more logic to this catch block in order to interpret errors, which may not look ideal. However if we want to be returning a specific type of error every time, for each of our GraphQL Union Error types then this a good enough approach for now.</p>
<h2>Updating our PropertyOwner resolvers and dataSources</h2>
<p>This last entity is fairly simple in both porting over the resolver and the dataSource:</p>
<pre><code class="language-js">Query: {
    getPropertyOwnerById: (_parent, args, { prisma }) =&gt; {
        return getPropertyOwnerById(args.propertyOwnerId, prisma);
    },
    propertyOwners: (_parent, _args, { prisma }) =&gt; getAllPropertyOwners(prisma)
},
Mutation: {
    createPropertyOwner: (_parent, args, { prisma }) =&gt; {
        return createPropertyOwner(args.createPropertyOwnerInput, prisma);
    }
}
</code></pre>
<pre><code class="language-js">async function getPropertyOwnerById(propertyOwnerId, Prisma) {
    return Prisma.propertyOwners.findUnique({
        where: {
            id: propertyOwnerId
        },
        include: {
            properties: true
        }
    });
}

async function createPropertyOwner(propertyOwner, Prisma) {
    return Prisma.propertyOwners.create({
        data: {
            name: propertyOwner.name,
            address: propertyOwner.address,
            properties: {
                connect: propertyOwner.properties.map((propertyId) =&gt; ({ id: propertyId }))
            },
            photo: propertyOwner.photo,
            rating: 0.0,
            v: 0
        },
        include: {
            properties: true
        }
    });
}

async function getAllPropertyOwners(Prisma) {
    return Prisma.propertyOwners.findMany({
        include: {
            properties: true
        }
    });
}
</code></pre>
<h2>Transactions</h2>
<p>Let’s say you want to perform a query or mutation where you want to make sure that each independent query runs, but you want to ensure that you can roll it back if there is an error in between. This is where transactions come into play, and we will be creating a mutation to showcase an example, right now if you want to add a roommate to one Renter, it will not update the other Renter object saying they are both roommates. We will create a <strong>makeRoommates</strong> mutation in the Renter schema:</p>
<pre><code class="language-graphql">type Mutation {
    createRenter(createRenterInput: CreateRenterInput): Renter
    makeRoommates(renterIds: [ID]): [Renter]
}
</code></pre>
<p>Then we will add the method to the renters/resolver.js:</p>
<pre><code class="language-js">makeRoommates: async (_parent, args, { prisma }) =&gt; {
    return makeRoommates(args.renterIds, prisma);
}
</code></pre>
<p>Finally we will add the code for the makeRoommates method:</p>
<pre><code class="language-js">// Takes a list of renterIds and ensures that each renter
// contains a roommates field that has all the ids provided
async function makeRoommates(renterIds, Prisma) {
    const connectionRenterIds = renterIds.map((renterId) =&gt; ({ id: renterId }));
    const updates = renterIds.map((renterId) =&gt; Prisma.renters.update({
        where: {
            id: renterId
        },
        data: {
            roommates: {
                connect: connectionRenterIds.filter(({ id }) =&gt; id !== renterId)
            }
        },
        include: {
            roommates: true
        }
    }));
    return Prisma.$transaction(updates);
}
</code></pre>
<p>We will take the given ids, and then loop through each renterId provided in the input of the function to create an update where each Renter is a roommate of all the other Renters. Some things to point out on the syntax here for <strong>Prisma$.transaction</strong>: namely that I would suggest to follow the format that your transaction always includes a list of updates/mutations/queries like so:</p>
<pre><code class="language-js">Prisma.$transaction([update1, update2, update3])
</code></pre>
<p>While Prisma does have <strong>interactive transactions</strong> meaning you can call a method and use its result to perform another query/mutation/update, however you can run into many problems during debugging this. Namely that the transaction may close before all the operations complete, and can require you to reconfigure your timeout for transactions (which I would not recommend in this early stage of the project). Prisma often in its documentation mentions that before using a <strong>transaction</strong> you can think to see if <strong>Nested Writes</strong> may solve your problem (see <code>seed.js</code> for an example). Likewise the <strong>Batch/Bulk</strong> operations like <strong>deleteMany, updateMany, and createMany</strong> run as transactions, so you can use those methods instead.</p>
<p><strong>Apollo pause:</strong> To check if you have ported over to Prisma successfully, test by running the <code>seed.js</code> and re-run the endpoints you created for each entity, that will ensure that your project is in the correct state.</p>
<h2>Clean up and Conclusion</h2>
<p>Now that we have successfully migrated over to Prisma, we can remove all instances of the <code>models</code> folder, and any reference to Mongoose so that we can uninstall it. During this tutorial we introduced some of the features of Prisma and then ported our Models to instead use the <strong>schema.prisma</strong> file. We had re-created our relationships between models, and then updated our endpoints to use the Prisma CRUD methods. We then showed how to perform some rudimentary error handling, and finally showcased an example of a mutation leveraging Prisma’s Transaction API.</p>
<p>At the end of this tutorial you should have a repository similar to <a href="https://github.com/bitovi/node-graphql-tutorial-2023/tree/prisma">this</a></p>
<p>I hope this has given you a glimpse into the power of Prisma, and the next tutorial in the series will cover adding Jest testcases and Fragments to the project.</p>

</section>

  			
  			<bit-prev-next class="footer" list-selector=".sidebar-left ul li.parent.expanded ul"></bit-prev-next>
  		
    </div>

    
      <div class="sidebar-right">
        <div class="content-nav on-this-page-container">
          <h6>On this page...</h6>
          <div class="list-items" id="scroll-toc">
            <bit-toc heading-container-selector="article.main" scroll-selector="#scroll-toc"></bit-toc>
          </div>
        </div>
        <div class="pullout discord">
          <h6>Get help</h6>
          <p>If you need <a href="https://discord.gg/J7ejFsZnJ4">help</a> with an exercise, please reach out to us on
             <a href="https://discord.gg/J7ejFsZnJ4">Discord</a></p>
        </div>
        <div class="pullout bug">
          <p>If you find a bug, please
             <a href="https://github.com/bitovi/academy/issues/new">create an issue</a> or email
             <a href="mailto:contact@bitovi.com?Subject=Training%20Suggestion" target="_blank">contact@bitovi.com</a></p>
        </div>
      </div>
    

	</article>
</div>



  <footer></footer>

  <div id="scripts">
    <script type="text/javascript">
      var docObject = {"src":{"path":"src/graphql/3-porting-to-prisma/porting-to-prisma.md"},"description":"In this guide we will be working off of a starting point [project](https://github.com/bitovi/node-graphql-tutorial-2023/tree/mongodb) and will be removing the need for Mongoose and instead we will be using Prisma to perform our queries and mutations! \n","name":"learn-graphql/porting-to-prisma","title":"Converting Mongoose to Prisma","type":"page","parent":"learn-graphql","order":3,"comment":" ","pathToRoot":"../.."};
    </script>

    
      <script>
        steal = {
          instantiated: {
            "bundles/bit-docs-site/static.css!$css" : null
          }
        }
      </script>
      <script type='text/javascript'
          data-main="bit-docs-site/static"
          src="../static/steal.production.js"></script>
    

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-2302003-12"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-2302003-12');
    </script>

  </div>
  <div id="email-modal" role="dialog" aria-modal="true" aria-labelledby="dialog_label" style="display: none;">
    <div aria-hidden="true" class="email-modal-backdrop"></div>
    <div role="region" class="email-modal-content">
      <h2 id="dialog_label">Join the Bitovi Newsletter</h2>
      <p>
        Do you want to receive updates about new Bitovi Academy courses, Bitovi open source projects, and dev community news? If so, please provide your email. We won’t spam you or give it away for any reason!<br />
        <i style="font-size: 0.8rem;">By providing your email you agree to receive communications from Bitovi</i>
      </p>
      <div id="academy-hubspot-form-embed"></div>
      <script charset="utf-8" type="text/javascript" src="//js.hsforms.net/forms/embed/v2.js"></script>
      <button id="email-modal-close" title="dismiss"><img src="../static/img/close.svg" height="24" width="24"></button>
    </div>
  </div>
</body>
</html>
